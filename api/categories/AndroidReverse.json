{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"postlist":[{"title":"Android got hook","uid":"08f55e9615384c7275f59ed241f8ccbd","slug":"Android-got-hook","date":"2021-06-09T06:24:12.000Z","updated":"2021-06-10T07:37:53.107Z","comments":true,"path":"api/articles/Android-got-hook.json","keywords":null,"cover":"https://th.wallhaven.cc/small/6o/6od3px.jpg","text":"原理 核心原理就是查找程序头表中的动态segment，然后查看虚拟内存映射到哪个位置，也就是rva，可以直接去ida中查看偏移， 因为我发现ida去解析so文件的时候，是看segment表去解析的，所以ida直接就是一个起始地址为0的虚拟内存（，先去010查看这个段在哪，然后发现...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"got表hook","slug":"got表hook","count":1,"path":"api/tags/got表hook.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},{"title":"Android8.0 art下面的几个脱壳点","uid":"05699e0b3c4e02c2136460838badc80b","slug":"Android8-0-art下面的几个脱壳点","date":"2021-06-11T16:10:05.000Z","updated":"2021-06-11T17:09:36.572Z","comments":true,"path":"api/articles/Android8-0-art下面的几个脱壳点.json","keywords":null,"cover":"https://w.wallhaven.cc/full/5w/wallhaven-5w3dm8.jpg","text":"前言搞了一个17年decon 会议的ppt，里面对市面上的一些apk加固方式有一些整体分析，实际上手动脱壳，现在越来越难了，时间成本太大了，各种莫名的反调试和混淆，so的话，俺也不太会搞vmp，在学了在学了（我太菜了，java层的话，还是有突破口的，毕竟dex再怎么加固，最终还是...","link":"","photos":[],"count_time":{"symbolsCount":843,"symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"AndroidUnPacker","slug":"AndroidUnPacker","count":1,"path":"api/tags/AndroidUnPacker.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},{"title":"Android锁机勒索病毒分析","uid":"4b0b858a57a6176d5e34068e8d18965f","slug":"Android锁机勒索病毒分析","date":"2021-06-29T03:54:43.000Z","updated":"2021-06-29T08:59:31.243Z","comments":true,"path":"api/articles/Android锁机勒索病毒分析.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/8o/8oev1j.jpg","text":"前言有一说一，我拉了，好几个模拟器运行这个apk，发现没啥特别的，静态分析一看，发现里面有su等一大堆的命令，mmp，所以说没root的话，一切免谈，不打算在真机上试，直接静态分析，嘿嘿 jeb静态分析开始从开始界面找起，因为这种恶意软件的启动肯定要有一个触发点，一般是在必经的地...","link":"","photos":[],"count_time":{"symbolsCount":938,"symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":22,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},{"title":"SVC指令获取设备信息&内联汇编","uid":"90a1c6273d337dfc4b6067dd868be1ed","slug":"SVC指令获取设备信息-内联汇编","date":"2021-06-28T07:05:01.000Z","updated":"2021-06-28T15:41:55.182Z","comments":true,"path":"api/articles/SVC指令获取设备信息-内联汇编.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/rd/rdyyjm.jpg","text":"前言目前越来越多的api，采用svc进行直接系统调用，syscall也不用了，直接内联汇编，然后svc，可以防止hook，不过最近在看雪也看到一篇修改内核的操作反操作的，之后打算再研究研究。 syscallsyscall可以说是系统层给用户层提供的一个调用内核态代码的api，我们...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":22,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},{"title":"Xposed编写inlinehook框架插件02","uid":"81adc87c645a49aab325f38e6f3026a2","slug":"Xposed编写inlinehook框架插件02","date":"2021-07-26T08:35:24.000Z","updated":"2021-07-26T08:48:55.416Z","comments":true,"path":"api/articles/Xposed编写inlinehook框架插件02.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/pk/pkw6y3.jpg","text":"前言吐槽下，妈的，应该是框架本身的bug，好像hook自己编写的函数无参数的话，就会莫名报错，这里耽误了我几个小时，最终才发现了这个问题，鬼知道我开关机了几次妈的。 正式开始 被hook的app的核心逻辑 #include &lt;jni.h&gt; #include &lt;s...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"xposed","slug":"xposed","count":2,"path":"api/tags/xposed.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},{"title":"android的PMS动态代理","uid":"668f1dbfd60678f860dbea390d6a69fb","slug":"android的PMS动态代理","date":"2021-07-02T06:26:47.000Z","updated":"2021-07-02T06:54:06.525Z","comments":true,"path":"api/articles/android的PMS动态代理.json","keywords":null,"cover":"https://th.wallhaven.cc/small/28/281d5y.jpg","text":"前言目前在java层中签名验证是使用java层的api进行获取，然后进行判断，可以选择hook，也可以使用安卓本身的特性去hook，不使用任何hook框架去实现hook 代理是什么？结合我自己的理解来说，动态代理实际上就是比如你想找别人，但是你不自己去找，而是委托另一个人去找，把...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":22,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},{"title":"xposed插件编写01","uid":"2baa56a271382e4f44c5cafacec7639e","slug":"xposed插件编写01","date":"2021-07-25T11:46:40.000Z","updated":"2021-07-25T12:26:22.976Z","comments":true,"path":"api/articles/xposed插件编写01.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/8o/8oky1j.jpg","text":"前置准备两个apk（一个xposed模块，一个要hook的apk） xposed模块准备 直接选择nativec++创建就行，然后就是配置需要注意 在app目录下的build.gradle文件中修改这几点 externalNativeBuild &#123; cmake &#12...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"xposed","slug":"xposed","count":2,"path":"api/tags/xposed.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},{"title":"修改ro.debuggable的坑以及有效方式","uid":"0558c37e07e30bb941d09a486e640b0f","slug":"修改ro-debuggable的坑以及有效方式","date":"2021-07-28T07:33:43.000Z","updated":"2021-07-28T07:37:09.949Z","comments":true,"path":"api/articles/修改ro-debuggable的坑以及有效方式.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/57/5758y8.jpg","text":"有效方式 android8.1 pixel完美修改，然后mprop，以及xdebuggable，我都使用了，但是还是不行，建议用这个面具来搞，我是用卡刷的，github上下载，然后模块安装 https://github.com/Magisk-Modules-Repo/Magisk...","link":"","photos":[],"count_time":{"symbolsCount":174,"symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":22,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},{"title":"2015阿里移动安全挑战赛5道题writeup","uid":"48c7547c87104b3665dc18f2c480b135","slug":"阿里移动安全挑战赛5道题","date":"2021-07-28T03:15:34.000Z","updated":"2021-07-30T02:39:10.290Z","comments":true,"path":"api/articles/阿里移动安全挑战赛5道题.json","keywords":null,"cover":"https://w.wallhaven.cc/full/dg/wallhaven-dg2dog.jpg","text":"Alicrackme_1jeb打开 逻辑非常简单就是调用了两个方法，返回一张表，和密文，而我们的输入是作为表的下标去进行检索。 不过在用frida dump下结果后，发现竟然是中文，我还想转换成字节数组，后面发现一个索引对一个中文， 直接写脚本撸就行 public class g...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":22,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},{"title":"美团的jnionload反混淆","uid":"575d038a35fac80847b9d48c9af690e7","slug":"美团的jnionload反混淆","date":"2021-08-30T03:15:40.000Z","updated":"2021-09-04T08:15:16.266Z","comments":true,"path":"api/articles/美团的jnionload反混淆.json","keywords":null,"cover":"https://w.wallhaven.cc/full/n6/wallhaven-n6eymw.jpg","text":" 本来想放脚本的，怕被gank，所以就不放了，说下思路，这种花指令似乎变得很普遍的，实际上没啥好怕的，可以手动分析它的跳转逻辑，自己去模拟下栈，以及地址的计算，会发现其实一堆的代码就是在计算出地址而已，那么我们同样可以本地计算，那么人手计算肯定慢，下一步肯定是往自动化，unico...","link":"","photos":[],"count_time":{"symbolsCount":234,"symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"反混淆（花指令)","slug":"反混淆（花指令","count":1,"path":"api/tags/反混淆（花指令.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},{"title":"利用lief重构androidemu的loader","uid":"6fe260c9125d041c2eb579635ea7b945","slug":"利用lief重构androidemu的loader","date":"2021-09-07T08:41:49.000Z","updated":"2021-09-07T09:00:23.699Z","comments":true,"path":"api/articles/利用lief重构androidemu的loader.json","keywords":null,"cover":null,"text":"先放一手代码 import ctypes UC_MEM_ALIGN &#x3D; 0x1000 PF_X &#x3D; 0x1 # Executable PF_W &#x3D; 0x2 # Writable PF_R &#x3D; 0x4 # Readable # Thansk ...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":22,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}]}