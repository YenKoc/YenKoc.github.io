[{"id":"0558c37e07e30bb941d09a486e640b0f","title":"修改ro.debuggable的坑以及有效方式","content":"有效方式\nandroid8.1 pixel完美修改，然后mprop，以及xdebuggable，我都使用了，但是还是不行，建议用这个面具来搞，我是用卡刷的，github上下载，然后模块安装\nhttps://github.com/Magisk-Modules-Repo/MagiskHidePropsConf/releases/tag/v5.4.0\n","slug":"修改ro-debuggable的坑以及有效方式","date":"2021-07-28T07:33:43.000Z","categories_index":"AndroidReverse","tags_index":"reverse","author_index":"YenKoc"},{"id":"48c7547c87104b3665dc18f2c480b135","title":"2015阿里移动安全挑战赛5道题writeup","content":"Alicrackme_1jeb打开\n\n逻辑非常简单就是调用了两个方法，返回一张表，和密文，而我们的输入是作为表的下标去进行检索。\n不过在用frida dump下结果后，发现竟然是中文，我还想转换成字节数组，后面发现一个索引对一个中文，\n直接写脚本撸就行\npublic class getFlag&#123;\n    public static void main(String[] args) &#123;\n        String table&#x3D;&quot;一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们仪白仔他斥瓜乎丛令用甩印乐&quot;;\n                String pw&#x3D;&quot;义弓么丸广之&quot;;\n                String flag&#x3D;&quot;&quot;;\n                for(int i&#x3D;0;i&lt;pw.length();i++)\n                &#123;\n                    flag+&#x3D;(char)table.indexOf(pw.charAt(i));\n                &#125;\n                System.out.println(flag);\n&#125;\n&#125;\n\n\nflag: 581026\nAlicrackme_2","slug":"阿里移动安全挑战赛5道题","date":"2021-07-28T03:15:34.000Z","categories_index":"AndroidReverse","tags_index":"reverse","author_index":"YenKoc"},{"id":"81adc87c645a49aab325f38e6f3026a2","title":"Xposed编写inlinehook框架插件02","content":"前言吐槽下，妈的，应该是框架本身的bug，好像hook自己编写的函数无参数的话，就会莫名报错，这里耽误了我几个小时，最终才发现了这个问题，鬼知道我开关机了几次妈的。\n正式开始\n被hook的app的核心逻辑\n#include &lt;jni.h&gt;\n#include &lt;string&gt;\n#include &lt;string.h&gt;\n#include &quot;android&#x2F;log.h&quot;\nint myr0(char* str) &#123;\n    if (strstr(str, &quot;YenKoc&quot;) !&#x3D; nullptr) &#123;\n\n        __android_log_print(4, &quot;YenKoc&quot;, &quot;i am  success&quot;);\n\n\n    &#125; else &#123;\n\n        __android_log_print(4, &quot;YenKoc&quot;, &quot;i ma fail&quot;);\n    &#125;\n    return reinterpret_cast&lt;int&gt;(strstr(str, &quot;YenKoc&quot;));\n&#125;\n\nextern &quot;C&quot; JNIEXPORT jstring JNICALL\nJava_com_example_hooksoexample01_MainActivity_stringFromJNI(\n        JNIEnv* env,\n        jobject &#x2F;* this *&#x2F;) &#123;\n    std::string hello &#x3D; &quot;Hello from C++&quot;;\n    if(myr0(&quot;123456789&quot;))&#123;\n        __android_log_print(4,&quot;YenKoc&quot;,&quot;myr0 is true  &quot;);\n    &#125;\n    else &#123;\n\n        __android_log_print(4,&quot;YenKoc&quot;,&quot;myr0 is false&quot;);\n    &#125;\n\n    return env-&gt;NewStringUTF(hello.c_str());\n&#125;\n\nhook的逻辑\n这里需要先明确一个问题，就是我们的hook的so，不像上一篇是hook libc的so，libc的so是在安卓的白名单中的，所以我们可以直接用dlopen打开，但是我们的so不在白名单，那么只能利用查看内存空间，根据符号表，或者偏移实现了，这里也是用的别的大佬开源的框架导入一手就行\n\ncmake记得导入\n剩下就是编写真正hook逻辑了\n#include &lt;jni.h&gt;\n#include &lt;string&gt;\nextern &quot;C&quot;&#123;\n    #include &quot;inlinehookk&#x2F;inlineHook.h&quot;\n    #include &quot;dlfcn&#x2F;dlfcn_compat.h&quot;\n    #include &quot;dlfcn&#x2F;dlfcn_nougat.h&quot;\n&#125;\n\n\n#include &quot;android&#x2F;log.h&quot;\n#include &lt;stdio.h&gt;\n#include &lt;dlfcn.h&gt;\n\nint (*old_judge)() &#x3D; NULL;\n\nint new_judge()\n&#123;\n    __android_log_print(4,&quot;YenKoc&quot;,&quot;i hook success %s&quot;);\n\n    return 1;\n\n&#125;\n\nint hook()\n&#123;\n   void* handle&#x3D; dlopen_compat(&quot;&#x2F;data&#x2F;app&#x2F;com.example.hooksoexample01-Ox57xIxBDLPq0xQ-MNJm-g&#x3D;&#x3D;&#x2F;lib&#x2F;arm&#x2F;libnative-lib.so&quot;,RTLD_NOW);\n   void* judgeaddr&#x3D;dlsym_compat(handle,&quot;_Z4myr0v&quot;);\n   __android_log_print(4,&quot;YenKoc&quot;,&quot; i hook success libaddr:%s&quot;,handle);\n    __android_log_print(4,&quot;YenKoc&quot;,&quot; i hook success funcaddr:%x&quot;,judgeaddr);\n    if (registerInlineHook((uint32_t) judgeaddr, (uint32_t) new_judge, (uint32_t **) &amp;old_judge) !&#x3D; ELE7EN_OK) &#123;\n        return -1;\n    &#125;\n    if (inlineHook((uint32_t) judgeaddr) !&#x3D; ELE7EN_OK) &#123;\n        return -1;\n    &#125;\n\n    return 0;\n&#125;\n\nint unHook()\n&#123;\n    if (inlineUnHook((uint32_t) puts) !&#x3D; ELE7EN_OK) &#123;\n        return -1;\n    &#125;\n\n    return 0;\n&#125;\nextern &quot;C&quot; void _init(void) &#123;\n    __android_log_print(4,&quot;YenKoc&quot;,&quot; i enter into init&quot;);\n     hook();\n&#125;\n\n\n&#x2F;&#x2F; 编译生成后在.init_array段 [名字可以更改]\n&#x2F;*__attribute__((__constructor__)) static void pp_init() &#123;\n    PPLOGD(&quot;Enter pp_init......&quot;);\n&#125;\n *&#x2F;\n&#x2F;&#x2F; jni_onload方法\n&#x2F;*\njint JNI_OnLoad(JavaVM *vm, void *reserved) &#123;\n\n    JNIEnv *env &#x3D; NULL;\n\n    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_4) !&#x3D; JNI  _OK) &#123;  &#x2F;&#x2F;判断 JNI 版本是否为JNI_VERSION_1_4\n        return JNI_EVERSION;\n    &#125;\n\n\n\n    return JNI_VERSION_1_4;\n&#125;\n *&#x2F;\nextern &quot;C&quot; JNIEXPORT jstring JNICALL\nJava_com_example_kanxuexposedso1_MainActivity_stringFromJNI(\n        JNIEnv* env,\n        jobject &#x2F;* this *&#x2F;) &#123;\n    std::string hello &#x3D; &quot;Hello from C++&quot;;\n    return env-&gt;NewStringUTF(hello.c_str());\n&#125;\n\n这里讲几点，一个是关于路径问题，路径的话，实际上就是/da ta/app/包名的变化/lib/arm/下的so文件名，这里直接adb进入查看就好了，问题一般不大，然后就是符号名，c++是有符号修饰，直接ida打开看，或者objection也可以，目前还是为了去寻找地址，剩下就是我们将hook逻辑都放在init段了，这样就可以直接启动，其他initarray和jnionload也在里面。\n\nxposed逻辑\npackage com.example.kanxuexposedso1;\n\nimport android.util.Log;\n\nimport de.robv.android.xposed.IXposedHookLoadPackage;\nimport de.robv.android.xposed.XC_MethodHook;\nimport de.robv.android.xposed.XposedBridge;\nimport de.robv.android.xposed.XposedHelpers;\nimport de.robv.android.xposed.callbacks.XC_LoadPackage;\n\npublic class Xmodule implements IXposedHookLoadPackage &#123;\n    @Override\n    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123;\n        if(lpparam.packageName.equals(&quot;com.example.hooksoexample01&quot;))\n        &#123;\n            Class systemClass&#x3D;lpparam.classLoader.loadClass(&quot;java.lang.Runtime&quot;);\n            XposedBridge.hookAllMethods(systemClass, &quot;loadLibrary0&quot;, new XC_MethodHook() &#123;\n                @Override\n                protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;\n                    super.beforeHookedMethod(param);\n                &#125;\n\n                @Override\n                protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;\n                    super.afterHookedMethod(param);\n                    String libname&#x3D;(String)param.args[1];\n                    Log.e(&quot;YenKoc::&quot;,libname);\n                    if(libname.indexOf(&quot;native-lib&quot;)!&#x3D;-1)\n                    &#123;\n                        System.load(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;b.so&quot;);\n                    &#125;\n\n\n                &#125;\n            &#125;);\n\n        &#125;\n    &#125;\n&#125;\n\n\n这里indexOf差点把我坑了，这里是指括号里面的在libname中的下标，之前一直搞反了。\n\n\n","slug":"Xposed编写inlinehook框架插件02","date":"2021-07-26T08:35:24.000Z","categories_index":"AndroidReverse","tags_index":"xposed","author_index":"YenKoc"},{"id":"2baa56a271382e4f44c5cafacec7639e","title":"xposed插件编写01","content":"前置准备两个apk（一个xposed模块，一个要hook的apk）\nxposed模块准备\n直接选择nativec++创建就行，然后就是配置需要注意\n在app目录下的build.gradle文件中修改这几点\nexternalNativeBuild &#123;\n           cmake &#123;\n               cppFlags &quot;&quot;\n           &#125;\n           ndk&#123;\n               abiFilters &quot;armeabi-v7a&quot;\n           &#125;\n       &#125;\n\nrepositories &#123;\n    jcenter()\n&#125;\n\ndependencies &#123;\n    compileOnly &#39;de.robv.android.xposed:api:82&#39;\n    compileOnly &#39;de.robv.android.xposed:api:82:sources&#39;\n&#125;\n\n然后在AndroidManifest.xml的application标签下加入\n&lt;meta-data android:name&#x3D;&quot;xposedmodule&quot; android:value&#x3D;&#39;true&#39;&#x2F;&gt;\n      &lt;meta-data android:name&#x3D;&quot;xposeddescription&quot; android:value&#x3D;&quot;kanxueso1&quot;&#x2F;&gt;\n      &lt;meta-data android:name&#x3D;&quot;xposedminversion&quot; android:value&#x3D;&quot;82&quot;&#x2F;&gt;\n      \n开始编写hook逻辑\n这里选择是套e佬的inlinehook框架，有轮子就上轮子，\n\ncmake里面也需要改下，把这些文件依赖导入进去\nadd_library( # Sets the name of the library.\n             native-lib\n\n             # Sets the library as a shared library.\n             SHARED\n\n             # Provides a relative path to your source file(s).\n            inlinehookk&#x2F;inlineHook.cpp\n            inlinehookk&#x2F;inlineHook.h\n            inlinehookk&#x2F;relocate.cpp\n            inlinehookk&#x2F;relocate.h\n\n             native-lib.cpp\n            )\n\n#include &lt;jni.h&gt;\n#include &lt;string&gt;\nextern &quot;C&quot;&#123;\n    #include &quot;inlinehookk&#x2F;inlineHook.h&quot;\n&#125;\n#include &quot;android&#x2F;log.h&quot;\n#include &lt;stdio.h&gt;\n#include &lt;dlfcn.h&gt;\n\nint (*old_strstr)(const char *,const char *) &#x3D; NULL;\n\nint new_strstr(const char *string,const char* myStr)\n&#123;\n    __android_log_print(4,&quot;YenKoc&quot;,&quot;i hook success %s&quot;,myStr);\n    if(!strcmp(myStr,&quot;YenKoc&quot;))\n    &#123;\n        return 100;\n    &#125;else&#123;\n        return old_strstr(string,myStr);\n    &#125;\n\n&#125;\n\nint hook()\n&#123;\n   void* handle&#x3D; dlopen(&quot;libc.so&quot;,RTLD_NOW);\n   void* strstraddr&#x3D;dlsym(handle,&quot;strstr&quot;);\n    if (registerInlineHook((uint32_t) strstraddr, (uint32_t) new_strstr, (uint32_t **) &amp;old_strstr) !&#x3D; ELE7EN_OK) &#123;\n        return -1;\n    &#125;\n    if (inlineHook((uint32_t) strstraddr) !&#x3D; ELE7EN_OK) &#123;\n        return -1;\n    &#125;\n\n    return 0;\n&#125;\n\nint unHook()\n&#123;\n    if (inlineUnHook((uint32_t) puts) !&#x3D; ELE7EN_OK) &#123;\n        return -1;\n    &#125;\n\n    return 0;\n&#125;\nextern &quot;C&quot; JNIEXPORT jstring JNICALL\nJava_com_example_kanxuexposedso1_MainActivity_stringFromJNI(\n        JNIEnv* env,\n        jobject &#x2F;* this *&#x2F;) &#123;\n    std::string hello &#x3D; &quot;Hello from C++&quot;;\n    hook();\n    return env-&gt;NewStringUTF(hello.c_str());\n&#125;extern &quot;C&quot;\nJNIEXPORT void JNICALL\nJava_com_example_kanxuexposedso1_Xmodule_hookhook(JNIEnv *env, jobject thiz) &#123;\n    hook();\n&#125;\n\nxposed这里先注册一个native函数，方便调用，不过不可能直接调用的，每次hook用的都是被hook app的classloader，会找不到代码执行的，说白了，进程内存中根本没你那段代码，执行个锤子（，所以我们需要得是将so注入进去\npackage com.example.kanxuexposedso1;\n\nimport de.robv.android.xposed.IXposedHookLoadPackage;\nimport de.robv.android.xposed.XC_MethodHook;\nimport de.robv.android.xposed.XposedBridge;\nimport de.robv.android.xposed.XposedHelpers;\nimport de.robv.android.xposed.callbacks.XC_LoadPackage;\n\npublic class Xmodule implements IXposedHookLoadPackage &#123;\n    public native void hookhook();\n    @Override\n    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123;\n        if(lpparam.packageName.equals(&quot;com.example.hooksoexample01&quot;))\n        &#123;\n            Class systemClass&#x3D;lpparam.classLoader.loadClass(&quot;java.lang.Runtime&quot;);\n            XposedBridge.hookAllMethods(systemClass, &quot;loadLibrary0&quot;, new XC_MethodHook() &#123;\n                @Override\n                protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;\n                    super.beforeHookedMethod(param);\n                &#125;\n\n                @Override\n                protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;\n                    super.afterHookedMethod(param);\n                    System.load(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;a.so&quot;);\n                    hookhook();\n                &#125;\n            &#125;);\n\n        &#125;\n    &#125;\n&#125;\n\n\n这里的so文件，是我将编译后的apk中的so文件取出了（，每次app启动自动注入so到内存中\n\n被hook的app的核心逻辑\n#include &lt;jni.h&gt;\n#include &lt;string&gt;\n\nextern &quot;C&quot; JNIEXPORT jstring JNICALL\nJava_com_example_hooksoexample01_MainActivity_stringFromJNI(\n        JNIEnv* env,\n        jobject &#x2F;* this *&#x2F;) &#123;\n    std::string hello &#x3D; &quot;Hello from C++&quot;;\n    if(strstr(&quot;fast&quot;,&quot;YenKoc&quot;)!&#x3D;nullptr)\n    &#123;\n        hello&#x3D;&quot;you are hooked&quot;;\n    &#125;\n\n    return env-&gt;NewStringUTF(hello.c_str());\n&#125;\n\n到此为止，基本上hook完成，屏幕就不截图了，结果是you are hooked，不过这次对我来说，有了一些感悟吧2333\n\n\n总结之前就有想过就是inlinehook这东西，我要如何去加入到我的逻辑上，之前陷入就是在自己开发的app中加入inlinehook没啥问题，但是去hook其他app时，总会感觉很迷茫，但是经过下午的练习，慢慢有了感觉，发现我对本质的东西之前是没有去理解，实际上我们去inlinehook肯定是找到某个函数的地址，然后架设跳板，之前在自己开发的app是完全可以实现的，因为我们hook逻辑也是写在本身的app进程中的，而且是由我们自己决定是否调用的，但是hook别的app，我们的hook逻辑是写在别的地方的，无法进去app进程，连进程空间都进不去，谈何hook，所以说我们需要去把hook的逻辑注入到app的进程内存，这样我们的hook逻辑和被hook的地方处在了一个空间中，我们的hook逻辑是可以对它进行操作的，剩下的问题就是调用起hook逻辑了，这里xposed设置native函数，也是为了调用起来，毕竟注入进去后，我们如果不提供接口出来，其实很难去操作的，但是我又想到了，就是dll注入中，每次注入是不是会自动执行某种入口函数xxmain，作为类linux平台也是一样的，so文件载入内存中，会先执行init。initarray段函数，再执行jni_onload函数，这些函数无需人为调用，是由linker完成的，所以我们也可以将hook逻辑写在这几个地方，让它自己执行就行。\n","slug":"xposed插件编写01","date":"2021-07-25T11:46:40.000Z","categories_index":"AndroidReverse","tags_index":"xposed","author_index":"YenKoc"},{"id":"668f1dbfd60678f860dbea390d6a69fb","title":"android的PMS动态代理","content":"前言目前在java层中签名验证是使用java层的api进行获取，然后进行判断，可以选择hook，也可以使用安卓本身的特性去hook，不使用任何hook框架去实现hook\n代理是什么？结合我自己的理解来说，动态代理实际上就是比如你想找别人，但是你不自己去找，而是委托另一个人去找，把事情交给另一个人去办的，这里注意细节，就是当你把事情委托给别人的时候，别人会怎么去办这件事，你是管不着的，不需要你去管，他只需要把事情做完就行，至于diy些其他操作也是属于正常操作。\n用代码说明下\n&#x2F;&#x2F;共同实现的接口\npublic interface IHelloWorld &#123;\n    public void helloWorld(String str);\n&#125;\n \n&#x2F;&#x2F;真实对象\npublic class RealSubject implements IHelloWorld &#123;\n    @Override\n    public void helloWorld() &#123;\n        System.out.println(&quot;RealSubject say hello world&quot;);\n    &#125;\n&#125;\n \n&#x2F;&#x2F;代理对象\npublic class Proxy implements IHelloWorld &#123;    \n    private IHelloWorld subject;\n \n    public Proxy(IHelloWorld subject) &#123;\n        this.subject &#x3D; subject;\n    &#125;\n \n    @Override\n    public void helloWorld() &#123;\n        &#x2F;&#x2F;代理类的私货\n        System.out.println(&quot;Proxy say hello world&quot;);  \n     \n        &#x2F;&#x2F;被代理对象的真实调用\n        subject.helloWorld();\n    &#125;\n&#125;\n \n \n&#x2F;&#x2F;实际调用\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;被代理的对象\n    RealSubject realSubject &#x3D; new RealSubject();\n \n    &#x2F;&#x2F;代理类对象\n    Proxy proxy &#x3D; new Proxy(realSubject);\n \n    &#x2F;&#x2F;调用代理类对象的方法\n    proxySubject.helloWorld();\n&#125;\n\n其实代码写的很清楚了，这是静态代理，我只是用这个举例，本来直接调用的不是很方便吗，为什么出现了一个代理，实际在代理对象中，我们可以搞的事情就很多了，可以在本来调用的方法中加入另外定制的代码，嘿嘿，加上一个是同一个接口，那么方法名都是一样的，实际上就是hook了。。\n动态代理动态代理模式是和静态代理模式差不多，不过就是不在我们自己定义代理对象了，实现接口就可以自动生成动态代理对象，结合代码\nObject proxy&#x3D; Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),new Class&lt;?&gt;[]&#123;iPackageManagerInterface&#125;,new PMSHookBinderInvocationHandler(sPackagerManager,signed,appPkgName,0));\n            sPackageManagerField.set(currentActivityThread,proxy);\n\nnew PMS那行代码就是实现了InvocationHandler这个接口的，调用这个Proxy.newProxyInstance方法自动生成了代理对象，另外实现接口的那个类，实际上是彻底补充了代理对象的功能，也就是帮原对象实现功能，同时加入我们的hook代码，当这个代理对象执行方法时，会先跑到我们实现接口的那个对象中的invoke方法。\nandroid里面的pms动态代理实现package com.example.puatest;\n\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.Signature;\nimport android.text.method.SingleLineTransformationMethod;\nimport android.util.Log;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class PMSHookBinderInvocationHandler implements InvocationHandler &#123;\n    private Object base;\n    public final static String yk&#x3D;&quot;YenKoc&quot;;\n\n    &#x2F;&#x2F;应用正确的签名信息\n    private String SIGN;\n    private String appPkgName&#x3D;&quot;&quot;;\n    public PMSHookBinderInvocationHandler(Object sPackagerManager, String signed, String appPkgName, int i) &#123;\n        try&#123;\n            this.base&#x3D;sPackagerManager;\n            this.SIGN&#x3D;signed;\n            this.appPkgName&#x3D;appPkgName;\n        &#125;catch (Exception e)\n        &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n            Log.i(&quot;YenKoc&quot;,&quot;调用了代理方法&quot;);\n        if(&quot;getPackageInfo&quot;.equals(method.getName()))&#123;\n            String pkgName&#x3D;(String)args[0];\n            Integer flag&#x3D;(Integer)args[1];\n            if(flag&#x3D;&#x3D; PackageManager.GET_SIGNATURES&amp;&amp;appPkgName.equals(pkgName))\n            &#123;\n                Signature sign&#x3D;new Signature(SIGN);\n                &#x2F;&#x2F;调用原来的方法\n                PackageInfo info&#x3D;(PackageInfo)method.invoke(base,args);\n                info.signatures[0]&#x3D;sign;\n                return info;\n            &#125;\n        &#125;\n        return method.invoke(base,args);\n    &#125;\n&#125;\n\n\n\n\npackage com.example.puatest;\n\nimport android.content.Context;\nimport android.content.pm.PackageManager;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class ServiceManagerWrapper &#123;\n    public final static String yk&#x3D;&quot;YenKoc&quot;;\n\n    public static void hookPMS(Context context,String signed,String appPkgName,int hashcode)\n    &#123;\n        try&#123;\n            Class&lt;?&gt; activityThreadClass&#x3D;Class.forName(&quot;android.app.ActivityThread&quot;);\n            Method currentActivityThreadMethod&#x3D;activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);\n            Object currentActivityThread&#x3D;currentActivityThreadMethod.invoke(null);\n            &#x2F;&#x2F;获取ActivityThread里面原始sPackageManager\n            Field sPackageManagerField&#x3D;activityThreadClass.getDeclaredField(&quot;sPackageManager&quot;);\n            sPackageManagerField.setAccessible(true);\n            Object sPackagerManager&#x3D;sPackageManagerField.get(currentActivityThread);\n            &#x2F;&#x2F;准备好代理对象\n            Class&lt;?&gt; iPackageManagerInterface&#x3D;Class.forName(&quot;android.content.pm.IPackageManager&quot;);\n            Object proxy&#x3D; Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),new Class&lt;?&gt;[]&#123;iPackageManagerInterface&#125;,new PMSHookBinderInvocationHandler(sPackagerManager,signed,appPkgName,0));\n            sPackageManagerField.set(currentActivityThread,proxy);\n            &#x2F;&#x2F;替换applicationpackageManager里面的mPM对象\n            PackageManager pm&#x3D;context.getPackageManager();\n            Field mPmField&#x3D;pm.getClass().getField(&quot;mPM&quot;);\n            mPmField.setAccessible(true);\n            mPmField.set(pm,proxy);\n\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    public  static void hookPMS(Context base)\n    &#123;\n        String sigg&#x3D;&quot;12342355&quot;;\n        hookPMS(base,sigg,&quot;com.example.puatest&quot;,0);\n    &#125;\n\n&#125;\n\n\npackage com.example.puatest;\n\nimport android.app.Application;\nimport android.content.Context;\nimport android.util.Log;\n\npublic class wrapApplication extends Application &#123;\n    @Override\n    protected void attachBaseContext(Context base) &#123;\n        Log.i(&quot;YenKoc&quot;,&quot;进入&quot;);\n        ServiceManagerWrapper.hookPMS(base);\n        super.attachBaseContext(base);\n    &#125;\n&#125;\n\n\n","slug":"android的PMS动态代理","date":"2021-07-02T06:26:47.000Z","categories_index":"AndroidReverse","tags_index":"reverse","author_index":"YenKoc"},{"id":"4b0b858a57a6176d5e34068e8d18965f","title":"Android锁机勒索病毒分析","content":"前言有一说一，我拉了，好几个模拟器运行这个apk，发现没啥特别的，静态分析一看，发现里面有su等一大堆的命令，mmp，所以说没root的话，一切免谈，不打算在真机上试，直接静态分析，嘿嘿\njeb静态分析开始从开始界面找起，因为这种恶意软件的启动肯定要有一个触发点，一般是在必经的地方，否则很有可能会触发不了，所以从开始界面开始操作，发现了一个很奇怪的地方\n\n这里出现了一个很奇怪的类名，其他我稍微跟了下，发现功能没啥大问题，这东西似乎就是遍历wifi列表，然后显示，继续跟进去这个奇奇怪怪的东西。\n\n继续跟进去\n\n还挺坏，基本就是每次复制之后，然后就删掉，最后的那个锁机的apk，就是这个叫cia.apk的东西了，不过我不想运行，所以只能本地解密后，再静态分析了。\n本地解密成apk文件Python2\nf&#x3D;open(&quot;date.jar&quot;,&quot;rb&quot;)\nf2&#x3D;open(&quot;finalres.txt&quot;,&quot;wb&quot;)\ndate&#x3D;&#39;&#39;\nfor i in f.read():\n    date+&#x3D;i\nxor7&#x3D;lambda x:chr(ord(x)^(358&amp;0xff))\nfinal&#x3D;&quot;&quot;.join(map(xor7,date))\nf2.write(final)\n\nfinalres.txt是我自己新建的一个空白文件，里面啥都没有，存放解密后的字节流的。\n解密后的效果:\n\n改下后缀，jeb就可以跑了\n继续分析这个apk\n\n新建了一个线程\n\n这里其实我网上搜了下，基本上锁机软件都有这段代码，我估计是控制屏幕的（。\n\n这里新起了一个service，继续看看这个service\n\n这里就是关键逻辑的地方了，初诺加数字，这个类是它自定义的一个类，里面全是android api的加密算法。\n看了下解密用的就是一个aes的算法\n\n这里就是最终判断的地方了，可见这位兄弟写的代码有多烂，分分钟被破（，这水平还勒索呢。。。\n直接hook GetMD5Code方法的返回值，为我输入的，直接没了，甚至都不需要解密。\n","slug":"Android锁机勒索病毒分析","date":"2021-06-29T03:54:43.000Z","categories_index":"AndroidReverse","tags_index":"reverse","author_index":"YenKoc"},{"id":"90a1c6273d337dfc4b6067dd868be1ed","title":"SVC指令获取设备信息&内联汇编","content":"前言目前越来越多的api，采用svc进行直接系统调用，syscall也不用了，直接内联汇编，然后svc，可以防止hook，不过最近在看雪也看到一篇修改内核的操作反操作的，之后打算再研究研究。\nsyscallsyscall可以说是系统层给用户层提供的一个调用内核态代码的api，我们使用open，read等函数，实际上最后也会调用到syscall这个系统调用函数，那么如果我们不去使用libc中的函数时，因为太容易被hook，那么我们是不是也可以同样实现它的底层函数，进而实现相同效果，同时还不容易被hook,实际上syscall底层还是调用svc进入内核态的，把libc.so从我的皮鞋上扒下来，ida反汇编看看。\n\n上面是f5的样子，实际上的汇编。\n\n所以根据这里，我们是不是可以模仿这种写法，自己构造底层函数，以防止被轻易hook，毕竟内核态的内存是不能动的。\n先导入一手头文件，讲道理发现有时候头文件没导全就很烦，所以干脆直接全部导入常用的，方便233\n#include &lt;jni.h&gt;\n#include &lt;dlfcn.h&gt;\n#include &lt;android&#x2F;log.h&gt;\n#include &lt;malloc.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;regex&gt;\n#include &lt;bits&#x2F;getopt.h&gt;\n#include &lt;asm&#x2F;unistd.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;asm&#x2F;fcntl.h&gt;\n#include&lt;fcntl.h&gt;\n\n#include&lt;sys&#x2F;types.h&gt;\n#include&lt;sys&#x2F;stat.h&gt;\n\n#include &lt;unistd.h&gt;\n#include &lt;sys&#x2F;syscall.h&gt;\n#include &lt;sys&#x2F;types.h&gt;\n#include &lt;sys&#x2F;stat.h&gt;\n#include &lt;fcntl.h&gt;\n\n然后我们自己自定义一个函数，\n\n这里有个坑点，就是如果不设置你编译的是几位的，那么参数是无法写__NT_open，编译会一直通不过，就设置就是在\n\nARM内联汇编沉思，发现很多syscall，为了防止被libc中直接hook，直接自己内嵌一个内联汇编了，就很不讲道理，自己实现一手，其实直接把ida中反汇编的汇编直接扒拉下来就好了，不过androidstudio还是需要设置一下的。\n    .text\n    .global raw_syscall\n    .type raw_syscall,%function\n\nraw_syscall:\n        MOV             R12, SP\n        STMFD           SP!, &#123;R4-R7&#125;\n        MOV             R7, R0\n        MOV             R0, R1\n        MOV             R1, R2\n        MOV             R2, R3\n        LDMIA           R12, &#123;R3-R6&#125;\n        SVC             0\n        LDMFD           SP!, &#123;R4-R7&#125;\n        mov             pc, lr\n\n\n\n在cmakelist中也需要修改下，引入这个汇编文件\n\n直接调用这个函数就行\n\n和之前是一样的，没啥大问题\nida反编译后，效果大概是这样的，还行\n\n继续跟下去，发现这个函数，和我在libc中反编译出的syscall是一样的，不过这里我已经不需要动态链接进去了，\n直接就是本地的，hh\n其他参考内联汇编:https://blog.csdn.net/tidyjiang/article/details/52138598\n","slug":"SVC指令获取设备信息-内联汇编","date":"2021-06-28T07:05:01.000Z","categories_index":"AndroidReverse","tags_index":"reverse","author_index":"YenKoc"},{"id":"e711ae4763716495e69aa9bd1f61c2a8","title":"2021强网杯wp","content":"前言就看了两题安卓加一个timeago，太菜了呀，实属要退役的节奏了，一段时间没调，感觉水平无限下滑（。\nezmath这题不予评价了，感觉挺奇怪的，按道理来说idapython还是inline hook都是可以每两字节爆破出来的，但是精度损失的非常厉害，感觉是出题人机器和我们的不太一样的问题，没啥意思感觉。\nTimetoAgo一道64位的exe，先去花指令的，都是一些简单的模式，d一下，然后该nop就nop就可以完美的f5了，\n\n因为题目一直提示时间的，问题，我就想当然的直接按没加密的patch，后面发现flag不对，又开始老老实实的搬砖了。\n先经过了四个漫长的函数，大概就是生成了一个结构体，不过结构体的字段值，是经过一个奇葩函数生成的，动调了下发现是常数，不过跑的很慢，耐心一点，大概5分钟就跑完了，四个值，0xffd,0x1ffd,0x3ffd,0x7ffd\n后面的就是慢慢磨，能很明显的看到tea算法加密的痕迹，第一个函数中出现&lt;&lt;4 和&gt;&gt;5的异或相加的，后面对照着思路，发现就是前4个是xtea变种加密，后4个tea加密，然后对比的密文也变动了，不用管直接dump下来，直接搞个脚本跑就行。\nStandonGiant安卓题，java层没啥代码，就是一个点击事件而已，然后直接到native层，在.init_array发现很明显的openssl痕迹，github上一搜，发现就是openssl的初始化，明显是静态编译进来了，题目也告诉是大数，我这里犯了一个致命错误，没有拿源码去对比，实际上openssl的源码网上一堆，然后一直在调试库函数，无穷无尽，大概前面就是做了一个逆序，然后经过了一个纯的rsa加密，模数就是那个异或后的数组，然后再经过一个base64的换表加密，这个是真的坑，那个base64的表中+-重复了，也就会导致我们反推回原表的下标会导致不止一种情况，所以需要爆破2^14次，把情况都找出来，只有正确的那个才能解密（。\nfrom Crypto.Util.number import *\nimport base64\nn &#x3D; 0x1321D2FDDDE8BD9DFF379AFF030DE205B846EB5CECC40FA8AA9C2A85CE3E992193E873B2BC667DABE2AC3EE9DD23B3A9ED9EC0C3C7445663F5455469B727DD6FBC03B1BF95D03A13C0368645767630C7EABF5E7AB5FA27B94ADE7E1E23BCC65D2A7DED1C5B364B51\np &#x3D; 33372027594978156556226010605355114227940760344767554666784520987023841729210037080257448673296881877565718986258036932062711\nq &#x3D; 64135289477071580278790190170577389084825014742943447208116859632024532344630238623598752668347708737661925585694639798853367\ne &#x3D; 65537\n#普通的base64的换表\n&#39;&#39;&#39;\nstr1 &#x3D; &quot;x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q&quot;\n\nstring1 &#x3D; &quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+&#x2F;&quot;\nstring2 &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot;\nflag&#x3D;base64.b64decode(str1.translate(str.maketrans(string1,string2)))\n&#39;&#39;&#39;\n# 表中出现重复出现的字符时要怎么做\na &#x3D;&quot;bborOT+ohG*,U:;@&#x2F;gVIAZ-,t++LaZkOrk?UcSOKJ?p-J+vuSN?:e,Kc&#x2F;?h-oH?:tthoqYYSPp-ZC+Yw:*jrxPymGYO&#x2F;PvDOIivNYtvJ?Mi*GG+&#x2F;lmqEysrTdSD+eP+moP+l?+Np&#x2F;oK&quot;\n#a &#x3D; &quot;btF.d:IDCNIMHdD+PFExV+BBGYbxjqGK@IN?B+d:*;XZvSMiBJaY@ufB,CIDCI?;oR?SWWdNU?EXc*BfpakoNsRD:IQRffViAUmF+&#x2F;aJ*v*xvxYw?KXVaFsRzy&#x2F;N&#x2F;,XGGKHrpZ*Ooje&#x3D;&quot;\ntable1 &#x3D; &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ*+,-.&#x2F;:;?@+-&quot;\ntable2 &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot;\nprint(len(a))\nall_mid_result&#x3D;[]\ndef findIndex(table,yk):\n    Indexs&#x3D;[]\n    for i in range(len(table)):\n        if yk&#x3D;&#x3D;table[i]:\n            Indexs.append(i);\n    return Indexs\n&#39;&#39;&#39;\nfor i in range(len(a)):\n    ykIndexs&#x3D;findIndex(a[i])\n    if len(ykIndexs)&#x3D;&#x3D;1:\n        flag+&#x3D;table2[ykIndexs[0]]\n    elif len(ykIndexs)&#x3D;&#x3D;2:\n&#39;&#39;&#39;\ntmp&#x3D;[]\ndef dfs(flag, yk, i):\n    if i&#x3D;&#x3D;139:\n        flag+&#x3D;&quot;&#x3D;&quot;\n        tmp.append(flag)\n        return\n    ykIndexs&#x3D;findIndex(yk,a[i])\n    #print(flag)\n    #print(ykIndexs)\n    if len(ykIndexs)&#x3D;&#x3D;2:\n        dfs(flag+table2[ykIndexs[0]],yk,i+1)\n        dfs(flag+table2[ykIndexs[1]],yk,i+1)\n    else:\n        dfs(flag+table2[ykIndexs[0]],yk,i+1)\ndfs(table2[table1.index(a[0])],table1,1)\nf&#x3D;open(&quot;data.txt&quot;,&quot;w&quot;)\nfor wx in range(len(tmp)):\n    mid_res&#x3D;base64.b64decode(tmp[wx])\n    c&#x3D;bytes_to_long(mid_res)\n    a&#x3D;pow(c,inverse(e,(p-1)*(q-1)),n)\n    flag&#x3D;long_to_bytes(a)\n    f.writelines(str(flag))\n\n\n\n\n反思还有一题allinone是题android vm套娃，有些思路，但是最后有函数我逆不回去，只能放弃，太菜了，unicorn没看，有点像kctf的传家宝那题了，蜗牛壳，运行一点，解密一点，妈的，得写脚本一直扣代码吧，可怕，不会，期待下wp，感觉状态很差，麻了\n","slug":"2021强网杯wp","date":"2021-06-13T17:59:54.000Z","categories_index":"writeup","tags_index":"reverse","author_index":"YenKoc"},{"id":"05699e0b3c4e02c2136460838badc80b","title":"Android8.0 art下面的几个脱壳点","content":"前言搞了一个17年decon 会议的ppt，里面对市面上的一些apk加固方式有一些整体分析，实际上手动脱壳，现在越来越难了，时间成本太大了，各种莫名的反调试和混淆，so的话，俺也不太会搞vmp，在学了在学了（我太菜了，java层的话，还是有突破口的，毕竟dex再怎么加固，最终还是要经过classloader，加载到内存中的，整体的dump下来，不过目前都是抽取壳，就算扒拉下来依旧是需要修复的（，这是fart解决的事\n分析源码安卓8.0会有一个比较大的变动，多了一个inmemorydexclassloader，这个classloader支持不落地加载的，所以有些壳可能会选择这个classloader去加载dex，而不使用传统的dexclassloader，我们可以先跟一下两种dexclassloader的源码，然后作一个比较，如果找到交叉点的话，直接hook这个交叉点，不就可以实现通杀了。\nDexClassLoader前面一大堆跟的就不放了，太easy了，直接跟到上次玩热修复，没继续跟下去的地方。\n\n\n\n\n这里有个很明显的将dex转换为oat格式的函数，这里因为art中会先将dex转换oat格式，加快运行速度，\n我们继续跟进去，我们跟的目的就是找到dex加载到内存中的首地址和size。\n\n\n这里有点类似java反射的操作，反正就是调用了dex转换为oat格式的函数，这里涉及一个点就是目前的壳，一般都会采用禁用dex转换成oat的方式，所以我们的思路需要做一个转换，走另一个分支\n\n\n\n终于出现了我们想要的了，继续跟下去，多找几个点\n\n基本找到了，接着看另一个classloader\nInmemoryClassLoader和上文基本一致的分析流程，不过分析到后面发现和上面的dexclassloader有了交叉点，也就是他们最终都会调用的函数openCommon和dexfile，那么我们直接hook这两个函数不就完事了\nhook找到源码，开始hook，然后编译刷机\n\n","slug":"Android8-0-art下面的几个脱壳点","date":"2021-06-11T16:10:05.000Z","categories_index":"AndroidReverse","tags_index":"AndroidUnPacker","author_index":"YenKoc"},{"id":"08f55e9615384c7275f59ed241f8ccbd","title":"Android got hook","content":"原理 核心原理就是查找程序头表中的动态segment，然后查看虚拟内存映射到哪个位置，也就是rva，可以直接去ida中查看偏移， 因为我发现ida去解析so文件的时候，是看segment表去解析的，所以ida直接就是一个起始地址为0的虚拟内存（，先去010查看这个段在哪，然后发现里面包含了一些导入的so库名称，还有一个符号表，字符串表，然后还有一个很重要的动态重定位表，里面是包含一个info结构体，这个结构体可以去查询符号的字符串表下标，以及类型，然后还有一个地方，就是这个导入符号对应got表偏移地址，那么我们直接把这个地址中的地址替换成我们想要的，不就完事了，不想放图了，被折磨的有点怕了（，我是懒狗\nDemo代码:#include &lt;jni.h&gt;\n#include &lt;string&gt;\n#include &quot;unistd.h&quot;\n#include &quot;stdio.h&quot;\n#include &quot;stdlib.h&quot;\n#include&lt;android&#x2F;log.h&gt;\n#include&lt;EGL&#x2F;egl.h&gt;\n#include&lt;GLES&#x2F;gl.h&gt;\n#include&lt;elf.h&gt;\n#include&lt;fcntl.h&gt;\n#include&lt;sys&#x2F;mman.h&gt;\n#include&lt;inttypes.h&gt;\n#include&lt;dlfcn.h&gt;\n#include &quot;native-lib.h&quot;\n\n\n#define LOG_TAG    &quot;NativeHook&quot;\n#define LOG_E(format, ...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, format, ##__VA_ARGS__)\n#define LOG_D(format, ...)  __android_log_print(ANDROID_LOG_INFO,  LOG_TAG, format, ##__VA_ARGS__)\n\n#define PAGE_START(address) ((address)&amp;PAGE_MASK)\n#define PAGE_END(address) (PAGE_START(address)+PAGE_SIZE)\n\nsize_t  (*old_fwrite)(const void *buf,size_t size,size_t count,FILE *fp);\n\nsize_t  new_fwrite(const void *buf,size_t size,size_t count,FILE *fp)\n&#123;\n    const char *text&#x3D;&quot;hello&quot;;\n    old_fwrite(text,strlen(text),1,fp);\n    return old_fwrite(buf,size,count,fp);\n&#125;\n\n&#x2F;&#x2F;从&#x2F;proc&#x2F;pi&#x2F;maps文件中，获取so模块的首地址\nvoid * get_module_base(pid_t pid,const char *module_name)\n&#123;\n    FILE *fp;\n    long addr&#x3D;0;\n    char filename[32]&#x3D;&quot;\\n&quot;;\n    char line[1024]&#x3D;&quot;\\n&quot;;\n    if(pid&lt;0)\n    &#123;\n        snprintf(filename,sizeof(filename),&quot;&#x2F;proc&#x2F;self&#x2F;maps&quot;);\n    &#125; else&#123;\n        snprintf(filename,sizeof(filename),&quot;&#x2F;proc&#x2F;%d&#x2F;maps&quot;,pid);\n    &#125;\n\n    fp&#x3D;fopen(filename,&quot;r&quot;);\n    while(fgets(line,sizeof(line),fp))\n    &#123;\n        if(strstr(line,module_name)!&#x3D;NULL&amp;&amp;sscanf(line,&quot;%&quot; PRIxPTR&quot;-%*lx %*4s 00000000&quot;,&amp;addr)&#x3D;&#x3D;1)\n            break;\n    &#125;\n    fclose(fp);\n    return (void*) addr;\n&#125;\nint hook_fwrite(const char *soPath)\n&#123;\n    &#x2F;&#x2F;获取要hook so的模块基地址\n    void* base_addr&#x3D;get_module_base(getpid(),soPath);\n    old_fwrite&#x3D;fwrite;\n    Elf32_Ehdr *header&#x3D;(Elf32_Ehdr*)base_addr;\n    Elf32_Phdr *phdr_table&#x3D;(Elf32_Phdr *)((int)base_addr+header-&gt;e_phoff);\n    if(phdr_table&#x3D;&#x3D;0)\n    &#123;\n        return 0;\n    &#125;\n    size_t phdr_count&#x3D;header-&gt;e_phnum;\n    unsigned long p_vaddr&#x3D;0;\n    unsigned int p_memsz&#x3D;0;\n    int j&#x3D;0;\n    for(j&#x3D;0;j&lt;phdr_count;j++)\n    &#123;\n        if(phdr_table[j].p_type&#x3D;&#x3D;PT_DYNAMIC) &#123;\n            p_vaddr &#x3D; phdr_table[j].p_vaddr + (int) base_addr;\n            p_memsz &#x3D; phdr_table[j].p_memsz;\n        &#125;;\n    &#125;\n    Elf32_Dyn *dynamic_table&#x3D;(Elf32_Dyn*)(p_vaddr);\n    unsigned long jmpRelOff&#x3D;0;\n    unsigned long strTabOff&#x3D;0;\n    unsigned long pltRelSz&#x3D;0;\n    unsigned long symTabOff&#x3D;0;\n    int dynCount&#x3D;p_memsz&#x2F;sizeof(Elf32_Dyn);\n    for(int i&#x3D;0;i&lt;dynCount;i++)\n    &#123;\n        int val&#x3D;dynamic_table[i].d_un.d_val;\n        switch (dynamic_table[i].d_tag) &#123;\n            case DT_JMPREL:\n                jmpRelOff&#x3D;val;\n                break;\n            case DT_STRTAB:\n                strTabOff&#x3D;val;\n                break;\n            case DT_PLTRELSZ:\n                pltRelSz&#x3D;val&#x2F;sizeof(Elf32_Rel);\n                break;\n            case DT_SYMTAB:\n                symTabOff&#x3D;val;\n                break;\n        &#125;\n    &#125;\n    Elf32_Rel *rel_table&#x3D;(Elf32_Rel*)(jmpRelOff+(int)base_addr);\n    for(int i&#x3D;0;i&lt;pltRelSz;i++)\n    &#123;\n        uint16_t ndx&#x3D;ELF32_R_SYM(rel_table[i].r_info);\n        Elf32_Sym *symTableIndex&#x3D;(Elf32_Sym*)(ndx*sizeof(Elf32_Sym)+symTabOff+(int)base_addr);\n        &#x2F;&#x2F;获取符号符号结构体\n        &#x2F;&#x2F;获取符号名字\n        char* funcName&#x3D;(char*)(symTableIndex-&gt;st_name+strTabOff+(int)base_addr);\n        if(memcmp(funcName,&quot;fwrite&quot;,strlen(&quot;fwrite&quot;))&#x3D;&#x3D;0)\n        &#123;\n            &#x2F;&#x2F;获取当前内存分页的大小\n            uint32_t page_size&#x3D;getpagesize();\n            &#x2F;&#x2F;获取内存分页的起始地\n            uint32_t mem_page_start&#x3D;rel_table[i].r_offset+(int)base_addr;\n            mprotect(reinterpret_cast&lt;void *&gt;((uint32_t) PAGE_START(mem_page_start)), page_size, PROT_READ | PROT_WRITE | PROT_EXEC);\n            *(unsigned int*)(rel_table[i].r_offset+(int)base_addr)&#x3D;(int)new_fwrite;\n        &#125;\n\n    &#125;\n\n&#125;\n\n","slug":"Android-got-hook","date":"2021-06-09T06:24:12.000Z","categories_index":"AndroidReverse","tags_index":"got表hook","author_index":"YenKoc"},{"id":"a90be964479d5a11087cdb9a691b6994","title":"Android热修复类加载方案demo","content":"前言在逆一些东西的时候，总会遇到热修复的东西，但是之前只是听说并没有了解过这个热修复是啥，所以昨天花了一下午的时间学习了，感觉还可以，主要是跟系统的源码有关系的。\n先了解一手系统classloader\nclassloader在热修复中，我们主要就关心两种，pathclassloader和dexClassloader，第一个是我们的系统类加载器，第二个是我们自定义的类加载器，可以任意加载zip，jar，apk中的dex文件，我们从系统源码的角度出发，去看看他们加载dex，主要是做了哪些事\n\n这里是选择跟一手Android8.1的源码，源码网站可以选择:http://aosp.opersys.com/xref/android-8.1.0_r81/\n个人认为比那个啥androidxref快一些，先看下DexClassLoader这个类\n\n再点进去，我们一般就是直接调用它的构造函数的。\n\n发现有四个参数，第一个参数是载入dex文件的路径，第二个参数是其他类似zip和jar，apk是需要解压的，解压后的文件放入的路径，第三个的是加载dex需要的库，第四个是继承的父类加载器，继续调用了父类的构造方法，第二个参数设置为空了，8.0后的系统，已经把第二个参数废掉了（，发现是继续baseclassloader，再跟上去\n\n发现好家伙，这里主要是干了什么呢，其实就是给pathList赋值，调用了DexPathList的构造方法\n，我们再跟进去。\n\n发现，好家伙，疯狂套娃，给pathList这个对象的字段dexElements赋值了，直接跟进去\n\n这个files.size方法基本判断说，就是当我们加载的是多dex情况，每个elements都对应一个dex，可以看这里，遍历dex文件，然后把dex文件搞成一个dexfile对象，我们可以跟进\n\n第一种就是直接dex文件的，第二种就是需要解压的，懂的都懂，我们直接跟第一种\n\n给dexfile三个字段进行赋值，再跟下去就到native层去了，就不跟了我们的目的也达到了，发现loaddexfile，就是将传入的dex文件，打成了一个dexfile对象\n\n发现这个elements字段核心就是为了给它的两个字段赋值而已。\n\n\n系统中是如何去查找一个类的呢？我们可以继续跟着源码，平常我们的代码都是先生成一个classloader对象，然后使用它的ge tClass()方法，去dex中去寻找类对象。\n\n发现调用了pathList的findClass方法，继续跟\n\n\n最后也是跟着native层去了，然后发现什么问题，就是先遍历了这个dexelements数组，每个数组元素不就相当于一个dexfile嘛，当发现有同名的类的时候，就返回类对象，所以我们要热修复的话，必须插到这个数组的前面才行。\n分享下热修复的代码package com.example.hotfixtest;\n\nimport android.content.Context;\n\nimport java.io.File;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.nio.file.Path;\nimport java.util.HashSet;\n\nimport dalvik.system.DexClassLoader;\nimport dalvik.system.PathClassLoader;\n\npublic class FixDex &#123;\n    &#x2F;&#x2F;修复的文件后缀\n    private static final String DEX_SUFFIX&#x3D;&quot;.dex&quot;;\n    private static final String APK_SUFFIX&#x3D;&quot;.apk&quot;;\n    private static final String JAR_SUFFIX&#x3D;&quot;.jar&quot;;\n    private static final String ZIP_SUFFIX&#x3D;&quot;.zip&quot;;\n    public static final String DEX_DIR&#x3D;&quot;odex&quot;;\n    public static final String OPTIMIZE_DEX_DIR&#x3D;&quot;optimize_dex&quot;;\n    private static HashSet&lt;File&gt; loadedDex&#x3D;new HashSet&lt;File&gt;();\n\n    static &#123;\n        &#x2F;&#x2F;初始化\n        loadedDex.clear();\n    &#125;\n    &#x2F;&#x2F;反射工具包\n    &#x2F;&#x2F;给对象字段赋值\n    public static void setObjectField(Object object,Class&lt;?&gt; objectClass,String fieldName,Object value) throws NoSuchFieldException, IllegalAccessException &#123;\n        Field field&#x3D;objectClass.getDeclaredField(fieldName);\n        field.setAccessible(true);\n        field.set(object,value);\n    &#125;\n    &#x2F;&#x2F;取出对象的字段值\n    public static Object getObjectField(Object object,Class&lt;?&gt; objectClass,String fieldName) throws NoSuchFieldException, IllegalAccessException &#123;\n        Field field&#x3D;objectClass.getDeclaredField(fieldName);\n        field.setAccessible(true);\n        return field.get(object);\n    &#125;\n    &#x2F;&#x2F;拿到pathList对象\n    public static Object getPathList(Object baseDexClassLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;\n        return getObjectField(baseDexClassLoader,Class.forName(&quot;dalvik.system.BaseDexClassLoader&quot;),&quot;pathList&quot;);\n    &#125;\n    &#x2F;&#x2F;拿到pathList对象中的dexElements对象\n    public static Object getDexElement(Object PathList) throws NoSuchFieldException, IllegalAccessException &#123;\n        return getObjectField(PathList,PathList.getClass(),&quot;dexElements&quot;);\n    &#125;\n    &#x2F;&#x2F;数组合并\n    private static Object combineArray(Object arrayLhs,Object arrayRhs)\n    &#123;\n        Class&lt;?&gt; componentType&#x3D;arrayLhs.getClass().getComponentType(); &#x2F;&#x2F;dexElements对象的雷\n        int oLength&#x3D;Array.getLength(arrayLhs);\n        int nLength&#x3D;Array.getLength(arrayRhs);\n        int NewLength&#x3D;oLength+nLength;\n        &#x2F;&#x2F;创建一个新的dexElements对象数组，不过目前是空的\n        Object dexElements&#x3D;Array.newInstance(componentType,NewLength);\n        System.arraycopy(arrayLhs,0,dexElements,0,oLength);\n        System.arraycopy(arrayRhs,0,dexElements,oLength,nLength);\n        return dexElements;\n    &#125;\n    private static void deDexInject(Context appContext,HashSet&lt;File&gt; loadedDex)\n    &#123;\n        String optimizeDir&#x3D;appContext.getFilesDir().getAbsolutePath()+File.pathSeparator+OPTIMIZE_DEX_DIR;\n        File fopt&#x3D;new File(optimizeDir);\n        if(!fopt.exists())\n        &#123;\n            fopt.mkdirs();\n        &#125;\n        try&#123;\n            &#x2F;&#x2F;记载应用程序的dex\n            PathClassLoader pathClassLoader&#x3D; (PathClassLoader) appContext.getClassLoader();\n            for(File dex:loadedDex) &#123;\n                DexClassLoader dexClassLoader &#x3D; new DexClassLoader(dex.getAbsolutePath(), fopt.getAbsolutePath(), null, pathClassLoader);\n                &#x2F;&#x2F;3.合并\n                Object dexPathList&#x3D;getPathList(dexClassLoader);\n                Object pathPathList&#x3D;getPathList(pathClassLoader);\n                Object leftDexElements&#x3D;getDexElement(dexPathList);\n                Object rightDexElements&#x3D;getDexElement(pathPathList);\n                &#x2F;&#x2F;合并完成\n                Object newDexElements&#x3D;combineArray(leftDexElements,rightDexElements);\n                &#x2F;&#x2F; 重写给pathList中的elements数组赋值\n                Object pathPathList1&#x3D;getPathList(pathClassLoader);\n                setObjectField(pathPathList1,pathPathList1.getClass(),&quot;dexElements&quot;,newDexElements);\n\n            &#125;\n        &#125;catch (Exception e)\n        &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    public static void loadFixedDex(Context context,File patchFilsDir)\n    &#123;\n        if(context&#x3D;&#x3D;null) &#123;\n            return;\n        &#125;\n        File fileDir&#x3D;patchFilsDir!&#x3D;null? patchFilsDir: new File(context.getFilesDir().getAbsoluteFile(),DEX_DIR);\n        File[] f&#x3D;fileDir.listFiles();\n        for(File tmp:f)\n        &#123;\n            if(tmp.getName().startsWith(&quot;class&quot;)||tmp.getName().endsWith(DEX_SUFFIX)||tmp.getName().endsWith(APK_SUFFIX)||tmp.getName().endsWith(JAR_SUFFIX)|| tmp.getName().endsWith(ZIP_SUFFIX))\n            &#123;\n                loadedDex.add(tmp);\n            &#125;\n        &#125;\n        &#x2F;&#x2F;合并之前的dex\n        deDexInject(context,loadedDex);\n    &#125;\n\n\n&#125;\n\n主要通过反射进行的操作，所以和系统版本有关系，安卓9已经把反射禁了，得需要另一种方式突破限制，不展开了\n","slug":"Android热修复类加载方案demo","date":"2021-06-04T05:54:30.000Z","categories_index":"安卓开发","tags_index":"热修复","author_index":"YenKoc"},{"id":"ab71dbe1e9c18adee445c559bc9eb61a","title":"哈工大编译原理第二节笔记","content":"前言本来打算早上起来学的，没想到失眠了，直接起床学（，被动学习加一\n2-1 词法语法分析基本概念\n这里讲了一个集合乘积的概念，字母表的n次方，就是几个字母表的乘积，这里的乘积和我们说的乘法不同，这里的乘积，其实更多的概念叫连接，几次方，相当于是连接后字符串的长度，类似于每位从字符表中取出一个字符，进行连接。\n\n\n克林闭包，已经包括了这个字符表中字符的所有组合了，串就是克林闭包中的任意元素。\n\n\n2-2 文法的定义文法主要是描述句子组成规则的，不过老师也提了一下，根据描述的对象的不同，我们的基本符号也会发生改变，比如当我们描述的是单词的规则，那么我们的基本符号对象就变成了字母。\n\n终结符，就是文法所定义的语言的基本符号，有时候也叫token。 根据举例，基本符号已经是具体的xx东西了。\n\n非终结符是用来表示语法成分的符号，有时也称为 语法变量\n\n\n\n\n\n\n2-3 语言的定义\n编译器如何知道这个句子是不是符号文法规则，其中一种就是使用这种自顶向下的推导，另一种就是归约，自下向上归约，推导和归约是个互逆的过程\n\n语言的形式化定义\n\n2-4 文法的分类\n\n\n逐级包含的关系，还挺6的\n","slug":"哈工大编译原理第二节笔记","date":"2021-06-02T17:36:06.000Z","categories_index":"编译原理","tags_index":"计算机基础","author_index":"YenKoc"},{"id":"645125775bc5f25537c3c04c5e9cbef1","title":"关于pixel4 root成砖，又复活的故事","content":"前言我自己的pixel1忘记带来了，从导师那弄了一台pixel4，好像没root，所以打算开始先root，然后装个测试环境\n刷入面具magisk这里和常规的那种pixel，刷入第三方tw，然后卡刷zip包还是很大不同，我尝试了一遍，发现根本没用，从网上搜了一种方法还行，打开调试模式什么的，就不多bb了，首先去github上下一个magiskmanager:https://github.com/topjohnwu/Magisk/releases?after=v20.2，安装好之后，开始安装magisk，点击\n\n点击安装后，要注意它会让你选择什么样的安装方式，这里是选择修复boot.img，所以我们这里需要同一个系统版本的boot\u0001.img，去网站上下个镜像，提取出boot.img,然后push到手机中，到时候安装时，直接选择就好了\n\n然后修补好后，会生成一个patched.img文件，把它再pull到本地上\n\n先进入bootloader模式\nadb shell bootloader\n\n再使用\nfastboot flash boot 上面的那个patched.img文件\n\n最后\nfastboot reboot\n\n重启后，发现面具已经刷好了，并且可以su了\n坑点fastboot老会出现command failed，网上搜到了一种解决方式，还不错\nfastboot snapshot-update cancel\n\n输入上面这段就可以完美解决了\n参考链接\nhttps://sspai.com/post/57923\nhttps://blog.csdn.net/weixin_45472158/article/details/113461883\nhttps://www.reddit.com/r/CalyxOS/comments/jlx95g/pixel_4a_installation_issues_boot_slot/\nitfanr.cc/2018/10/16/google-pixel-unlock-bl-and-root/\n\n","slug":"关于pixel4-root成砖，又复活的故事","date":"2021-06-02T08:04:54.000Z","categories_index":"刷机","tags_index":"刷机","author_index":"YenKoc"},{"id":"77bc24379b69ae18331fff6632b0555b","title":"哈工大编译原理第一节笔记","content":"前言在看哈工大的编译原理视频ing，顺便做做笔记（，要考试了，太惨了\n笔记1-1 什么是编译源程序进行编译器，编译成汇编，然后汇编生成可重定位的机器代码，再经过链接，生成目标机器代码，大体流程是这样的，具体的流程，我又去翻了一遍程序员的自我修养的第二章。\n\n先经过预处理操作\n这里的过程主要是处理那些源文件中以”#”开始的预编译指令。比如#include,#define等，主要处理规则:\n\n将所有的“#define”指令删除，并且展开所有的宏定义\n处理所有条件预编译指令，比如”#if“，”#idef“，#elif”，“#else”\n处理#include预编译指令，将被包含的文件插入到该预编指令的位置，不断包含，因为头文件也包含其他头文件\n删除所有的注释\n添加行号和文件名标识\n保留所有的#prama编译器指令\n\n经过预编译后的.i文件不包含任何宏定义，因为所有的宏定义都已经展开了，包含的文件也已经插入到文件当中了。\n\n编译\n编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析以及优化后生产相应的汇编代码文件。\n\n汇编\n汇编器是将汇编代码转变成机器可以执行的指令，其实汇编就是机器码的翻译，可以对应起来的，所以汇编也是和cpu架构对应起来的。\n\n链接\n主要是将各种模块经过汇编后的重定位目标模块，组装在一起，下面这图我觉得挺贴切的\n\n\n\n1-2 编译系统的结构老师这边举了一个英文翻译成汉语的例子，我觉得挺不错的，首先我们肯定得知道这个句子是什么意思嘛，所以需要语义分析，然后语义分析是需要分析句子的结构，划分句子的，句子结构是分析他们的分别是什么状语的，那么我们的问题又转到分析状语的过程，是语法分析，识别短语，同时要识别短语，是需要确定词性的，是需要词法分析的，真不错的，实际编译器上是倒着来的\n\n1-3 词法分析\n同种类型就是靠属性值来进行区分的，来个例子，其实就是搜索，然后再拆分\n\n1-4 语法分析概述\n\n\n大概有点理解了，所以说，在正常翻译过程中的x语，在编译原理中，其实上是由文法来制定的，什么词加上什么词，构成什么语法结构，是由文法来决定的，这步是语法分析做的事。\n1-5 语义分析概述\n\n\n1-6 中间代码生成和编译器后端\n\n唯一确定了运算完成的顺序\n\n目标代码生成以源程序的中间表示形式作为输入，并把它映射到目标语言，最重要的是变量的寄存器分配\n代码优化为改进代码进行的等价程序变化，使其运行得更快，所占用空间更少\n总结下: 有个一个大体的概念，老师讲的挺赞的\n","slug":"哈工大编译原理第一节笔记","date":"2021-06-01T11:15:47.000Z","categories_index":"编译原理","tags_index":"计算机基础","author_index":"YenKoc"},{"id":"29c90278776b9ceb230f70e3bee57549","title":"windows上反调试的一些总结","content":"前言反调试，分为两种，一种是静态反调试，另一种是动态反调试，这两者主要的目的也不同，第一种的核心目的是检测调试器，而第二种的核心目的其实就是为了隐藏代码和数据的，第一种的类似xxdebugpresent，第二种类似双进程保护，异常处理等反调试手段，第一种的话实际上一次破解结束后，反调试就被绕过了，程序就可以正常调试了，但是第二种是要不断的调试，才能看到代码和数据的，还是有很大区别的。\n静态反调试0x01 PEB反调试peb的意思是进程环境信息块，利用peb结构体信息可以判断当前进程是否处于被调试的状态的。\ntypedef struct _PEB &#123;\n  BYTE                          Reserved1[2];\n  BYTE                          BeingDebugged; &#x2F;&#x2F;被调试状态\n  BYTE                          Reserved2[1];\n  PVOID                         Reserved3[2];\n  PPEB_LDR_DATA                 Ldr;\n  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;\n  BYTE                          Reserved4[104];\n  PVOID                         Reserved5[52];\n  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;\n  BYTE                          Reserved6[128];\n  PVOID                         Reserved7[1];\n  ULONG                         SessionId;\n&#125; PEB, *PPEB;\n\n以上是peb结构体的成员信息，不完全，但是这里就不截图了，具体完整的peb可以见链接:https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx\n这里主要关注四个成员\n0x002 BeingDebugged  UChar\n0x00c Ldr \t\t\t\t\tPtr32_PEB_LDR_DATA\n0x018 ProcessHeap.  Ptr32_Void\n0x068 NtGlobalFlag. Uint48\n\n0x02 获取peb地址这里获取peb结构体有两种方式，不过都是通过借助fs段寄存器做的\n\n直接获取peb的地址\nMOV EAX,DWORD PTR FS:[0x30]\n\n先获取teb地址，再通过ProcessEnvironmentBlock成员（偏移加0x30）来获取peb地址\nMOV EAX,DWORD PTR FS:[0x18]\nMOV EAX,DWORD PTR DS:[EAX+0x30]\n\n\n0x03 细分peb\nBeingDebugged(+0x2)\n进程处于调试状态的时候，这个成员会被设置成1，不在调试状态下，它的值是会被设置成0，\n这不得不 提到IsDebuggerPresent()这个api实际上就是检测peb这个成员的值的。\n\nNtGlobalFlag(+0x68)\n调试进程的时候，PEB.NtGlobalFlag成员(+0x68)的值会被设置成0x70所以可以去检测\n这个值，然后去判断进程是否处于被调试状态。\n但是直接attach上调试器的时候，这个成员值是不会变的\n\n\n0x04 过反调试办法peb毕竟还是结构体，也就是最终还是在内存中体现的，那么\n我们可以直接取到peb地址，然后把成员的值改回来就行了\n或者可以利用我之前使用的在汇编层面上把返回值修改掉，不过\n没有直接改结构体，来的方便\n0x01 NtQueryInformationProcess()利用这个api探测调试器，这个api可以获取各种与进程调试相关的信息\n，该函数定义\nNTSTATUS WINAPI NtQueryInformationProcess\n(\n\t__in HANDLE ProcessHandle\n\t__in PROCESSINFOCLASS ProcessInforationClass\n\t__out PVOID ProcessInformation,\n\t__in ULONG ProcessInformationLength,\n\t__out_opt PULONG ReturnLength\n);\n\n根据传入的第二个参数的不同，返回值会传入第三个参数\n这个PROCESSINFOCLASS是枚举类型，我们我们主要去关心这个与调试器有关的成员有\nProcessDebugPort(0x7)、ProcessDebugObject-Handle(0x1E)、ProcessDebugFlags(0x1F)\n0x02 ProcessDebugPort(0x7)当传入的参数为0x7的时候，调用这个NtQueryInformationProcess()函数\n，进程处于非调试状态时，是为0，处于调试状态值为0xFFFFFFFF\n\nNtqxxxx()\n0x03 ProcessDebugObjectHandle(0x1e)调试进程会生成调试对象，当传入第二个参数为0x1e时，\n第三个参数就可以获取调试对象句柄，但是这个句柄要在进程处于调试状态的时候，才可以，如果进程处于非调试状态\n，这个对象是为空的。\n0x04 ProcessDebugFlags(0x1F)和上面的是一样的，不过第二个参数现在要传入0x11f的，\n若进程处于被调试状态，第三个参数值为0，如果为1的话，则进程处于非调试状态的\n0x05 反调试方法如果反调试api调用少，我们可以直接去改那个内存中的值，毕竟每次传入第二个参数的时候，会把返回值存在第三个参数重，第三个参数的内存空间，我们是可以操作的，如果api很多，我们可以选择用inlinehook，直接去修改返回值，实现自动化。\n0x01 ZwSetInformationThread()强制分离调试器和被调试进程的技术\n这个api的结构\nNTSTATUS ZwSetInformationThread(\n\t--in HANDLE ThreadHandle\n\t--in THREADINFOCLASS ThreadInformationClass\n\t__in PVOID ThreadInformation,\n\t__in ULONG ThreadInformationLength\n)\n\n由第二个参数来决定这个api的功能，第二个参数为0x11时，是隐藏调试进程，使其无法调试的，\n0x02 反调试方法可以修改第二个参数的值为0，这样就可以不执行分离进程的功能了\n其他方式例如检测虚拟机环境，检测od窗口，检测进程中是否有调试器的进程，检测计算机的名字\n主要通过系统的api去做的检测\n","slug":"windows上反调试的一些总结","date":"2021-05-27T17:25:12.000Z","categories_index":"逆向工程核心原理","tags_index":"反调试","author_index":"YenKoc"},{"id":"99d6abf837e88eebd0687f5f9fc4ecea","title":"mrctf的游戏逆向","content":"前言之前ctf中的游戏逆向都是比较直接，都是dnspy然后搜索关键字，然后开始逆向的，比较简单些，这题的话和其他的游戏题还是有很大的不同的，昂哥出的题确实有质量，后续的官方wp中也有昂哥用dll注入，直接破掉的操作，先看几题，常规的题，之后再与这题进行一个对比。\nBJD hamburger competition这题挺有节目效果的，老八奥力给\n\n估计就是我们选择正确的食物组合，然后才能getflag，一看就是unity3d的游戏，还有mono的运行库，很明显了\n\n因为c#都编译到Assembly-CSharp.dll中去了，所以我们入手点在这个文件中，dnspy安排上\n\n先通过搜索字符串，定位一下核心逻辑\n\n直接搜到了核心逻辑了，我们看下逻辑，看看要怎么逆\n\n发现逻辑其实很简单，和之前猜想的一样，就是不同食材的组合，不同食材对应的不同分数，恰好组合才可以getflag，发现是除了汉堡顶和底，7种食物要选4种，直接爆破所有情况，不过也有非预期解，就是直接sha1解开\nimport hashlib\ndef enc(a):\n    tmp&#x3D;997\n    for i in a:\n        if i&#x3D;&#x3D;1:\n            tmp-&#x3D;127\n        elif i&#x3D;&#x3D;2:\n            tmp*&#x3D;3\n        elif i&#x3D;&#x3D;3:\n            tmp^&#x3D;18\n        elif i&#x3D;&#x3D;4:\n            tmp+&#x3D;29\n        elif i&#x3D;&#x3D;5:\n            tmp-&#x3D;47\n        elif i&#x3D;&#x3D;6:\n            tmp*&#x3D;5\n        elif i&#x3D;&#x3D;7:\n            tmp^&#x3D;87\n    tmp^&#x3D;127\n    return str(tmp)\nindex&#x3D;[1,2,3,4,5,6,7]\nres&#x3D;[]\nfor yk1 in index:\n    for yk2 in index:\n        for yk3 in index:\n            for yk4 in index:\n                res.append(yk1)\n                res.append(yk2)\n                res.append(yk3)\n                res.append(yk4)\n                t&#x3D;enc(res).encode(&quot;utf-8&quot;)\n                if (hashlib.sha1(t).hexdigest().upper()&#x3D;&#x3D;&quot;DD01903921EA24941C26A48F2CEC24E0BB0E8CC7&quot;):\n                    print t\n                res&#x3D;[]\n\n\nMRCTF EZ_GAME这题有两种做法，一种是骚操作，一种就是正常的思路，dll注入\n先重温下骚操作，不得不说，现在的骚操作确实猛且骚，哈哈哈\n第一步先打开文件夹，看下这个程序的架构，一看就是unity，但是现在unity还有icpp，为了提高运行速度，所以需要去识别的下，\n发现就是I2cpp的\n\n然后出题人有点狠，直接加的是themida的壳，不讲武德！，这种题i2cpp还是有现成的工具去查看一些类信息的，不过通过类信息去定位核心逻辑，估计是凉了，毕竟加了强壳，不过还是可以对我们的分析起到很关键的地方的，这个工具叫II2CppDumper，放下github链接. https://github.com/Perfare/Il2CppDumper，记得直接下编译好的\n用法如下:\n\n然后在生成的Dumpdll文件夹下面找到Assemable文件，拖入dnspy，可以查看一些类信息和定义\n\n可以发现这题无法用ce搞出来，因为发现不仅仅是数量修改了，就完事了，因为这个key的update是要根据吃的星星，每吃一个，计算一次，也就是必须吃满105个星星，update了105次，才是正确的key，这点我们可以用ce做一个验证,哦对，本来这些信息的rva，我们可以利用这个偏移，直接打开ida去看的，然而加了壳，你懂的，难顶。\nce的操作先打开ce，我这里用的是风叶人的加强版，确实🐂，对结构体以及类这块有加强，挺香的，我们先吃几个星星，然后开始内存搜索，看看是哪里在修改\n\n发现什么问题呢，后面的八个字节一直在变动，然后我标注的地方就是之前我们死亡的次数，这个结构是可以完全对应上之前我们用工具搞出来的类定义的信息的，\n\nok的，那也就是说我们的猜想是没有问题的，那么我们要如何去找到这个updatekey的地方呢，ce有这个功能去跟踪是哪里改写了这个地址，方便我们更快的找到核心逻辑，这个强壳，有些反调试，所以需要去设置下ce\n\n\n会弹出旁边的那个窗，不管它，再去吃钻石，去触发这个内存断点（我估计就是下了一个内存访问的断点）,发现成功触发了\n\n这里可以选择直接撸汇编，不过太麻烦了，所以还是选择从内存中dump下来，然后ida打开，阅读伪代码好一些\n\n直接火绒剑安排上，把内存先dump下来\n\n用ida打开之后，有些结构被打乱了，所以需要我们手动去找函数头\n\n\n把初始的值拿出来，然后本地复现加密算法，再填充回ce就可以直接拿到flag了，冲\n#include &lt;cstdio&gt;\n#include &quot;defs.h&quot;\nvoid calc(__int64* key)\n&#123;\n    for (int i &#x3D; 0; i &lt; 4; i++)\n    &#123;\n        __int64 k &#x3D; 1, l &#x3D; 0;\n        for (__int64 j &#x3D; 0; j &lt; 64; j++)\n        &#123;      \n            l ^&#x3D; (unsigned __int64)(k &amp; *key) &gt;&gt; (j &amp; 0x3F);\n            k &#x3D; __ROL8__(k, 1);\n        &#125;\n        *key &#x3D; l | (2 * *key);\n    &#125;\n&#125;\n\nint main()\n&#123;\n    __int64 key &#x3D; 0xDEADBEEFAA114514;\n    for (int i &#x3D; 0; i &lt; 105; i++)\n        calc(&amp;key);\n    printf(&quot;0x%llX&quot;, key);\n    return 0;\n&#125;\n\n拿到最终的key，然后就是重新启动游戏，直接填充数据，0xEA8451453BD5B7DD, 把对应偏移的内存地址的值都填上，就能拿到flag了\n\n\nDLL注入利用i2cpp导出的函数，然后可以利用这些导出函数类似反射的功能，又因为我们把dll注入进去了，也是同一个进程了，所以我们去使用这个函数是全局的，绝对有影响的\n\n以上就是大致的导出函数，然后利用 GetProcAddress(dll_name,api_name)，获取每个导出函数的地址，然后把每个api的地址都存放到一个数据结构里面的，核心逻辑是这样的\nvoid getclass(PTR clazz,void *data)\n&#123;\n    char *str&#x3D;(char*)il2cpp_class_get_name(clazz);\n    if(!strcmp(str,&quot;GetFlag&quot;))\n    &#123;\n        \n        void *iter&#x3D;0;\n        PTR method&#x3D;NULL;\n        do \n        &#123;\n            method&#x3D;il2cpp_class_get_methods(clazz,&amp;iter);\n            char *name&#x3D;il2cpp_method_get_name(method);\n            \n            if(!strcmp(name,&quot;EatTokenUpdateKey&quot;))\n            &#123;\n                MessageBoxA(NULL,name,name,NULL);\n                PTR eatCookie&#x3D;il2cpp_class_get_field_from_name(clazz,&quot;eatCookie&quot;);\n                PTR goHome&#x3D;il2cpp_class_get_field_from_name(clazz,&quot;goHome&quot;);\n                PTR findAlien&#x3D;il2cpp_class_get_field_from_name(clazz,&quot;findAlien&quot;);\n                bool b&#x3D;true;\n                PTR b_ptr&#x3D;(PTR)&amp;b;\n                il2cpp_field_static_set_value(eatCookie,b_ptr);\n                il2cpp_field_static_set_value(goHome,b_ptr);\n                il2cpp_field_static_set_value(findAlien,b_ptr);\n                PTR o&#x3D;NULL;\n                PTR objs[1]&#x3D;&#123;NULL&#125;;\n                for(int i&#x3D;0;i&lt;105;i++)\n                    il2cpp_runtime_invoke(method,(PTR)&amp;o,objs);\n                return;\n            &#125;\n        &#125;while(method!&#x3D;NULL);\n        \n    &#125;\n    \n    \n&#125;\n\n然后至于为什么dll注入之后，就会启动某个函数的呢，这个我也是查了很多资料，发现每个DLL都有一个入口点函数，系统会在不同时刻进行调用这个函数，比如这里,就是注入的dll的函数入口点，\nBOOL APIENTRY DllMain(HMODULE hModule,DWORD  ul_reason_for_call,LPVOID lpReserved)\n&#123;\n    \n    switch (ul_reason_for_call)\n    &#123;\n        case DLL_PROCESS_ATTACH:\n            FillFunctionTable();\n            il2cpp_class_for_each(getclass,NULL); &#x2F;&#x2F;遍历每个类，查看是否是我们要找的那个类\n            if(enable_hijack)\n            &#123;\n                main_dll&#x3D;LoadLibraryA(&quot;UnityPlayer_Original.dll&quot;);\n                if(main_dll&#x3D;&#x3D;NULL)\n                &#123;\n                    MessageBoxA(NULL,&quot;Error&quot;,&quot;Error&quot;,MB_OK);\n                    TerminateProcess(GetCurrentProcess(),0);\n                    return FALSE;\n                &#125;\n                else\n                    UnityMainCall&#x3D;(PTR (*)())GetProcAddress(main_dll,&quot;UnityMain&quot;);\n            &#125;\n            &#x2F;&#x2F;Sleep(10000);\n           \n            &#x2F;&#x2F;il2cpp_alloc(64);\n            break;\n        case DLL_PROCESS_DETACH:\n            if(enable_hijack)\n                FreeLibrary(main_dll);\n            break;\n    &#125;\n    return TRUE;\n&#125;\n\n\n至于什么时刻，怎么辨别，就是靠传入的信号值，不同来辨别，比如DLL_PROCESS_ATTACH，就是当dll载入内存空间时，进行调用，其他的调用方式，看下图(copy得到):\n2.每个DLL都可以有一个入口点函数DllMain,系统会在不同的时刻调用此函数。以下是DllMain的一般形式：\n\nBOOL WINAPI DllMain(\n    HINSTANCE hinstDLL,  &#x2F;&#x2F; handle to DLL module\n    DWORD fdwReason,     &#x2F;&#x2F; reason for calling function\n    LPVOID lpReserved )  &#x2F;&#x2F; reserved\n&#123;\n    &#x2F;&#x2F; Perform actions based on the reason for calling.\n    switch( fdwReason ) \n    &#123; \n        case DLL_PROCESS_ATTACH:\n         &#x2F;&#x2F; Initialize once for each new process.\n         &#x2F;&#x2F; Return FALSE to fail DLL load.\n            break;\n\n        case DLL_THREAD_ATTACH:\n         &#x2F;&#x2F; Do thread-specific initialization.\n            break;\n\n        case DLL_THREAD_DETACH:\n         &#x2F;&#x2F; Do thread-specific cleanup.\n            break;\n\n        case DLL_PROCESS_DETACH:\n         &#x2F;&#x2F; Perform any necessary cleanup.\n            break;\n    &#125;\n    return TRUE;  &#x2F;&#x2F; Successful DLL_PROCESS_ATTACH.\n&#125;\n先来看一下这个函数传递进来的参数：\n1、 HINSTANCE hinstDLL\n这个参数是该DLL实例的句柄，也就是此DLL映射到进程地址空间后，在该进程地址空间中的位置。\n2、 DWORD fdwReason\n此参数标示了调用DllMain函数的原因。有四种值，就是函数中case后的取值。各个取值的含义，稍后论述。\n3、 LPVOID lpReserved \n保留。\n\n现在我们来讨论一下fdwReason的四种取值，这些取值，也直接反映了操作系统会在何种情况下调用DllMain。\n1、DLL_PROCESS_ATTACH\n当系统第一次将一个DLL映射到进程地址空间中时，会调用DllMain，并为fdwReason传入DLL_PROCESS_ATTACH。\n注意，只有在第一次映射的时候，才会这样。如之后，另一线程再次显式加载此DLL，则操作系统只是增加该DLL的使用计数，而不会再次使用DLL_PROCESS_ATTACH来调用DllMain。\n对DLL_PROCESS_ATTACH的处理，代表了DLL的初始化。\nDllMain的返回值，也是针对DLL_PROCESS_ATTACH消息的。对于其余的三种取值，不起作用。\n对于隐式加载，如DllMain返回FALSE，则程序会启动失败。对于显式加载，则会使LoadLibrary返回NULL。\n2、DLL_PROCESS_DETACH\n当系统将一个DLL从进程地址空间中撤销映射时，则会向DllMain传入DLL_PROCESS_DETACH。我们应当在此处放置一些清理代码。\n当使用FreeLibrary时，如该线程的使用计数为0时，操作系统才会使用DLL_PROCESS_DETACH来调用DllMain。如使用计数大于0，则只是单纯的减少该DLL的计数。\n3、DLL_THREAD_ATTACH\n当进程创建一个线程，则系统会检查当前已映射到该进程空间中的所有DLL映像，并用DLL_THREAD_ATTACH来调用每个DLL的DllMain。\n只有当所有DLL都完成了对DLL_THREAD_ATTACH的处理后，新线程才会执行它的线程函数。\n另外，主线程不可能用DLL_THREAD_ATTACH来调用DllMain，因为主线程必然是在进程初始化的时候，用DLL_PROCESS_ATTACH调用DllMain的。\n4、DLL_THREAD_DETACH\n线程若要终止，会调用ExitThread，但是此函数不会立即终止线程，而是会利用DLL_THREAD_DETACH来调用当前进程地址空间中的所有DLL镜像的DllMain.\n当每个DLL的DllMain都处理完后，系统才会真正的结束线程。\n\n","slug":"mrctf的游戏逆向","date":"2021-05-24T05:57:54.000Z","categories_index":"gameReverse","tags_index":"reverse","author_index":"YenKoc"},{"id":"884cdb3da3fbfd31ea764ff186f03018","title":"pintool in CTF","content":"前言突然发现pintools对一些单字节验证的题目还挺好使的，所以就打算整整学学，唉，就是玩，2333\n安装(ubuntu16.04)不要问我，kali怎么装，应该是一样的）,无脑输入下面的shell命令就完事了\nwget -c https:&#x2F;&#x2F;software.intel.com&#x2F;sites&#x2F;landingpage&#x2F;pintool&#x2F;downloads&#x2F;pin-3.13-98189-g60a6ef199-gcc-linux.tar.gz\ntar -xvf pin-3.13-98189-g60a6ef199-gcc-linux.tar.gz\nmv pin-3.13-98189-g60a6ef199-gcc-linux pin\ncd pin&#x2F;source&#x2F;tools&#x2F;ManualExamples&#x2F;\nmake all TAEGET&#x3D;intel64\nmake all TAEGET&#x3D;ia32\n\n之后就会生成一个文件夹，本来是叫pin-xxxxx，就很多，名字改的简洁些，改成pin了，效果如下\n\n使用使用的方法基本就是命令记住就行，以下命令在pin目录路径下执行，主要是为了找到pin这个可执行文件，绝对路径和相对路径应该明白的吧，兄弟们。\n.&#x2F;pin -t &#x2F;home&#x2F;giantbranch&#x2F;pin&#x2F;source&#x2F;tools&#x2F;ManualExamples&#x2F;obj-intel64&#x2F;inscount0.so -- .&#x2F;文件名\n\n原理剖析inscount0.so这个玩意主要就是记录执行的指令数，也是我们非常常用的，我们可以利用这个指令数的差异进行爆破，我总结了下，主要是适用于单字节比较，比如输入的一个字节，经过一个加密等操作后，和密文进行对比，如果错误，程序退出，如果正确的话，是不是就进行下一个字节的判断，由此造成了指令数的差异，如果正确的话，指令数可能会暴增，但是也是不一定的，qctf有题ollvm，指令数就是输入正确的，反而指令数更少了，还是需要去根据规律去使用。\n根据ctf实例，进行分析1. 强网杯的一题xx_warm_obf这题倒是有点意思，在main函数中注册了一个信号处理函数。\n\n至于怎么发现呢，就是在调试过程中，发现了许多的int3的指令，这玩意会引起软中断的，并发送一个信号，但是由于我们使用调试器调试，所以会先将信号发送到调试器来处理，由于程序是需要int3去发送信号，并处理信号的，我们就不要去打乱这个逻辑，所以我们这里稍微修改一手信号操作。\n\n\n ok，已经不会老弹窗了，不过还有一个信号要处理，应该是一个反调试，就是关于程序超时的情况，所以一弹出，我们直接丢弃这个异常就完事了，下一步就是我们不断的去调试，发现它有很多固定的跳转模式，其实就是垃圾指令，本来程序执行的话，它的指令流程是固定的嘛，这里不谈输入的影响，但是加入一些垃圾指令后，增加了我们静态分析的难度，但是这玩意和ollvm，永远只是表面上打乱了程序流程，但是实际的trace日志上体现的，还是从上到下的执行流程，把垃圾的指令分辨出来就可以，很快到真实执行的地方了，发现这玩意就是一个方程，我们可以用z3去解，但是有pintools，这题又是单字节整活，直接安排上。\n\n\n放下pintool exp（python），实际上能操作shell都行\nimport os\nimport sys\nimport subprocess\n\nclass Shell(object):\n    def runCmd(self, cmd):\n        res &#x3D; subprocess.Popen(cmd, shell&#x3D;True, stdin&#x3D;subprocess.PIPE,\n                               stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.STDOUT)\n        sout, serr &#x3D; res.communicate()\n        return res.returncode, sout, serr, res.pid\n\n    def initPin(self, cmd):\n        res &#x3D; subprocess.Popen(cmd, shell&#x3D;True, stdin&#x3D;subprocess.PIPE,\n                               stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.STDOUT)\n        self.res &#x3D; res\n\n    def pinWrite(self, input):\n        self.res.stdin.write(input)\n\n    def pinRun(self):\n        sout, serr &#x3D; self.res.communicate()\n        return sout, serr\n\ncmd &#x3D; &#39;.&#x2F;pin -t .&#x2F;home&#x2F;giantbranch&#x2F;pin&#x2F;source&#x2F;tools&#x2F;ManualExamples&#x2F;obj-intel64&#x2F;inscount0.so -- .&#x2F;xx_warmup_obf&#39;\n\nshell &#x3D; Shell()\n\ns &#x3D; &quot;f&quot;\nimport string\nchs&#x3D;string.printable\nchs &#x3D; string.digits+string.ascii_letters+&#39;&#123;&#125;_&#39;\nfor i in range(27):\n    min_num &#x3D; 2**32\n    min_ch &#x3D; &quot;&quot;\n    for ch in chs:\n        tmp &#x3D; s + ch +(28-len(s)-1)*&#39;a&#39;+&#39;\\n&#39;\n        shell.initPin(cmd)\n        shell.pinWrite(tmp)\n        sout,serr &#x3D; shell.pinRun()\n        with open(&#39;inscount.out&#39;) as f:\n            count &#x3D; f.readline().split(&#39; &#39;)[1]\n        count &#x3D; int(count)\n        print(count,tmp,sout)\n        if(count&lt;min_num):\n            min_num &#x3D; count\n            min_ch &#x3D; ch\n    s+&#x3D;min_ch\n    print(min_num,min_ch)\n    print(&#39;flag:&#39;+s)\n\n2. QCTF ollvm这题也是很经典的一题ollvm类型题目了，可以用bird爷的去平坦化的脚本，可以去掉的，也可以有骚操作，比如pintool，在尝试输入的过程中呢，发现q，输入之后，指令数是在递增的，c也是，说明是可以使用pintool的，放下exp就完事了\nimport subprocess\nimport os\nimport logging\nimport json\nimport string\nimport time\nlogging.basicConfig(level&#x3D;logging.INFO)\nlogger &#x3D; logging.getLogger(__name__)\nclass shell(object):\n    def runCmd(self, cmd):\n        res &#x3D; subprocess.Popen(cmd, shell&#x3D;True, stdin&#x3D;subprocess.PIPE,\n                               stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.STDOUT)\n        sout, serr &#x3D; res.communicate()\n        return res.returncode, sout, serr, res.pid\n\n    def initPin(self, cmd):\n        res &#x3D; subprocess.Popen(cmd, shell&#x3D;True, stdin&#x3D;subprocess.PIPE,\n                               stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.STDOUT)\n        self.res &#x3D; res\n\n    def pinWrite(self, input):\n        self.res.stdin.write(input)\n\n    def pinRun(self):\n        sout, serr &#x3D; self.res.communicate()\n        return sout, serr\nfilename &#x3D; &quot;.&#x2F;ollvm&quot;\ncmd &#x3D; &quot;.&#x2F;pin -t &quot; + \\\n    &quot;&#x2F;home&#x2F;giantbranch&#x2F;pin&#x2F;source&#x2F;tools&#x2F;ManualExamples&#x2F;obj-intel64&#x2F;inscount0.so&quot; + &quot; -- &quot; + filename\nprint cmd\nsubprocess.Popen(cmd,shell&#x3D;True,stdin&#x3D;subprocess.PIPE,stdout&#x3D;subprocess.PIPE,stderr&#x3D;subprocess.STDOUT)\n#### brup args ascii\nstart_time &#x3D; time.time()\ndic &#x3D; string.letters+&#39;_&#123;&#125;&#39;+string.digits\ncur&#x3D;&#39;&#39;\nshell &#x3D; shell()\ncout_old&#x3D;0\nstart_time &#x3D; time.time()\nfor i in range(38):\n    for s in dic:\n        pwd &#x3D; cur+s+&#39;?&#39;*(37-len(cur))\n        print len(pwd)\n        rcmd &#x3D; cmd+&#39; &#39;+pwd\n        shell.initPin(rcmd)\n        sout,serr &#x3D; shell.pinRun()\n\twith open(&#39;inscount.out&#39;) as f:\n\t\tcount&#x3D;f.readline().split(&#39; &#39;)[1]\n\tcout&#x3D;count\n        cout_sub&#x3D; int(cout) - cout_old\n        cout_old &#x3D; int(cout)\n        if cout_sub &gt; 1000000 and cout_sub &lt; 1500000 :\n            cur&#x3D;cur+s\n        print (&quot;current flag &quot;, pwd,&quot;current count:&quot;,cout,&quot;sub_count &quot;,cout_sub)\nend_time&#x3D;time.time()\ntimes&#x3D; end_time-start_time\nprint &quot;need times :&quot;,times,&#39;s&#39;\n\n\n\n","slug":"pintool-in-CTF","date":"2021-05-22T12:28:18.000Z","categories_index":"pintool","tags_index":"reverse","author_index":"YenKoc"},{"id":"f39a6fe1a2cc6526ddedf18113d11661","title":"rctf 2018 Simple vm","content":"给了两个文件，一个是vm，一个是opcode文件，ida打开后\n\n打开了bin文件，然后将文件内容读取出来，继续进入下一个函数里面分析\n\n是一个非常明显的while switch case的解释器，ptr存着就是上面读取的opcode文件内存，这就是属于是那种已经给定了opcode，我们需要逆向解释器，结合opcode文件，推出flag，这里我就不打算把映射搞出来了，我这里的手法就是去跟踪数据流，也就是我的输入究竟经过了什么样的处理？ 需要去搞明白，为了加快我的调试速度，我先把伪代码抠下来，然后把伪代码的执行流程进行了打印\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;map&gt;\n#include &quot;defs.h&quot;\nusing namespace std;\nconst int maxm&#x3D;2e3+5;\n\nint main()&#123;\n    __int64 v0; &#x2F;&#x2F; rax\n    _BYTE *v1; &#x2F;&#x2F; rbp\n    int v2; &#x2F;&#x2F; ebx\n    __int64 v4; &#x2F;&#x2F; rdx\n    __int64 v5; &#x2F;&#x2F; rax\n    __int64 v6; &#x2F;&#x2F; rax\n    __int64 v7; &#x2F;&#x2F; rax\n    __int64 v8; &#x2F;&#x2F; rax\n    __int64 v9; &#x2F;&#x2F; rax\n    int v10; &#x2F;&#x2F; eax\n    __int64 v11; &#x2F;&#x2F; rax\n    char v12; &#x2F;&#x2F; dl\n    int v13; &#x2F;&#x2F; eax\n    int v14; &#x2F;&#x2F; eax\n    _BYTE *v15; &#x2F;&#x2F; rax\n    __int64 v16; &#x2F;&#x2F; rax\n    __int64 v17; &#x2F;&#x2F; rax\n    __int64 v18; &#x2F;&#x2F; rax\n    unsigned char ptr[396] &#x3D; &#123;\n            0x01, 0x30, 0x00, 0x00, 0x00, 0x10, 0x18, 0x43, 0x14, 0x15, 0x47, 0x40, 0x17, 0x10, 0x1D, 0x4B,\n            0x12, 0x1F, 0x49, 0x48, 0x18, 0x53, 0x54, 0x01, 0x57, 0x51, 0x53, 0x05, 0x56, 0x5A, 0x08, 0x58,\n            0x5F, 0x0A, 0x0C, 0x58, 0x09, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00,\n            0x15, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x12, 0x0B, 0x0C, 0x00, 0x01, 0x00, 0x00, 0x35, 0x00, 0x00,\n            0x00, 0x66, 0x15, 0x10, 0x01, 0x00, 0x00, 0x0E, 0x0A, 0x66, 0x16, 0x0C, 0x10, 0x01, 0x00, 0x00,\n            0x47, 0x00, 0x00, 0x00, 0x66, 0x03, 0x40, 0x01, 0x00, 0x00, 0x10, 0x11, 0xF1, 0x00, 0x00, 0x00,\n            0x13, 0x04, 0x43, 0x01, 0x00, 0x00, 0x08, 0x04, 0x41, 0x01, 0x00, 0x00, 0x10, 0x03, 0x40, 0x01,\n            0x00, 0x00, 0x08, 0x04, 0x42, 0x01, 0x00, 0x00, 0x03, 0x41, 0x01, 0x00, 0x00, 0x03, 0x43, 0x01,\n            0x00, 0x00, 0x08, 0x10, 0x03, 0x42, 0x01, 0x00, 0x00, 0x08, 0x04, 0x44, 0x01, 0x00, 0x00, 0x66,\n            0x03, 0x40, 0x01, 0x00, 0x00, 0x11, 0xF1, 0x00, 0x00, 0x00, 0x10, 0x03, 0x44, 0x01, 0x00, 0x00,\n            0x16, 0x05, 0x40, 0x01, 0x00, 0x00, 0x0E, 0x06, 0x40, 0x01, 0x00, 0x00, 0x0C, 0x45, 0x01, 0x00,\n            0x00, 0x55, 0x00, 0x00, 0x00, 0x66, 0x03, 0x46, 0x01, 0x00, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00,\n            0x13, 0x10, 0x03, 0x46, 0x01, 0x00, 0x00, 0x11, 0x11, 0x01, 0x00, 0x00, 0x13, 0x17, 0x18, 0x60,\n            0x01, 0x00, 0x00, 0x0C, 0x46, 0x01, 0x00, 0x00, 0xB6, 0x00, 0x00, 0x00, 0x01, 0x76, 0x01, 0x00,\n            0x00, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x0A, 0x49, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x46, 0x6C, 0x61, 0x67, 0x3A, 0x00, 0x00, 0x00, 0x0F,\n            0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x20, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x05, 0x57, 0x72, 0x6F, 0x6E, 0x67, 0x0A, 0x52, 0x69, 0x67, 0x68, 0x74, 0x0A, 0x00, 0x00, 0x00,\n            0x15, 0x50, 0x01, 0x00, 0x00, 0x0E, 0x12, 0x0B, 0x0C, 0x50, 0x01, 0x00, 0x00, 0x65, 0x01, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x56, 0x01, 0x00, 0x00, 0x0E, 0x12, 0x0B, 0x0C, 0x50,\n            0x01, 0x00, 0x00, 0x7B, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    &#125;;\n    unsigned int test&#x3D;~(0xffffffdf&amp;0x31);\n    printf(&quot;%d\\n&quot;,test);\n    v0 &#x3D; 0LL;\n    v1 &#x3D; ptr;\n    int dword_6010A4&#x3D;0;\n    int dword_601090&#x3D;0x18c;\n    int c;\n    while ( 1 )\n    &#123;\n        v2 &#x3D; v0 + 1;\n        switch ( v1[v0] )\n        &#123;\n            case 0:\n                return *(unsigned int *)&amp;v1[v2];\n                printf(&quot;over!&quot;);\n            case 1:\n                goto LABEL_35;\n            case 2:\n                v4 &#x3D; v2;\n                v2 &#x3D; v0 + 9;\n                v1[*(int *)&amp;v1[v4]] &#x3D; *(_DWORD *)&amp;v1[(int)v0 + 5];\n                printf(&quot;v4 &#x3D; v2;\\n&quot;\n                       &quot; v2 &#x3D; v0 + 9;\\n&quot;\n                       &quot;v1[*(int *)&amp;v1[v4]] &#x3D; *(_DWORD *)&amp;v1[(int)v0 + 5];\\n&quot;);\n                break;\n            case 3:\n                v5 &#x3D; v2;\n                v2 +&#x3D; 4;\n                v6 &#x3D; *(int *)&amp;v1[v5];\n                printf(&quot; v5 &#x3D; v2;\\n&quot;\n                       &quot; v2 +&#x3D; 4;\\n&quot;\n                       &quot;v6 &#x3D; *(int *)&amp;v1[v5];\\n&quot;);\n                goto LABEL_27;\n            case 4:\n                v7 &#x3D; v2;\n                v2 +&#x3D; 4;\n                v8 &#x3D; *(int *)&amp;v1[v7];\n                printf(&quot;v7 &#x3D; v2;\\n&quot;\n                       &quot;v2 +&#x3D; 4;\\n&quot;\n                       &quot;v8 &#x3D; *(int *)&amp;v1[v7];\\n&quot;);\n                goto LABEL_31;\n            case 5:\n                v9 &#x3D; v2;\n                v2 +&#x3D; 4;\n                v10 &#x3D; (char)v1[*(int *)&amp;v1[v9]];\n                printf(&quot; v9 &#x3D; v2;\\n&quot;\n                       &quot; v2 +&#x3D; 4;\\n&quot;\n                       &quot; v10 &#x3D; (char)v1[*(int *)&amp;v1[v9]];\\n&quot;);\n                goto LABEL_21;\n            case 6:\n                v11 &#x3D; v2;\n                v12 &#x3D; dword_6010A4;\n                v2 +&#x3D; 4;\n                v8 &#x3D; *(int *)&amp;v1[v11];\n                printf(&quot; v11 &#x3D; v2;\\n&quot;\n                       &quot; v12 &#x3D; dword_6010A4;\\n&quot;\n                       &quot; v2 +&#x3D; 4;\\n&quot;\n                       &quot; v8 &#x3D; *(int *)&amp;v1[v11];\\n&quot;);\n                goto LABEL_9;\n            case 7:\n                v13 &#x3D; dword_6010A4;\n                printf(&quot;v13 &#x3D; dword_6010A4;\\n&quot;);\n                goto LABEL_23;\n            case 8:\n                v14 &#x3D; ~(dword_6010A4 &amp; c);\n                printf(&quot;v14 &#x3D; ~(dword_6010A4 &amp; c);\\n&quot;);\n                goto LABEL_12;\n            case 0xA:\n                v14 &#x3D; getchar();\n                printf(&quot;v14 &#x3D; getchar();\\n&quot;);\n                goto LABEL_12;\n            case 0xB:\n                putchar(c);\n                printf(&quot;\\n&quot;);\n                printf(&quot;putchar(c);\\n&quot;);\n                break;\n            case 0xC:\n                v15 &#x3D; &amp;v1[*(int *)&amp;v1[v2]];\n                if ( *v15 )\n                &#123;\n                    v2 &#x3D; *(_DWORD *)&amp;v1[v2 + 4];\n                    --*v15;\n                &#125;\n                else\n                &#123;\n                    v2 +&#x3D; 8;\n                &#125;\n                printf(&quot;v15 &#x3D; &amp;v1[*(int *)&amp;v1[v2]];\\n&quot;\n                       &quot;                if ( *v15 )\\n&quot;\n                       &quot;                &#123;\\n&quot;\n                       &quot;                    v2 &#x3D; *(_DWORD *)&amp;v1[v2 + 4];\\n&quot;\n                       &quot;                    --*v15;\\n&quot;\n                       &quot;                &#125;\\n&quot;\n                       &quot;                else\\n&quot;\n                       &quot;                &#123;\\n&quot;\n                       &quot;                    v2 +&#x3D; 8;\\n&quot;\n                       &quot;                &#125;\\n&quot;);\n                break;\n            case 0xD:\n                ++c;\n                printf(&quot;++c\\n&quot;);\n                break;\n            case 0xE:\n                ++dword_6010A4;\n                printf(&quot;++dword_6010A4;\\n&quot;);\n                break;\n            case 0xF:\n                v14 &#x3D; dword_6010A4;\n                printf(&quot;v14 &#x3D; dword_6010A4;\\n&quot;);\n                goto LABEL_12;\n            case 0x10:\n                v10 &#x3D; c;\n                printf(&quot;v10&#x3D;c\\n&quot;);\n                goto LABEL_21;\n            case 0x11:\n                v16 &#x3D; v2;\n                v2 +&#x3D; 4;\n                v13 &#x3D; *(_DWORD *)&amp;v1[v16];\n                printf(&quot; v16 &#x3D; v2;\\n&quot;\n                       &quot;                v2 +&#x3D; 4;\\n&quot;\n                       &quot;                v13 &#x3D; *(_DWORD *)&amp;v1[v16];\\n&quot;);\n            LABEL_23:\n                c +&#x3D; v13;\n                printf(&quot;c+&#x3D;v13\\n&quot;);\n                break;\n            case 0x12:\n                printf(&quot; v6 &#x3D; dword_6010A4;\\n&quot;\n                       &quot; goto LABEL_27;\\n&quot;);\n                v6 &#x3D; dword_6010A4;\n                goto LABEL_27;\n\n            case 0x13:\n                v6 &#x3D; c;\n                printf(&quot;v6&#x3D;c\\n&quot;);\n            LABEL_27:\n                v14 &#x3D; (char)v1[v6];\n                printf(&quot;v14 &#x3D; (char)v1[v6];\\n&quot;\n                       &quot;goto LABEL_12;\\n&quot;);\n                goto LABEL_12;\n\n            case 0x14:\n                v17 &#x3D; v2;\n                v2 +&#x3D; 4;\n                v14 &#x3D; *(_DWORD *)&amp;v1[v17];\n                printf(&quot;v17 &#x3D; v2;\\n&quot;\n                       &quot;v2 +&#x3D; 4;\\n&quot;\n                       &quot;v14 &#x3D; *(_DWORD *)&amp;v1[v17];\\n&quot;\n                       &quot;goto LABEL_12;\\n&quot;);\n                goto LABEL_12;\n\n            case 0x15:\n                v18 &#x3D; v2;\n                v2 +&#x3D; 4;\n                v10 &#x3D; *(_DWORD *)&amp;v1[v18];\n                printf(&quot;v18 &#x3D; v2;\\n&quot;\n                       &quot;v2 +&#x3D; 4;\\n&quot;\n                       &quot;v10 &#x3D; *(_DWORD *)&amp;v1[v18];\\n&quot;);\n            LABEL_21:\n                dword_6010A4 &#x3D; v10;\n                printf(&quot;dword_6010A4 &#x3D; v10;\\n&quot;);\n                break;\n            case 0x16:\n                v8 &#x3D; dword_6010A4;\n                printf(&quot;v8 &#x3D; dword_6010A4;\\n&quot;);\n            LABEL_31:\n                v12 &#x3D; c;\n                printf(&quot;v12&#x3D;c\\n&quot;);\n            LABEL_9:\n                v1[v8] &#x3D; v12;\n                printf(&quot;v1[v8]&#x3D;v12\\n&quot;);\n                break;\n            case 0x17:\n                v14 &#x3D; c - dword_6010A4;\n                printf(&quot;v14 &#x3D; c - dword_6010A4;\\n&quot;);\n            LABEL_12:\n                c &#x3D; v14;\n                printf(&quot;c&#x3D;v14\\n&quot;);\n                break;\n            case 0x18:\n                if ( c )\n                    LABEL_35:\n                    v2 &#x3D; *(_DWORD *)&amp;v1[v2];\n                else\n                    v2 &#x3D; v0 + 5;\n                printf(&quot; if ( c )\\n&quot;\n                       &quot;                    LABEL_35:\\n&quot;\n                       &quot;                    v2 &#x3D; *(_DWORD *)&amp;v1[v2];\\n&quot;\n                       &quot;                else\\n&quot;\n                       &quot;                    v2 &#x3D; v0 + 5;\\n&quot;);\n                break;\n            default:\n                break;\n        &#125;\n        if ( v2 &gt;&#x3D; dword_601090 )\n            return 0LL;\n        v0 &#x3D; v2\n        printf(&quot;v0&#x3D;v2\\n&quot;);\n    &#125;\n&#125;\n\n\n在getchar()方法上，开始下断点，然后根据数据流，发现将输入存在某段内存空间中,在这段内存空间，下一个内存访问断点\n发现在这断下来了，\n\nv14的值就是我们的第一个内存空间的值，继续往下跟踪\nc&#x3D;v14\nv12&#x3D;c\nv1[v8]&#x3D;v12\n\n好家伙，又复制到别的地方去了，估计是怕直接在原内存中进行操作的话，容易直接被内存断点打破2333，我们把内存访问断点再一次的设定在这，2333\n​    \n跟一下这个v14\nc&#x3D;v14\nv12&#x3D;c\nv1[v8]&#x3D;v12 &#x2F;&#x2F;存放到别的地方去\n\nv14&#x3D;~(dword_10A4&amp; c) &#x2F;&#x2F;0x20&amp;str[0]\nc&#x3D;v14\nv12&#x3D;c\nv1[v8]&#x3D;v12 &#x2F;&#x2F;v8&#x3D;0x141\n\n把数据放到这段内存里了g\nt1=~(0x20+i&amp;str[i]);\nt2=~((0x20+i)&amp;t1);\nv14&#x3D;~(dword_6010a4&amp;c)\nc&#x3D;v14\nv12&#x3D;c\nv1[v8]&#x3D;v12 &#x2F;&#x2F;v8&#x3D;142 t2存进去\n\nv14&#x3D;v1[v6] &#x2F;&#x2F;v6&#x3D;141 也就是t1取出\nc&#x3D;v14\nv14&#x3D;v1[v6] &#x2F;&#x2F;v6&#x3D;140 把输入取出\nc&#x3D;v14\nv14&#x3D;~(dword_6010a4&amp;c)  t1&amp;str[i]\nc&#x3D;v14\nv10&#x3D;c\ndword_6010a4&#x3D;v10\nv14&#x3D;v1[v6] &#x2F;&#x2F;v6&#x3D;0x142 把t2取出\nc&#x3D;v14\nv14&#x3D;~(dword_6010A4&amp;c); t3&amp;t2\nc&#x3D;v14\nv12&#x3D;c\nv1[v8]&#x3D;v14 v8&#x3D;0x144\n\n\n\n说明是一波单字节操作，将0x144的最后加密部分存放到0x112中了 ,每一次调试的过程中知道了dword在那个等式中就是0x20+i\n\n\n这里就是做判断的地方，好家伙，还是倒着来判断的），不过之前我们已经把算法分析出来了，直接爆破就完事了，反正是单字节的\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;map&gt;\n#include &quot;defs.h&quot;\nusing namespace std;\nconst int maxm&#x3D;2e3+5;\n\nint main()&#123;\n\n    int res[] &#x3D; &#123;0x10,0x18,0x43,0x14,0x15,0x47,0x40,0x17,0x10,0x1d,0x4b,0x12,0x1f,0x49,0x48,0x18,0x53,0x54,0x1,0x57,0x51,0x53,0x5,0x56,0x5a,0x8,0x58,0x5f,0xa,0xc,0x58,0x9&#125;;\n\n    for(int i&#x3D;0;i&lt;32;i++)\n    &#123;\n        for(int j&#x3D;0;j&lt;256;j++)\n        &#123;\n        int t1&#x3D;~((0x20+i)&amp;j);\n        int t2&#x3D;~((0x20+i)&amp;t1);\n        int t3&#x3D;~(t1&amp;j);\n        int t4&#x3D;~(t3&amp;t2);\n        if(t4&#x3D;&#x3D;res[i])\n        &#123;\n            printf(&quot;%c&quot;,j);\n            break;\n        &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n再介绍一种z3的使用\nfrom z3 import *\ndef tt(inp,i):\n    t1&#x3D;~((0x20+i)&amp;inp)\n    t2&#x3D;~((0x20+i)&amp;t1)\n    t3&#x3D;~(t1&amp;inp)\n    t4&#x3D;~(t3&amp;t2)\n    return t4\nres&#x3D; [0x10,0x18,0x43,0x14,0x15,0x47,0x40,0x17,0x10,0x1d,0x4b,0x12,0x1f,0x49,0x48,0x18,0x53,0x54,0x1,0x57,0x51,0x53,0x5,0x56,0x5a,0x8,0x58,0x5f,0xa,0xc,0x58,0x9]\n\ns&#x3D;Solver()\ninputs&#x3D;[BitVec((&#39;w%d&#39;%i),8) for i in range(32)]\nfor yk in range(32):\n    s.add(tt(inputs[yk],yk)&#x3D;&#x3D;res[yk])\nif s.check()&#x3D;&#x3D;sat:\n    model&#x3D;s.model()\n    str&#x3D;[chr(model[inputs[j]].as_long().real) for j in range(32)]\n    print &quot;&quot;.join(str)\n\n\n","slug":"rctf-2018-Simple-vm","date":"2021-05-21T02:23:22.000Z","categories_index":"writeup","tags_index":"reverse","author_index":"YenKoc"},{"id":"43f61f74963677e07981d8eac779d6cf","title":"看雪ctf 第二题 南冥神功","content":"","slug":"看雪ctf-第二题-南冥神功","date":"2021-05-12T02:44:04.000Z","categories_index":"","tags_index":"","author_index":"YenKoc"},{"id":"5f3262e9c2aa5e7df63089bc650eb7bf","title":"津门杯2021 wp","content":"mobile加了360的壳子，frida-dexdump，脱下来就完事了，发现没native层, 好家伙，纯java呗），找到关键的dex开始审计\n，找到了两段逻辑，一段是加密的，一段是解密的，大概逆了一下，发现这题有两种做法，一种是白嫖解密接口，把给出的数据，通过替换xml，txt，db文件，再hook输入就可以直接实现傻瓜式解密，另一种就是本地复现加密接口，然后直接逆向解密。\n1.正向的操作先看下代码\npublic void i() throws NoSuchPaddingException, InvalidKeyException, NoSuchAlgorithmException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException, InvalidKeySpecException, CertificateException, UnrecoverableEntryException, KeyStoreException, NoSuchProviderException, IOException &#123;\n      String v0 &#x3D; this.f0.getText().toString(); &#x2F;&#x2F;取出data\n      String v1 &#x3D; this.e0.getText().toString(); &#x2F;&#x2F;取出key\n      this.d0 &#x3D; v1;\n      int v2 &#x3D; 0;\n      if((v1.equals(&quot;&quot;) | v0.equals(&quot;&quot;)) !&#x3D; 0) &#123;  &#x2F;&#x2F;不为空\n          Toast.makeText(StubApp.getOrigApplicationContext(this.getApplicationContext()), &quot;The user password or data is null, please check!&quot;, 0).show();\n          return;\n      &#125;\n\n      new a(this);\n      String v1_1 &#x3D; this.d0;\n      if(a.b &#x3D;&#x3D; 0) &#123;\n          a.a &#x3D; new SecureRandom().generateSeed(8);  &#x2F;&#x2F;这里生成了一个随机数种子\n          a.b &#x3D; 10;\n      &#125;\n\n      BigInteger v3 &#x3D; new BigInteger(a.a); &#x2F;&#x2F;生成了一个大整数\n      Key v1_2 &#x3D; a.a(v1_1); &#x2F;&#x2F;以前面生成的种子，生成一个key\n      Cipher v4 &#x3D; Cipher.getInstance(&quot;PBEWITHSHA256AND128BITAES-CBC-BC&quot;);\n      v4.init(1, v1_2);\n      String v1_3 &#x3D; new String(Base64.encode(v4.doFinal(v0.getBytes()), 1)); &#x2F;&#x2F;先aes加密，然后base64\n      --a.b;\n      this.k0 &#x3D; v3 + &quot;_&quot; + v1_3;  &#x2F;&#x2F;flag加密成 随机数种子大整数+下划线+aes加base64加密后的数据\n      TextView v0_1 &#x3D; this.g0;\n      StringBuilder v1_4 &#x3D; c.a.a.a.a.a(&quot;The flag is encrypted!\\n&quot;);\n      v1_4.append(this.k0);\n      v1_4.append(&quot;\\n&quot;);\n      v0_1.setText(v1_4.toString());\n      Log.i(&quot;KeyDistribution:&quot;, &quot;encString:&quot; + this.k0);\n      if(this.k0 &#x3D;&#x3D; null) &#123;\n          Toast.makeText(StubApp.getOrigApplicationContext(this.getApplicationContext()), &quot;Encryption failed！！&quot;, 0).show();\n      &#125;\n      else &#123;\n          Toast.makeText(StubApp.getOrigApplicationContext(this.getApplicationContext()), &quot;Encrypted successfully！\\n&quot;, 0).show();\n      &#125;\n\n      b v0_2 &#x3D; new b(this); &#x2F;&#x2F;创建一个本地的sqllite数据库\n      this.h0.setLength(0);\n      this.i0.setLength(0);\n      this.j0 &#x3D; null;\n      v0_2.Q &#x3D; this.d0; &#x2F;&#x2F;一开始输入的key\n      SecureRandom v6 &#x3D; new SecureRandom();\n      BigInteger[] v8 &#x3D; new BigInteger[3]; &#x2F;&#x2F;创建了一个大数的数组\n      int v9;\n      for(v9 &#x3D; 0; v9 &lt; 3; ++v9) &#123;\n          v8[v9] &#x3D; new BigInteger(0x20, v6);  生成了三个随机大整数\n          Log.i(&quot;upDateR:&quot;, v8[v9].toString());\n      &#125;\n\n      v0_2.P &#x3D; v8;\n      SecureRandom v6_1 &#x3D; new SecureRandom();\n      ArrayList v8_1 &#x3D; new ArrayList();\n      while(v8_1.size() &lt; 7) &#123;\n          BigInteger v9_1 &#x3D; new BigInteger(16, v6_1); 生成了7个随机大整数\n          if(!v8_1.contains(v9_1)) &#123;\n              v8_1.add(v9_1);\n          &#125;\n\n          Log.i(&quot;upDateX:&quot;, v8_1.toString());\n      &#125;\n\n      v0_2.R &#x3D; v8_1;\n      this.g0.append(&quot;Random numbers R and X have been successfully generated！\\n&quot;);\n      BigInteger v8_2 &#x3D; new BigInteger(v0_2.Q.getBytes()); &#x2F;&#x2F;key转换成大整数\n      BigInteger[] v6_2 &#x3D; new BigInteger[7];\n      int v9_2;\n      for(v9_2 &#x3D; 0; v9_2 &lt; 7; ++v9_2) &#123;\n          v6_2[v9_2] &#x3D; v8_2.add(v0_2.P[0].multiply(((BigInteger)v0_2.R.get(v9_2))).add(v0_2.P[1].multiply(((BigInteger)v0_2.R.get(v9_2)).pow(2))).add(v0_2.P[2].multiply(((BigInteger)v0_2.R.get(v9_2)).pow(3)))); &#x2F;&#x2F;这里有个计算，然后把值算出来，其实就是给出文件的下划线的后半段\n      &#125;\n\n      List v8_3 &#x3D; v0_2.R;\n      String[] v9_3 &#x3D; new String[7];\n      int v12;\n      for(v12 &#x3D; 0; v12 &lt; 7; ++v12) &#123;\n          v9_3[v12] &#x3D; ((BigInteger)v8_3.get(v12)).toString() + &quot;_&quot; + v6_2[v12].toString(); &#x2F;&#x2F;存放各个文件中的值，前半段就是v8_3的值，\n          StringBuilder v13 &#x3D; c.a.a.a.a.a(&quot;formatShareKey:&quot;);\n          v13.append(v9_3[v12]);\n          Log.i(&quot;KeyDistribution:&quot;, v13.toString());\n      &#125;\n\t&#x2F;&#x2F;下面就是数据存放到文件里就行\n      v0_2.S &#x3D; v9_3;\n      SharedPreferences.Editor v3_1 &#x3D; v0_2.T.getSharedPreferences(&quot;shareKeys&quot;, 0).edit();\n      v3_1.putString(&quot;key1&quot;, v0_2.S[0]);\n      v3_1.putString(&quot;key2&quot;, v0_2.S[1]);\n      v3_1.putString(&quot;key3&quot;, v0_2.S[2]);\n      v3_1.apply();\n      Log.i(&quot;KeyDistribution:&quot;, &quot;SharedPreferences store 3keys success! &quot;);\n      FileOutputStream v3_2 &#x3D; v0_2.T.openFileOutput(&quot;shareKeys.txt&quot;, 0);\n      v3_2.write(v0_2.S[3].getBytes());\n      v3_2.write(&quot;\\n&quot;.getBytes());\n      v3_2.write(v0_2.S[4].getBytes());\n      v3_2.close();\n      Log.i(&quot;KeyDistribution:&quot;, &quot;file store 2keys success! &quot;);\n      SQLiteDatabase v3_3 &#x3D; new b(v0_2.T).getWritableDatabase();\n      v0_2.onCreate(v3_3);\n      v3_3.execSQL(&quot;insert into shareKey(keyStr) values(\\&quot;&quot; + v0_2.S[5] + &quot;\\&quot;)&quot;);\n      v3_3.execSQL(&quot;insert into shareKey(keyStr) values(\\&quot;&quot; + v0_2.S[6] + &quot;\\&quot;)&quot;);\n      Log.i(&quot;KeyDistribution:&quot;, &quot;database store 2keys success! &quot;);\n      while(v2 &lt; 7) &#123;\n          StringBuilder v0_3 &#x3D; this.h0;\n          v0_3.append(&quot;output&quot;);\n          int v1_5 &#x3D; v2 + 1;\n          v0_3.append(v1_5);\n          v0_3.append(&quot;: &quot;);\n          v0_3.append(v9_3[v2]);\n          v0_3.append(&quot;\\n&quot;);\n          v2 &#x3D; v1_5;\n      &#125;\n  &#125;\n\n仔细发现，这玩意核心还是在于找出key对吧，毕竟aes 对称加密，拿到key就可以解密，在后面的解密函数也有体现，这一大堆数据，在经过shit的计算，发现最终把key还原出来的，这也就是为什么后面白嫖接口是没毛病的，那么这里我们只需要去解方程，7个方程，解4个未知数，绰绰有余，解方程，z3必须得安排一手，我发现z3这东西是真好用，尤其是那种不可逆的，用方程约束解，是真的香。贴下exp\nfrom z3 import *\nfrom Crypto.Util.number import long_to_bytes\n&#39;&#39;&#39;encString:-7821488970927517137_qaoNj5jP05riAKvxmIju6o3tg90BdCcAlBkGtP&#x2F;x4rlJGUtVwBJY+5LlhPO3YRjP\n\noutput1:8885_37582432166857160353847123081\noutput2:9640_37582432426358548450758074236\noutput3:24762_37582451494960253781775215346\noutput4:51615_37582614757994549493283390711\noutput5:31533_37582473078165981182199222865\noutput6:63809_37582777982366357470099779581\noutput7:3560_37582431290919704469684029756&#39;&#39;&#39;\nt&#x3D;[8885,9640,24762,51615,31533,63809,3560]\ncmp_data&#x3D;[37582432166857160353847123081,37582432426358548450758074236,37582451494960253781775215346,37582614757994549493283390711,37582473078165981182199222865,37582777982366357470099779581,37582431290919704469684029756]\ns&#x3D;Solver()\nkey&#x3D;Int(&#39;key&#39;)\nv8_3&#x3D;[Int(&#39;v%d&#39;% i) for i in range(3)]\nfor i in range(7):\n    s.add(key+v8_3[0]*t[i]+v8_3[1]*t[i]**2+v8_3[2]*t[i]**3&#x3D;&#x3D;cmp_data[i])\nif s.check()&#x3D;&#x3D;sat:\n    print(s.model())\n    key &#x3D; s.model()[key].as_long()\n    print long_to_bytes(key)\n\n\n\n\npackage com.example.jm;\n\nimport androidx.appcompat.app.AppCompatActivity;\n\nimport android.content.Context;\nimport android.os.Bundle;\nimport android.util.Base64;\nimport android.widget.TextView;\n\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.spec.InvalidKeySpecException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\n\npublic class MainActivity extends AppCompatActivity &#123;\n\n    TextView textView;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) &#123;\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        textView&#x3D;findViewById(R.id.text1);\n        try &#123;\n            textView.setText(check());\n        &#125; catch (BadPaddingException e) &#123;\n            e.printStackTrace();\n        &#125; catch (IllegalBlockSizeException e) &#123;\n            e.printStackTrace();\n        &#125; catch (NoSuchPaddingException e) &#123;\n            e.printStackTrace();\n        &#125; catch (NoSuchAlgorithmException e) &#123;\n            e.printStackTrace();\n        &#125; catch (InvalidKeySpecException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    public String check() throws BadPaddingException, IllegalBlockSizeException, NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeySpecException &#123;\n        a.a &#x3D; new BigInteger(&quot;-7821488970927517137&quot;).toByteArray();\n        String v3_5&#x3D;&quot;qaoNj5jP05riAKvxmIju6o3tg90BdCcAlBkGtP&#x2F;x4rlJGUtVwBJY+5LlhPO3YRjP&quot;;\n        byte[] v1_1 &#x3D; Base64.decode(v3_5, 2);\n        Key v2_6 &#x3D; a.a(&quot;you_are_good&quot;);\n        Cipher v3_6 &#x3D; Cipher.getInstance(&quot;PBEWITHSHA256AND128BITAES-CBC-BC&quot;);\n        try &#123;\n            v3_6.init(2, v2_6);\n        &#125; catch (InvalidKeyException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return new String(v3_6.doFinal(v1_1));\n    &#125;\n\n&#125;\n&#x2F;* class a &#123;\n    public static byte[] a &#x3D; null;\n    public static int b &#x3D; 10;\n\n    public a(Context arg2) &#123;\n        this.a &#x3D; new SecureRandom().generateSeed(8);\n    &#125;\n\n    public static Key a(String arg4) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;\n        PBEKeySpec v0 &#x3D; new PBEKeySpec(arg4.toCharArray(), a, 10000, 0x80);\n        return SecretKeyFactory.getInstance(&quot;PBEWITHSHA256AND128BITAES-CBC-BC&quot;).generateSecret(v0);\n    &#125;\n&#125;\n*&#x2F;\n\npackage com.example.jm;\n\nimport android.content.Context;\n\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.spec.InvalidKeySpecException;\n\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\n\npublic class a &#123;\n\n    public static byte[] a &#x3D; null;\n    public static int b &#x3D; 10;\n\n    public a(Context arg2) &#123;\n        this.a &#x3D; new SecureRandom().generateSeed(8);\n    &#125;\n\n    public static Key a(String arg4) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;\n        PBEKeySpec v0 &#x3D; new PBEKeySpec(arg4.toCharArray(), a, 10000, 0x80);\n        return SecretKeyFactory.getInstance(&quot;PBEWITHSHA256AND128BITAES-CBC-BC&quot;).generateSecret(v0);\n    &#125;\n&#125;\n\n\n\n\nre1. easyre就不放图了，出题人故意修改了elf文件的字段值，导致无法运行，尝试修改oep，发现还有段错误，所以就放弃了，群里大哥聊到和sctf的一题算法一样，找到了链接，然后发现这道题根本就是sctf orz的缩小版，把des加密的部分去掉了，所以连exp都是可以白嫖的，不过还有一个lua程序，发现是先解密，然后在后面程序中调用了这个算法，所以我们的exp还需要微调一下，直接从指纹爷那里嫖一手exp，魔改一下，然后记得约束还要确保是ascii码，否则跑出来就是乱码,z3绝对是一个爆破好手，最终转化成等式就可以开始乱杀）\nfrom z3 import *\n\ndest_enc&#x3D;[0x005B3600, 0x000000CB, 0x005B3422, 0x0000025D, 0x005B38EA, 0x00000F5B, 0x005B34F0, 0x00000057, 0x005B372A, 0x00000504, 0x005B3429, 0x00001365, 0x005B2542, 0x00000293, 0x005B35EA, 0x00000D6E, 0x005B3B2B, 0x00000697, 0x005B4282, 0x00000941, 0x005B33F9, 0x0000772B, 0x005B2839, 0x00000D8A, 0x005B3CFE, 0x00000861, 0x005B28BC, 0x00007710, 0x005B1224, 0x0000326E, 0x005B26AC, 0x00001DE8]\nfrom Crypto.Cipher import DES\nimport struct\nimport time\n\n\ndef Z3(xor_data, cmp_data):\n    s&#x3D;Solver()\n\n    flag &#x3D; [BitVec((&#39;x%d&#39; % i), 8) for i in range(32)]\n    xor_result &#x3D; [0 for i in range(64)]\n    for i in range(32):\n        for j in range(33):\n            a &#x3D; flag[i] ^ xor_data[j]\n            xor_result[i + j] +&#x3D; a\n            xor_result[i+j]&#x3D;(xor_result[i+j]^5977654)\n\n    for i in range(0, 32):\n        s.add(flag[i]&lt;&#x3D;127)\n        s.add(flag[i]&gt;&#x3D;32)\n        s.add(xor_result[i] &#x3D;&#x3D; cmp_data[i])\n\n    if s.check() &#x3D;&#x3D; sat:\n        model &#x3D; s.model()\n        str &#x3D; [chr(model[flag[i]].as_long().real) for i in range(32)]\n        print(&quot;&quot;.join(str))\n        time.sleep(5)\n        exit()\n    else:\n        print(&quot;unsat&quot;)\n\ndef myrandint( start,end,seed):\n    a&#x3D;32310901\n    b&#x3D;1729\n    rOld&#x3D;seed\n    m&#x3D;end-start\n    while True:\n        rNew&#x3D;int((a*rOld+b)%m)\n        yield rNew\n        rOld &#x3D; rNew\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n\n    for seed in range(0xfff):\n        xor_data &#x3D; []\n        # r &#x3D; myrandint(1, 255, 99)\n        r &#x3D; myrandint(1, 255, seed)\n        for i in range(33):\n            xor_data.append(next(r))\n        # r &#x3D; myrandint(1, 255, 99)\n\n        Z3(xor_data, dest_enc)\n\n2.  GOODRE这题算比较easy一点的，重点在于要动调，多逆，静态分析有时候头晕的话，动调看汇编，很快会走出去困局，直接看注释吧\n\n\n很明显的tea加密，就不多bb了，一个是tea常数，特别注意就是密钥是硬编码的，要自己根据算法流程去找就行了，其他没什么好说的\n","slug":"津门杯2021-wp","date":"2021-05-10T02:48:37.000Z","categories_index":"writeup","tags_index":"reverse","author_index":"YenKoc"},{"id":"65a729b015fbeb895e9e3c25a8f4953e","title":"记录下修改smail的骚操作以及如何重打包","content":"前言在被各种的重打包工具折磨之后，群里大佬推荐我看看珍惜哥的视频学学，这肯定得冲了呀，看了一小时，看完了，感觉学到一点骚操作，挺好玩的，就记录下\nsmail的修改在patch java层的时候，我们通常是去反编译apk，然后去修改smail，之后再重新编译打包签名，得把几个过程分开来看\n反编译这里我之前就用androidkiller和apk改之理，来发编译，但是最近发现反编译没啥问题，但是好家伙，打包的时候会报错，查阅了下资料，原来是jdk14以上，默认签名是使用jdk去签名的了，不使用apktools了，所以我另外下了一个jdk8，单独设置了路径，这个问题解决了，但是有些apk，重打包还是会出现问题），这里说偏了），说回来，珍惜师傅推荐是android逆向助手，我下了一个，界面比较简洁\n\n这里我主要是用来反编译dex的。至于为什么不是整个apk，下面会说\n修改smail先写个demo\npackage com.example.smailtest;\n\nimport androidx.appcompat.app.AppCompatActivity;\n\nimport android.os.Bundle;\nimport android.widget.TextView;\n\npublic class MainActivity extends AppCompatActivity &#123;\n\n    TextView tv;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) &#123;\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        tv&#x3D;findViewById(R.id.tvt);\n        tv.setText(Test.getXx());\n    &#125;\n&#125;\n\npackage com.example.smailtest;\n\npublic class Test &#123;\n    public static int xx&#x3D;2;\n    public static int getXx()\n    &#123;\n        return xx;\n    &#125;\n\n&#125;\n\n将生成的apk，弄出来，反编译\n\n打开Test.smail文件，记事本永远的神\n\n语法非常简单，那么如果我想要修改getXx()方法的返回值的，或者怎么修改，我们是不是要按照手册一行一行写的呢，肯定不是的，珍惜表哥，提了一个骚操作，就是把jeb反编译好的，代码直接抄一份到androidstudio中，然后我们自己手动改好逻辑后，利用java2smail转换成smail文件，不就直接接近了我们想要的效果了吗，2333，到时候寄存器有点变化，不用管，手动调整过来就好了\npackage com.example.smailtest;\n\npublic class Test &#123;\n    public static int xx&#x3D;2;\n    public static int getXx()\n    &#123;\n        return 100000;\n    &#125;\n\n&#125;\n\n\n\n\n抄下来，是这样的，然后修改了一手，之后大概是我想要的效果。然后转换成smail\n\n直接copy到我们的smail文件中，利用逆向助手，重新编译成dex\n重打包打包不一定非要使用之前那种androidkiller和改之理整体apk编译重打包的，我们可以把apk看成zip，然后把我们修改编译后的dex，替换原来的dex，然后修改后缀为apk，这时候我们只需要签名就完事了\n\n重新签名，这里选择mt管理器的重打包签名，非常的稳，牛逼，这里直接手机上操作就完事了，哦对，支持正版哦，\n签名后，正常运行，搞定，嘿嘿\n","slug":"记录下修改smail的骚操作以及如何重打包","date":"2021-05-06T09:20:45.000Z","categories_index":"安卓小技巧","tags_index":"reverse","author_index":"YenKoc"},{"id":"b380b394179f19e6fa4ccc3b184ec926","title":"ISCC某安卓题","content":"口述下:ctf的安卓题，不能以实战的角度去逆了，毕竟从ctf角度出发，我们需要的是最短时间拿到flag，而不是把整体app代码全部分析出来，昨晚睡前，大概看了下文件就睡了，早上把逻辑理了下，就开始了，首先是java2c，这个问题，其实就是和java层的代码一样，不过是写在ndk中的，样子比较丑，和反射长的差不多，可以去hook art，也可以直接看逻辑，我用了下杨神的轮子，大概打印了下，发现流程是正常，不过这样其实也偏了，就算前期把一些数剧改了，也没关系，反正后期我们用的是改完之后的数据去获得flag的，所以根本不需要在意他怎么改，嫖就完事了，直接定位到点击事件，onclick方法，也是一个native方法，直接跟进去，发现这里就是核心逻辑，不过先调用了一个check1方法，跟进去，发现是ollvm 虚假控制流，看了下混淆比较轻，直接手调，发现就是一个验证code长度是不是为6，组成是不是只有小写的字母，然后继续下一步，就是正式调试，发现先经过一个md5加密，然后每个字节每4位开始转换成字符，其实就是md5成32位的字符串，然后经过一个等式，来判断code是否正确，看了下不可逆，不过是可以直接爆破的，写exp开始跑\nimport hashlib\n\ntt&#x3D;&quot;&quot;\nflag&#x3D;&quot;abcdefghijklmnopqrstuvwxyz&quot;\nv35&#x3D;0\nfor a in range(26):\n    for b in range(26):\n        for c in range(26):\n            for d in range(26):\n                for e in range(26):\n                    for f in range(26):\n                        #tt+&#x3D;\n                        m &#x3D; hashlib.md5()\n                        tt&#x3D;flag[a]+flag[b]+flag[c]+flag[d]+flag[e]+flag[f]\n                        m.update(bytes(tt, encoding&#x3D;&quot;utf8&quot;))\n                        res&#x3D;m.hexdigest()\n                        v33&#x3D;0\n                        v34&#x3D;0\n\n                        for yk in range(len(res)):\n                            if ord(res[yk])&#x3D;&#x3D;48:\n                                v35&#x3D;yk\n                            else:\n                                v35&#x3D;0\n                            if ord(res[yk])&#x3D;&#x3D;48:\n                                v33+&#x3D;1\n                            v34+&#x3D;v35\n                        if v34+10*v33&#x3D;&#x3D;403:\n                            print(&quot;right!:&quot;+tt)\n                            exit(0)\n                        else:\n                            print(&quot;wrong answer:&quot;+tt)\n                        tt&#x3D;&quot;&quot;\n\n这里注意hashlib.md5()这个方法，每次只调用一次，否则会一直变动，之前跑了一次，但是没跑出来，调试了下源程序，发现了这个问题，改过来后，直接就可以跑出来了，大概3个小时，\n\n然后接下来就是用code中的一些字符作为伪随机的种子，之前以为是前4位，调试后，发现不是，不过和我们输入的flag没关系，那么说明是跟着code变化，code的正确，值也必然对，直接dump下来，就完事了，写个exp，搞定\nimport java.util.Random;\n\npublic class getFlag &#123;\n    public static void main(String[] args) &#123;\n        String test&#x3D;&quot;ozulmt&quot;;\n        char[] tt&#x3D;new char[]&#123;&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;;\n        int v49&#x3D;test.charAt(0);\n        int v50&#x3D;test.charAt(1);\n        int v51&#x3D;test.charAt(2);\n        int v52&#x3D;test.charAt(3);\n        System.out.println(v49);\n        Random rd&#x3D;new Random(0xcc18);\n        StringBuilder sb&#x3D;new StringBuilder();\n        for(int w&#x3D;0;w&lt;32;w++)\n        &#123;\n           sb.append(tt[rd.nextInt(16)]);\n        &#125;\n        System.out.println(sb.toString());\n\n    &#125;\n&#125;\n\n6ab457d7223583baa46d8b2cb1c3c406\ncode和flag正确输入，发现弹出ISCC{6ab457d7223583baa46d8b2cb1c3c406}，结束，总体出的还行\n","slug":"ISCC某安卓题","date":"2021-05-02T11:56:33.000Z","categories_index":"writeup","tags_index":"reverse","author_index":"YenKoc"},{"id":"ab7fd6f31dafc73ffe830b8abfe31bb7","title":"肉丝的任务罢了","content":"第一道题\n逻辑很简单，就是输入一个username，然后经过一个native函数，和字符串做对比\n\n调用了一个base64，\n\n第二题和第一题java层逻辑差不多，稍微复杂一点，大概就是数字先md5加密，然后原数字经过一个aes-cbc加密，和md5加密后的进行拼接，进行一波对比。cbc的加密逻辑看了挺久，我以为有魔改，看了下逻辑并没有，直接hook下函数，把key和iv dump下来，解密就完事了\n\nfunction aa()&#123;\n    var moudle&#x3D;Process.findModuleByName(&quot;libroysue.so&quot;);\n    var hoofunc&#x3D;ptr(moudle.base).add(0x341e8);\n    Interceptor.attach(hoofunc,&#123;\n        onEnter:function(args)&#123;\n            console.log(&quot;key:&quot;,Memory.readPointer(ptr(args[3]),16));\n            console.log(&quot;content:&quot;,Memory.readCString(args[3]),16);\n            console.log(&quot;iv:&quot;,Memory.readCString(args[4]));\n\n        &#125;,onLeave:function(retval)\n        &#123;\n\n\n        &#125;\n    &#125;)\n&#125;\nsetImmediate(aa);\n\n\n第三题和第二题一样的逻辑，只是加了一些反调试，不过确实太鸡肋了，这波我静态就能搞了，甚至三个函数全nop重打包，一个是检测调试去的，看traceid，一个是看手机型号，一个是检测aosp，hh，frida一把梭也可以。\n\n其他确实没啥好说的，强度不够高，算法不够复杂\n","slug":"肉丝的任务罢了","date":"2021-04-25T14:03:22.000Z","categories_index":"writeup","tags_index":"reverse","author_index":"YenKoc"},{"id":"92105b8d45b62e5c37b36b7d4a309a89","title":"2021HW的个人总结","content":"1.hw给我带来什么？​     首先，我今年能来护网真的算是我的运气了，至于为什么这么说，因为在面试这个部门的过程中，其实遇到了一些插曲，在一面的时候，回答的还算完美，之前跟着樱花师傅写的os和csapp lab还是有印象的，在二面的时候，就开始崩了，问了很多安卓开发的问题，然而我这里很久没有去熟悉开发的知识，导致很多问题没有回答上，我对自己都很不满意，于是在寒假的时候又重温了安卓开发），这个是后话了，估计是二面有点炸，所以安排了一个总监面，和吕老大加上了微信，我们直接开始了面试，我大致介绍了我的情况，然后聊了一些技术方面的问题，后面又聊了下我是为什么在学校没人学安全的情况下依旧想从事安全的，以及组建安全实验室的事，我就如实回答的了，其实自己也没想那么多，我只觉得安全很有意思，它为我打开了一个新世界，同时能有成就感吧，可能是我每天的日报和我的真诚，打动了吕老大，面完之后，lulu说老大很欣赏我对技术的热情，我也感觉到很惊喜，后面也和我预想的一样，我面试通过了，但是我不敢松懈，我觉得技术不能只靠热情，还是需要实力说话，所以就开始认真搞起了实战，从开始实习到现在，收获不少，同事们也非常nice，技术也提升了不少，好像写偏了），继续回归，总体来说这次hw，自己在移动端没有给团队给来什么收益分，虽然小强哥也给我们几个app分析，可是逆完，发现伤害性不大，mmp，甚至可以伪造令牌登录，没啥大用，但是发现科恩那边有用这个app的逻辑洞打进邮箱的，心理就有点难受，因为那个逻辑洞是需要用户id的，我们意识到了，但是没号啊，这需要数据库的账号才能做到，所以说web爷爷没进展的话，我们几乎就没啥输出，后面就是对着几个app的接口，各种尝试，然而服务器那边权限一直关闭，我们普通用户权限一点机会都没有），所以就很尴尬，后面就认清自己的定位了，哪里需要我，我就去哪，打辅助这个我在行，就一直帮小强哥翻数据，搞到了很不错的数据，嘿嘿，算是欣慰了，最后一段时间，就是帮着昆哥搞报告了，在搞报告的过程中，看到了web爷爷们的报告，感觉到很厉害，自己也学到一些渗透的思路，虽然我这方面弱的一，hh，但是我觉得技术不能受限制，要多去学习和接受，这样才能走的更远！上面那么多废话，核心就是打开了自己的思路，涨了见识，看到了大厂的团队协作模式，这些都是宝贵的人生经历，感谢吕老大，感谢明哥，也感谢那个不肯放弃的自己。\n2. 意外之喜这几天我见到了自己的偶像，夜影大哥，他对我的整个ctf生涯影响很大，可以说就是看夜影大哥的博客入门的，以及后面在迷茫中，夜影大哥也给了我很多意见，我真的非常感谢他，这次hw，我没想到他也在，hw前几天我还不认识川老板，知道2st把照片发给我看，我才知道是川老板，进而判断了下夜影说不定也在，试探性的问了下，居然真的在，后面就真的面基了，感觉挺不可思议的，感觉大佬们都很有亲和力，人都很不错，哈哈。\n今晚直接疯了，见到了tk教主，还握手并合影了，激动炸了！！！！！！！！！\n3. 我接下来要做些什么呢？继续把基础搞扎实，然后把pc缺的那部分补上，pc的思想对安卓的进阶学习是有很大好处的，我觉得还是有很多相通的点，然后就是多实战，多把自己平常的想法投入实践，多逆，多问，加油！！\n","slug":"2021HW的个人总结","date":"2021-04-22T17:50:06.000Z","categories_index":"总结","tags_index":"总结","author_index":"YenKoc"},{"id":"17e7f940452dda42feb97fd742be4e95","title":"DDCTF 黑盒破解","content":"前言最近在出校赛的题，和csu联合出题，压力还是有的，题目不可能出的太水的，所以我最近的想法，搞点有意思的题，看看vm的几种实现，然后自己写写，感受下，然后开始搞搞开发了，嘿嘿，vm做个开胃菜，之后玩点上次github上看到的东西。\n开始分析，ida上号这题vm是属于需要自己构造bytecode的，然后构造得出flag，另一种是给出bytecode，然后根据bytecode的加密流程，把flag逆向出来，第二种我觉得比第一种简单，毕竟程序流程是固定的，我们可以直接实现一个解释器，然后通过bytecode，和逆向出的虚拟机dispatcher，弄出伪代码，然后就可以愉快的逆向了，第一种，就emmm，属于得自己去猜和想，这个程序流程要怎么走，难度更大，这题恰好是第一种，只能耐心推导了。\n\nsub401E90函数和sub4016BD函数是用来初始化vm环境的，\n\n基本上是一个大型结构体，这个结构体太大，本来想用ida构造个出来的，后面发现字段太多了，玩不动，这里中间和中午看vm构造，差不多\n\n同样用一个结构体存储这一个opcode，下面是一个handler，其他就是表的各种操作，直接不看，反正和输入没有任何关系，表中的数据，我们只需要在使用的时候，必然是正确的，dump就完事了，接着往下走\n\n发现我们的输入，作为上文初始化表的下标，和之前定义的opcode开始作对比，丝毫不慌，我们知道了opcode，直接逆推下标，就知道我们的输入范围是什么，pycharm启动\n\nbyte_603900&#x3D;[\n  0x02, 0x00, 0x00, 0x0E, 0x16, 0x54, 0x20, 0x18, 0x11, 0x45,\n  0x50, 0x59, 0x58, 0x53, 0x00, 0x08, 0x44, 0x2D, 0x46, 0x39,\n  0x00, 0x54, 0x42, 0x01, 0x3C, 0x0F, 0x00, 0x07, 0x17, 0x00,\n  0x56, 0x21, 0x00, 0x37, 0x6D, 0x2B, 0x2A, 0x6E, 0x59, 0x5D,\n  0x47, 0x3A, 0x4A, 0x34, 0x44, 0x48, 0x43, 0x6C, 0x3F, 0x59,\n  0x25, 0x33, 0x55, 0x2F, 0x31, 0x68, 0x27, 0x34, 0x7C, 0x28,\n  0x67, 0x59, 0x00, 0x52, 0x00, 0x26, 0x00, 0x3E, 0x56, 0x4E,\n  0x33, 0x21, 0x45, 0x6D, 0x60, 0x39, 0x46, 0x72, 0x6D, 0x4D,\n  0x54, 0x40, 0x00, 0x74, 0x57, 0x73, 0x72, 0x7A, 0x47, 0x45,\n  0x00, 0x71, 0x00, 0x4A, 0x35, 0x70, 0x3B, 0x36, 0x2E, 0x26,\n  0x2C, 0x6C, 0x4A, 0x00, 0x7C, 0x63, 0x35, 0x57, 0x4D, 0x41,\n  0x43, 0x62, 0x00, 0x68, 0x37, 0x00, 0x5A, 0x6A, 0x6B, 0x7C,\n  0x29, 0x69, 0x4C, 0x70, 0x50, 0x71, 0x26, 0x36, 0x3C, 0x06,\n  0x1B, 0x00, 0x3C, 0x30, 0x00, 0x00, 0x00, 0x4C, 0x0B, 0x4B,\n  0x48, 0x08, 0x54, 0x47, 0x12, 0x09, 0x24, 0x00, 0x00, 0x24,\n  0x40, 0x0D, 0x39, 0x06, 0x5C, 0x2C, 0x1A, 0x2D, 0x0A, 0x38,\n  0x35, 0x37, 0x16, 0x3B, 0x00, 0x24, 0x48, 0x00, 0x49, 0x00,\n  0x37, 0x08, 0x1F, 0x24, 0x45, 0x1D, 0x11, 0x40, 0x2F, 0x4A,\n  0x08, 0x15, 0x00, 0x11, 0x00, 0x1A, 0x22, 0x41, 0x52, 0x5B,\n  0x0B, 0x45, 0x31, 0x19, 0x43, 0x19, 0x1E, 0x0A, 0x21, 0x05,\n  0x4D, 0x59, 0x38, 0x34, 0x09, 0x36, 0x2F, 0x43, 0x02, 0x53,\n  0x12, 0x2F, 0x4C, 0x21, 0x0D, 0x3C, 0x31, 0x2E, 0x37, 0x08,\n  0x30, 0x29, 0x32, 0x2F, 0x00, 0x1A, 0x14, 0x41, 0x53, 0x15,\n  0x21, 0x00, 0x08, 0x13, 0x38, 0x5C, 0x36, 0x3B, 0x50, 0x00,\n  0x2F, 0x1E, 0x57, 0x00, 0x30, 0x2E, 0x0C, 0x2E, 0x37, 0x52,\n  0x1C, 0x33, 0x34, 0x11, 0x38, 0x00\n]\nopcode&#x3D;[0x2A,0x27,0x3e,0x5A,0x3F,0x4E,0x6A,0x2B,0x28]\ninputD&#x3D;[]\nfor j in range(len(opcode)):\n    inputD.append(chr(byte_603900.index(opcode[j])&amp;0xff))\nprint(inputD)\n\n\n这里有点坑的就是表被改了，具体追溯有点麻烦，直接在对比的地方，下断点把正确的opcode dump下来就算成功了。\n\n基本上可以确定我们的输入的范围，就在这个九个字母选择，不同的字母对应不同的handler，这里常规步骤是逆向handler，将handler提取出来，然后尝试还原成伪代码，我们跟进不同的函数走着看，然后把关键步骤，都提取出来，比较直观\n#  *(_BYTE *)(a1 + 665) &#x3D; *(_BYTE *)(*(_QWORD *)(a1 + 8) + *(int *)(a1 + 288));\n\n# *(_BYTE *)(*(int *)(a1 + 288) + *(_QWORD *)(a1 + 8)) &#x3D; *(_BYTE *)(a1 + 665);\n\n#  *(_BYTE *)(a1 + 665) &#x3D; *(_BYTE *)(a1 + 665) + *(_BYTE *)(a1 + 664) - 33;\n\n#  *(_BYTE *)(a1 + 665) &#x3D; *(_BYTE *)(a1 + 665) - *(_BYTE *)(a1 + 664) + 33;  ++*(_BYTE *)(a1 + 665);\n\n# ++*(_DWORD *)(a1 + 288);\n\n#  --*(_DWORD *)(a1 + 288);\n\n# ++*(_DWORD *)(a1 + 288);   *(_BYTE *)(*(_QWORD *)(a1 + 280) + *(int *)(a1 + 288) + *(_QWORD *)a1) &#x3D; *(_BYTE *)(a1+ 16+ *(int *)(a1 + 288)+ (__int64)*(char *)(a1 + 664)- 48)- 49;\n\n# for ( i &#x3D; 0; *(char *)(a1 + 664) &gt; i; ++i )\n#     ++*(_DWORD *)(a1 + 288);\n# *(_BYTE *)(*(_QWORD *)(a1 + 280) + *(int *)(a1 + 288) + *(_QWORD *)a1) &#x3D; *(_BYTE *)(a1 + 16+ *(int *)(a1 + 288) + (__int64)*(char *)(a1 + 664) - 48)- 49;\n\n#  *(_DWORD *)(a1 + 288) +&#x3D; *(char *)(a1 + 664);\n\n #*(_BYTE *)(a1 + 665) *&#x3D; *(_BYTE *)(a1 + 664);\n#*(_BYTE *)(*(_QWORD *)(a1 + 280) + * (int *)(a1 + 288) +*(_QWORD *)a1) &#x3D; *(_BYTE *)(a1+ * (int *)(a1 + 288)+ (__int64) * (char *)(a1 + 664))- 17;\n\n# *(char *)(a1 + 665) &#x2F;&#x3D; *(char *)(a1 + 664);\n\n#*(_BYTE *)((int)++*(_DWORD *)(a1 + 288) + *(_QWORD *)(a1 + 8)) &#x3D; *(_BYTE *)(a1 + 664);\n#*(_BYTE *)(*(_QWORD *)(a1 + 280) + * (int *)(a1 + 288) +*(_QWORD *)a1) &#x3D; *(_BYTE *)(a1+ 16+ * (int *)(a1 + 288) + (__int64) * (char *)(a1 + 664) - 80)- 81;\n\n# *(_BYTE *)(a1 + 664) &#x3D; *(_BYTE *)(*(_QWORD *)(a1 + 8) + (int)(*(_DWORD *)(a1 + 288))--);\n# *(_BYTE *)(*(_QWORD *)(a1 + 280) + *(int *)(a1 + 288) + *(_QWORD *)a1) &#x3D; *(_BYTE *)(a1+ 16+ *(int *)(a1 + 288) + (__int64)*(char *)(a1 + 664)- 32)- 33\n\n这样看，太丑了，我们用我们的理解的伪代码弄出来。\n&#39;$&#39;: tmp&#x3D;data[index]\n&#39;8&#39;: data[index]&#x3D;tmp\n&#39;C&#39;: tmp&#x3D;tmp+input[i]-33\n&#39;t&#39;: tmp&#x3D;tmp-input[i]+33; --tmp\n&#39;0&#39;: index++\n&#39;E&#39;: check\n&#39;u&#39;: index--\n&#39;#&#39;: data[index]&#x3D;input[index+input[i]-48]-49\n&#39;;&#39;: \nfor(int j&#x3D;0;j&lt;input[i];j++)\n\t++index\ndata[index]&#x3D;input[index+input[i]-48]-49\n\ncheck函数，主要就是判断PaF0!&amp;Prv}H{ojDQ#7v=是否转变成Binggo\n接下来就开始构造，P-&gt;B 这里肯定是先取数据，然后处理，然后再塞回去，这里数字由大变小，肯定是选t来处理的。\n基本上就是$t/80，以此类推就完事了。\n这里比较绕的点，在于后面那个将data在第7个字符后面截断的时，需要填入的\\0，这里需要特别构造\n这里构造方式很多，就不多逼逼了，这题真有意思，草，调一天了，舒服了。\n  $t/80$C11111)80$CI80$CX80$Cg80$Cj80#1uuuuuuEs\n","slug":"DDCTF-黑盒破解","date":"2021-04-22T06:07:05.000Z","categories_index":"writeup","tags_index":"reverse","author_index":"YenKoc"},{"id":"a285eb2e1ce3d42c5752f972d9befc34","title":"解决基于多线程栈回溯不够深度，无法定位到具体代码","content":"前言现在的发包框架都是新起一个线程，然后把一些发包逻辑塞到里面去，之前学习到去hook一些java层的api，可以去栈回溯，但是在实战中发现，就是我们的栈回溯最高层，只能回溯到java.lang.Thread类，但是这个无法让我们快速找到关键代码，而且为什么只能回溯到java.lang.Thread类呢，就只能从源码中去找答案.\n源码分析先写个安卓里面新建线程的demo\nnew Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;helll&quot;);\n            &#125;\n        &#125;).start();\n\n发现是创建了一个thread对象，并在构造函数中，传入了一个runnable对象，全是匿名的，我们去跟下这个Thread类\n，看看是如何新建线程的，\n\n\n\n到目前为止，只是new了thread对象，还没开始新建线程，只是把线程的初始化环境配好。再跟下start方法\n\n跟进nativeCreate方法\n\n好家伙，是jni函数，这里有个技巧，就是jni函数找源码，类名加下划线加jni函数，就能找到。\n\n\n\n发现最终还是调用libc中的pthreadcreate方法，去新建进程，继续跟下这个线程会执行什么，这时候已经到新建线程里了，\n\n发现了为什么我们栈回溯，一直最高层是java.lang.Thread，因为我们新线程最先执行是java.lang.Thread.run方法。\n所以我们的核心问题是找到主线程是在哪里新建线程的，所以我们hook的对象应该是在主进程过程中的执行流程，然后打印\n这里可选的点还是蛮多的，这里选init2，然后还可以把target对象的classname打印出来的，放下frida 脚本\n&#x2F;&#x2F;package:com.example.hookso\nfunction LogPrint(log) &#123;\n    var theDate &#x3D; new Date();\n    var hour &#x3D; theDate.getHours();\n    var minute &#x3D; theDate.getMinutes();\n    var second &#x3D; theDate.getSeconds();\n    var mSecond &#x3D; theDate.getMilliseconds();\n\n    hour &lt; 10 ? hour &#x3D; &quot;0&quot; + hour : hour;\n    minute &lt; 10 ? minute &#x3D; &quot;0&quot; + minute : minute;\n    second &lt; 10 ? second &#x3D; &quot;0&quot; + second : second;\n    mSecond &lt; 10 ? mSecond &#x3D; &quot;00&quot; + mSecond : mSecond &lt; 100 ? mSecond &#x3D; &quot;0&quot; + mSecond : mSecond;\n    var time &#x3D; hour + &quot;:&quot; + minute + &quot;:&quot; + second + &quot;:&quot; + mSecond;\n    var threadid &#x3D; Process.getCurrentThreadId();\n    console.log(&quot;[&quot; + time + &quot;]&quot; + &quot;-&gt;threadid:&quot; + threadid + &quot;--&quot; + log);\n\n&#125;\n\nfunction printJavaStack(name) &#123;\n    Java.perform(function () &#123;\n        var Exception &#x3D; Java.use(&quot;java.lang.Exception&quot;);\n        var ins &#x3D; Exception.$new(&quot;Exception&quot;);\n        var straces &#x3D; ins.getStackTrace();\n        if (straces !&#x3D; undefined &amp;&amp; straces !&#x3D; null) &#123;\n            var strace &#x3D; straces.toString();\n            var replaceStr &#x3D; strace.replace(&#x2F;,&#x2F;g, &quot; \\n &quot;);\n            LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n            LogPrint(replaceStr);\n            LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; \\n &quot;);\n            Exception.$dispose();\n        &#125;\n    &#125;);\n&#125;\nfunction hookThread()\n&#123;\n    Java.perform(function()&#123;\n         var YThreadClass&#x3D;Java.use(&quot;java.lang.Thread&quot;);\n         YThreadClass.init2.implementation&#x3D;function(arg0)\n         &#123;\n             var target&#x3D;this.target.value;\n             if(target!&#x3D;null)\n             &#123;\n                LogPrint(&quot;go into Thread.init2 -&gt;Runnable class:&quot;+target.$className);\n                printJavaStack(&quot;java.lang.Thread.init2&quot;);\n             &#125;else&#123;\n                 LogPrint(&quot;go into Thread.init2-&gt;Thread.class:&quot;,this.$className);\n                 printJavaStack(&quot;java.lang.Thread.init2&quot;);\n                 var threadclassname&#x3D;this.$className;\n                 var ChindThreadClass.run.implementation&#x3D;function()&#123;\n                     LogPrint(&quot;go into&quot;+threadclassname+&quot;.run&quot;);\n                     printJavaStack(threadclassname+&quot;.run&quot;);\n                     var result&#x3D;this.run();\n                     return result;\n                 &#125;\n             &#125;\n         \n         var res&#x3D;this.init2(arg0);\n         return res;\n        &#125;\n        YThreadClass.run.implementation&#x3D;function()\n        &#123;\n            var target &#x3D; this.target.value;\n            if (target !&#x3D; null) &#123;\n                LogPrint(&quot;go into Thread.run-&gt;Runnable class:&quot; + target.$className);\n                printJavaStack(&quot;java.lang.Thread.run&quot;)\n            &#125;\n\n            var reuslt &#x3D; this.run();\n            return reuslt;\n        &#125;\n\n    &#125;)\n\n    \n&#125;\nfunction main()\n&#123;\n    hookThread();\n&#125;\nsetImmediate(main)    \n\n\n\n\n效果真不错\n","slug":"解决基于多线程栈回溯不够深度，无法定位到具体代码","date":"2021-04-21T02:05:56.000Z","categories_index":"app抓包","tags_index":"抓包","author_index":"YenKoc"},{"id":"3c82e2c97f4021478c0aae078b24ed3b","title":"ZUC密码","content":"前言复现mrctf题中，发现有题涉及到zuc密码，这个之前好像有听说过，但是没去细致看过，所以就看了几篇博客，跟了下流程，把算法抄了一遍，加深下影响，去具体背加密流程，我这脑子也记不下，只能是熟悉流程和特征，对应的看了233\n源代码#include &lt;iostream&gt;\n\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n&#x2F;*the state register of LFSR*&#x2F;\ntypedef unsigned char u8;\ntypedef unsigned int u32;\nu32 LFSR_S[16]&#x3D;&#123;0&#125;;\n\n&#x2F;*the register of F*&#x2F;\nu32 F_R1&#x3D;0;\nu32 F_R2&#x3D;0;\n\n&#x2F;*the outputs of BitReorganization*&#x2F;\nu32 BRC_X[4]&#x3D;&#123;0&#125;;\n\n\nu8 S0[256] &#x3D; &#123;\n        0x3e, 0x72, 0x5b, 0x47, 0xca, 0xe0, 0x00, 0x33, 0x04, 0xd1, 0x54, 0x98, 0x09, 0xb9, 0x6d, 0xcb,\n        0x7b, 0x1b, 0xf9, 0x32, 0xaf, 0x9d, 0x6a, 0xa5, 0xb8, 0x2d, 0xfc, 0x1d, 0x08, 0x53, 0x03, 0x90,\n        0x4d, 0x4e, 0x84, 0x99, 0xe4, 0xce, 0xd9, 0x91, 0xdd, 0xb6, 0x85, 0x48, 0x8b, 0x29, 0x6e, 0xac,\n        0xcd, 0xc1, 0xf8, 0x1e, 0x73, 0x43, 0x69, 0xc6, 0xb5, 0xbd, 0xfd, 0x39, 0x63, 0x20, 0xd4, 0x38,\n        0x76, 0x7d, 0xb2, 0xa7, 0xcf, 0xed, 0x57, 0xc5, 0xf3, 0x2c, 0xbb, 0x14, 0x21, 0x06, 0x55, 0x9b,\n        0xe3, 0xef, 0x5e, 0x31, 0x4f, 0x7f, 0x5a, 0xa4, 0x0d, 0x82, 0x51, 0x49, 0x5f, 0xba, 0x58, 0x1c,\n        0x4a, 0x16, 0xd5, 0x17, 0xa8, 0x92, 0x24, 0x1f, 0x8c, 0xff, 0xd8, 0xae, 0x2e, 0x01, 0xd3, 0xad,\n        0x3b, 0x4b, 0xda, 0x46, 0xeb, 0xc9, 0xde, 0x9a, 0x8f, 0x87, 0xd7, 0x3a, 0x80, 0x6f, 0x2f, 0xc8,\n        0xb1, 0xb4, 0x37, 0xf7, 0x0a, 0x22, 0x13, 0x28, 0x7c, 0xcc, 0x3c, 0x89, 0xc7, 0xc3, 0x96, 0x56,\n        0x07, 0xbf, 0x7e, 0xf0, 0x0b, 0x2b, 0x97, 0x52, 0x35, 0x41, 0x79, 0x61, 0xa6, 0x4c, 0x10, 0xfe,\n        0xbc, 0x26, 0x95, 0x88, 0x8a, 0xb0, 0xa3, 0xfb, 0xc0, 0x18, 0x94, 0xf2, 0xe1, 0xe5, 0xe9, 0x5d,\n        0xd0, 0xdc, 0x11, 0x66, 0x64, 0x5c, 0xec, 0x59, 0x42, 0x75, 0x12, 0xf5, 0x74, 0x9c, 0xaa, 0x23,\n        0x0e, 0x86, 0xab, 0xbe, 0x2a, 0x02, 0xe7, 0x67, 0xe6, 0x44, 0xa2, 0x6c, 0xc2, 0x93, 0x9f, 0xf1,\n        0xf6, 0xfa, 0x36, 0xd2, 0x50, 0x68, 0x9e, 0x62, 0x71, 0x15, 0x3d, 0xd6, 0x40, 0xc4, 0xe2, 0x0f,\n        0x8e, 0x83, 0x77, 0x6b, 0x25, 0x05, 0x3f, 0x0c, 0x30, 0xea, 0x70, 0xb7, 0xa1, 0xe8, 0xa9, 0x65,\n        0x8d, 0x27, 0x1a, 0xdb, 0x81, 0xb3, 0xa0, 0xf4, 0x45, 0x7a, 0x19, 0xdf, 0xee, 0x78, 0x34, 0x60&#125;;\n\nu8 S1[256] &#x3D; &#123;\n        0x55, 0xc2, 0x63, 0x71, 0x3b, 0xc8, 0x47, 0x86, 0x9f, 0x3c, 0xda, 0x5b, 0x29, 0xaa, 0xfd, 0x77,\n        0x8c, 0xc5, 0x94, 0x0c, 0xa6, 0x1a, 0x13, 0x00, 0xe3, 0xa8, 0x16, 0x72, 0x40, 0xf9, 0xf8, 0x42,\n        0x44, 0x26, 0x68, 0x96, 0x81, 0xd9, 0x45, 0x3e, 0x10, 0x76, 0xc6, 0xa7, 0x8b, 0x39, 0x43, 0xe1,\n        0x3a, 0xb5, 0x56, 0x2a, 0xc0, 0x6d, 0xb3, 0x05, 0x22, 0x66, 0xbf, 0xdc, 0x0b, 0xfa, 0x62, 0x48,\n        0xdd, 0x20, 0x11, 0x06, 0x36, 0xc9, 0xc1, 0xcf, 0xf6, 0x27, 0x52, 0xbb, 0x69, 0xf5, 0xd4, 0x87,\n        0x7f, 0x84, 0x4c, 0xd2, 0x9c, 0x57, 0xa4, 0xbc, 0x4f, 0x9a, 0xdf, 0xfe, 0xd6, 0x8d, 0x7a, 0xeb,\n        0x2b, 0x53, 0xd8, 0x5c, 0xa1, 0x14, 0x17, 0xfb, 0x23, 0xd5, 0x7d, 0x30, 0x67, 0x73, 0x08, 0x09,\n        0xee, 0xb7, 0x70, 0x3f, 0x61, 0xb2, 0x19, 0x8e, 0x4e, 0xe5, 0x4b, 0x93, 0x8f, 0x5d, 0xdb, 0xa9,\n        0xad, 0xf1, 0xae, 0x2e, 0xcb, 0x0d, 0xfc, 0xf4, 0x2d, 0x46, 0x6e, 0x1d, 0x97, 0xe8, 0xd1, 0xe9,\n        0x4d, 0x37, 0xa5, 0x75, 0x5e, 0x83, 0x9e, 0xab, 0x82, 0x9d, 0xb9, 0x1c, 0xe0, 0xcd, 0x49, 0x89,\n        0x01, 0xb6, 0xbd, 0x58, 0x24, 0xa2, 0x5f, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xb8, 0x95, 0xe4,\n        0xd0, 0x91, 0xc7, 0xce, 0xed, 0x0f, 0xb4, 0x6f, 0xa0, 0xcc, 0xf0, 0x02, 0x4a, 0x79, 0xc3, 0xde,\n        0xa3, 0xef, 0xea, 0x51, 0xe6, 0x6b, 0x18, 0xec, 0x1b, 0x2c, 0x80, 0xf7, 0x74, 0xe7, 0xff, 0x21,\n        0x5a, 0x6a, 0x54, 0x1e, 0x41, 0x31, 0x92, 0x35, 0xc4, 0x33, 0x07, 0x0a, 0xba, 0x7e, 0x0e, 0x34,\n        0x88, 0xb1, 0x98, 0x7c, 0xf3, 0x3d, 0x60, 0x6c, 0x7b, 0xca, 0xd3, 0x1f, 0x32, 0x65, 0x04, 0x28,\n        0x64, 0xbe, 0x85, 0x9b, 0x2f, 0x59, 0x8a, 0xd7, 0xb0, 0x25, 0xac, 0xaf, 0x12, 0x03, 0xe2, 0xf2&#125;;\n\nu32 EK_d[16] &#x3D; &#123;\n        0x44d7, 0x26bc, 0x626b, 0x135e, 0x5789, 0x35e2, 0x7135, 0x09af,\n        0x4d78, 0x2f13, 0x6bc4, 0x1af1, 0x5e26, 0x3c4d, 0x789a, 0x47ac&#125;;\n#define MAKEU31(a,b,c) (((u32)((u32)(0)|(u8)(a))&lt;&lt;23)|(u32)((u32)(0)|(u8)(c)))\n&#x2F;*Bit Reorganization*&#x2F;\nvoid BitReorganization()\n&#123;\n    BRC_X[0]&#x3D;((LFSR_S[15]&amp;0x7FFF8000)&lt;&lt;1)|(LFSR_S[14]&amp;0xFFFF);\n    BRC_X[1]&#x3D;((LFSR_S[11]&amp;0xFFFF)&lt;&lt;16)|(LFSR_S[9]&gt;&gt;15);\n    BRC_X[2]&#x3D;((LFSR_S[7]&amp;0xFFFF)&lt;&lt;16)|(LFSR_S[5]&gt;&gt;15);\n    BRC_X[3]&#x3D;((LFSR_S[2]&amp;0xFFFF)&lt;&lt;16)|(LFSR_S[0]&gt;&gt;15);\n&#125;\n#define MAKEU32(a,b,c,d) (((u32)(a)&lt;&lt;24)|((u32)(b)&lt;&lt;16)|((u32)(c)&lt;&lt;8)|((u32)(d)))\n#define ROT(a,k) (((a)&lt;&lt;k)|((a)&gt;&gt;(32-k)))\n&#x2F;*L1*&#x2F;\nu32 L1(u32 X)\n&#123;\n    return (X^ROT(X,2)^ROT(X,10)^ROT(X,18)^ROT(X,24));\n&#125;\n&#x2F;*L2*&#x2F;\nu32 L2(u32 X)\n&#123;\n    return (X^ROT(X,8)^ROT(X,14)^ROT(X,22)^ROT(X,30));\n&#125;\n\n&#x2F;*F*&#x2F;\nu32 F()&#123;\n    u32 W,W1,W2,u,v;\n    W&#x3D;(BRC_X[0]^F_R1)+F_R2;\n    W1&#x3D;F_R1+BRC_X[1];\n    W2&#x3D;F_R2+BRC_X[2];\n    u&#x3D;L1((W1&lt;&lt;16)|W2&gt;&gt;16);\n    v&#x3D;L2((W2&lt;&lt;16|W1&gt;&gt;16));\n    F_R1&#x3D; MAKEU32(S0[u&gt;&gt;24],S1[(u&gt;&gt;16)&amp;0xFF],S0[(u&gt;&gt;8)&amp;0xFF],S1[u&amp;0xFF]);\n    F_R2&#x3D;MAKEU32(S0[v&gt;&gt;24],S1[(v&gt;&gt;16)&amp;0xFF],S0[(v&gt;&gt;8)&amp;0xFF],S1[v&amp;0xFF]);\n    return W;\n&#125;\nu32 AddM(u32 a,u32 b)\n&#123;\n    u32 c&#x3D;a+b;\n    return (c&amp;0x7FFFFFFF)+(c&gt;&gt;31);\n&#125;\n#define MulByPow2(x,k) ((((x) &lt;&lt; k) | ((x) &gt;&gt; (31 - k))) &amp; 0x7FFFFFFF)\n&#x2F;* LFSR with work mode *&#x2F;\nvoid LFSRWithWorkMode()\n&#123;\n    u32 f,v;\n    u32 i;\n    f&#x3D;LFSR_S[0];\n    v&#x3D;MulByPow2(LFSR_S[0],8);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[4],20);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[10],21);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[13],17);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[15],15);\n    f&#x3D;AddM(f,v);\n    &#x2F;*update the state*&#x2F;\n    for(i&#x3D;0;i&lt;15;i++)&#123;\n        LFSR_S[i]&#x3D;LFSR_S[i+1];\n    &#125;\n    LFSR_S[15]&#x3D;f;\n&#125;\nvoid LFSRWithInitializationMode(u32 u)\n&#123;\n    u32 f,v;\n    u32 i;\n    f&#x3D;LFSR_S[0];\n    v&#x3D;MulByPow2(LFSR_S[0],8);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[4],20);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[10],21);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[13],17);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[15],15);\n    f&#x3D;AddM(f,v);\n    f&#x3D; AddM(f,u);\n    &#x2F;*update the state*&#x2F;\n    for(i&#x3D;0;i&lt;15;i++)&#123;\n        LFSR_S[i]&#x3D;LFSR_S[i+1];\n    &#125;\n    LFSR_S[15]&#x3D;f;\n&#125;\n&#x2F;*initialize*&#x2F;\nvoid Initiallization(u8 *k,u8 *iv)\n&#123;\n    u32 w,nCount;\n    u32 i;\n\n    &#x2F;*expand key*&#x2F;\n    for(i&#x3D;0;i&lt;16;i++)\n    &#123;\n        LFSR_S[i]&#x3D;MAKEU31(k[i],EK_d[i],iv[i]);\n    &#125;\n\n    &#x2F;*set F_R1 and F_R2 to zero*&#x2F;\n    F_R1&#x3D;0;\n    F_R2&#x3D;0;\n    nCount&#x3D;32;\n    while(nCount&gt;0)\n    &#123;\n        BitReorganization();\n        w&#x3D;F();\n        LFSRWithInitializationMode(w&gt;&gt;1);\n        nCount--;\n    &#125;\n    &#x2F;*First generation abandoned*&#x2F;\n    BitReorganization();\n    F();\n    LFSRWithWorkMode();\n\n&#125;\nvoid GenerateKeyStream(u32* pKeyStream,u32 KeyStreamLen)\n&#123;\n    u32 i;\n    for(i&#x3D;0;i&lt;KeyStreamLen;i++)\n    &#123;\n        BitReorganization();\n        pKeyStream[i]&#x3D;F()^BRC_X[3];\n        LFSRWithWorkMode();\n    &#125;\n&#125;\nint main() &#123;\n    u8 key[16]&#x3D;&#123;0x3d,0x4c,0x4b,0xe9,0x6a,0x82,0xfd, 0xae, 0xb5, 0x8f, 0x64, 0x1d, 0xb1, 0x7b, 0x45, 0x5b&#125;;\n    u8 iv[16]&#x3D;&#123;0x84,0x31,0x9a,0xa8,0xde,0x69,0x15,0xca,0x1f,0x6b,0xda,0xd8,0xc7,0x66&#125;;\n    u32 pKeyStream[4]&#x3D;&#123;0&#125;;\n    u32 KeyStreamLen&#x3D;sizeof(pKeyStream)&#x2F;sizeof(pKeyStream[0]);\n    Initiallization(key,iv);\n    GenerateKeyStream(pKeyStream,KeyStreamLen);\n    for(int i&#x3D;0;i&lt;KeyStreamLen;i++)\n    &#123;\n        printf(&quot;z%d:\\t0x%08x\\n&quot;,i,pKeyStream[i]);\n    &#125;\n\n&#125;\n\n比较明显的就是四个x寄存器，然后那两张s表，以及最后的x3寄存器的异或，都可以作为判断的标准，自己用c++搞完，编译后，strip去完符号，用ida打开，看了看\n\n\n\n结尾研究了下ubuntu的c/c++编译环境，配置了下，感觉还不错，反正比我win虚拟机强mmp，linux用起来还是舒服，去符号找了很久\n参考链接:\nhttps://blog.csdn.net/qq_38737992/article/details/90288994\nhttps://blog.csdn.net/qq_43094622/article/details/105823724\nhttps://blog.csdn.net/listener51/article/details/53836213\n","slug":"ZUC密码","date":"2021-04-19T12:05:24.000Z","categories_index":"密码学","tags_index":"密码学","author_index":"YenKoc"},{"id":"62c420e89414aa7b4113290b58fef1bf","title":"2021MRCTF Re wp","content":"My Register这题我觉得出的非常好，真不错，我都学到了很多，尤其是这种双进程保护，之前其实挺懵逼的，最近可能是自己基础更扎实了，很多概念一点就能通，总体就是父进程创建子进程，根据标记，会走向不同分支，这样还不够刺激，还没达到反调试，我们可以在子进程的代码中强行加入一些异常处理，这样当执行到异常处理时，有调试器时（这时候父进程就是调试器）会将执行权转移到父进程，发送一个信号给父进程，父进程代码中设置了while（true），不断的等待，当信号过来时，根据异常的类型，走向不同的分支，这时候父进程作为调试器是可以操作子进程的寄存器以及内存的，也就意味着，我们可以将子进程某个段或者函数进行加密，当异常处理时，父进程再进行解密，leave爷真有你的哦\n\n\n这里是最骚的，如果你去动调，直接完犊子，这个isDeggerpresent本来检测是父进程还是子进程，一般是子进程才能走这个分支，但是当我们用ida去动调时，父进程因为有了调试器，也就意味着，这个父进程进去了，mmmp，后面我分析就很乱，很懵逼。。这里设计是巧妙的。\n\n这里是上面我说的，是负责解密子进程的地方，还有修改rip的地方，之前调试父进程一直有异常，问题就在这里跳过的，跟进子进程\n\n差不多就是两个输入，然后创建了一个文件，再继续跟\n\n就加密方式，没啥好说的，只是注意一点就是email是不影响最后结果，放下exp\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&quot;defs.h&quot;\nint main()\n&#123;\n   int dword_4xx[376]&#x3D;&#123;0x0000001D, 0x0000006E, 0x0000004E, 0x0000003F, 0x00000039, 0x0000003A, 0x00000028, 0x00000029, 0x00000017, 0x00000014, 0x00000037, 0x00000046, 0x00000043, 0x00000030, 0x00000011, 0x00000012, 0x0000002D, 0x0000002E, 0x00000002, 0x0000000C, 0x00000030, 0x00000031, 0x00000032, 0x0000003E, 0x00000025, 0x00000026, 0x00000005, 0x00000076, 0x0000005E, 0x0000002D, 0x0000000F, 0x0000000C, 0x0000001D, 0x0000001E, 0x0000003F, 0x0000004C, 0x00000066, 0x00000015, 0x00000038, 0x0000003B, 0x00000015, 0x00000016, 0x00000006, 0x00000075, 0x0000006F, 0x0000001C, 0x00000003, 0x00000000, 0x0000000D, 0x0000007C, 0x0000007F, 0x00000003, 0x00000010, 0x0000006C, 0x0000007A, 0x0000000B, 0x00000005, 0x00000006, 0x0000002A, 0x0000002B, 0x00000021, 0x00000052, 0x0000007D, 0x0000000E, 0x00000050, 0x00000053, 0x0000007F, 0x0000007C, 0x0000005B, 0x0000005A, 0x00000056, 0x00000058, 0x0000006C, 0x00000010, 0x00000006, 0x00000077, 0x00000071, 0x00000072, 0x00000050, 0x00000051, 0x0000007D, 0x0000000E, 0x00000011, 0x00000062, 0x00000078, 0x0000007B, 0x0000006B, 0x00000068, 0x00000076, 0x00000078, 0x0000007E, 0x00000070, 0x00000071, 0x00000070, 0x00000043, 0x00000040, 0x0000005D, 0x00000051, 0x00000046, 0x0000003A, 0x00000005, 0x00000079, 0x00000042, 0x0000004C, 0x00000079, 0x0000007A, 0x00000057, 0x00000026, 0x00000023, 0x0000005F, 0x0000004A, 0x00000044, 0x0000006D, 0x0000006C, 0x0000006C, 0x0000006F, 0x00000049, 0x0000004A, 0x00000066, 0x00000067, 0x00000054, 0x0000005A, 0x0000005E, 0x00000050, 0x00000063, 0x00000062, 0x00000052, 0x00000051, 0x000000BD, 0x000000BE, 0x0000009D, 0x0000009C, 0x000000A9, 0x000000A8, 0x00000097, 0x00000099, 0x000000AD, 0x000000D1, 0x000000C6, 0x000000B7, 0x000000B1, 0x000000B2, 0x00000090, 0x000000E3, 0x000000DC, 0x000000A0, 0x000000B7, 0x000000B9, 0x0000008B, 0x0000008A, 0x000000BB, 0x000000B8, 0x000000A5, 0x000000A6, 0x000000B7, 0x000000B6, 0x00000082, 0x000000F1, 0x000000DD, 0x000000AE, 0x000000BE, 0x000000B0, 0x00000086, 0x0000008A, 0x00000099, 0x000000E8, 0x000000E5, 0x00000096, 0x000000B8, 0x000000B9, 0x000000B4, 0x000000C7, 0x000000E1, 0x00000092, 0x00000080, 0x00000083, 0x0000008D, 0x0000008E, 0x000000A2, 0x000000A3, 0x000000A5, 0x000000A4, 0x000000AB, 0x000000D8, 0x000000F7, 0x00000084, 0x00000094, 0x000000E7, 0x000000F1, 0x00000080, 0x00000083, 0x00000080, 0x000000D0, 0x000000A3, 0x00000081, 0x000000F2, 0x000000E9, 0x000000E8, 0x000000D9, 0x000000D8, 0x000000E6, 0x000000E7, 0x000000D5, 0x000000D6, 0x000000F1, 0x000000F2, 0x000000D1, 0x000000A2, 0x00000093, 0x00000092, 0x00000090, 0x000000E3, 0x000000C4, 0x000000C5, 0x000000C9, 0x000000C8, 0x000000C7, 0x000000C4, 0x000000E7, 0x000000E4, 0x000000C1, 0x000000C0, 0x000000F0, 0x000000F1, 0x000000F0, 0x000000F1, 0x000000FC, 0x0000008F, 0x000000A6, 0x000000D5, 0x000000F8, 0x000000FB, 0x000000D5, 0x000000D6, 0x000000C7, 0x000000B4, 0x0000008D, 0x0000008C, 0x000000A3, 0x000000D0, 0x000000DE, 0x000000DF, 0x000000EC, 0x000000ED, 0x000000E9, 0x000000EA, 0x000000CB, 0x000000BA, 0x000000BA, 0x000000C9, 0x000000E7, 0x00000094, 0x000000B0, 0x000000CC, 0x000000DB, 0x000000D5, 0x0000002E, 0x0000002F, 0x0000002C, 0x0000002F, 0x00000039, 0x0000003A, 0x00000016, 0x00000017, 0x00000017, 0x00000016, 0x00000017, 0x00000019, 0x00000029, 0x00000055, 0x00000041, 0x00000040, 0x00000052, 0x0000002E, 0x00000037, 0x0000003B, 0x00000029, 0x0000002A, 0x00000006, 0x00000075, 0x00000054, 0x00000028, 0x0000003F, 0x00000031, 0x00000030, 0x0000003E, 0x0000003A, 0x00000034, 0x0000000D, 0x0000007E, 0x0000006E, 0x0000001F, 0x00000019, 0x0000001A, 0x00000039, 0x0000004A, 0x00000049, 0x00000048, 0x00000065, 0x00000016, 0x0000003C, 0x0000003D, 0x00000002, 0x0000000C, 0x00000015, 0x00000069, 0x0000007E, 0x0000000F, 0x00000009, 0x0000000A, 0x0000002B, 0x00000058, 0x00000074, 0x00000007, 0x00000016, 0x00000018, 0x00000019, 0x00000017, 0x0000002F, 0x0000002E, 0x0000006D, 0x0000001E, 0x00000000, 0x00000071, 0x00000079, 0x0000007A, 0x0000006A, 0x00000019, 0x00000004, 0x00000077, 0x00000064, 0x00000017, 0x0000000F, 0x00000073, 0x0000006A, 0x00000064, 0x0000004D, 0x0000004C, 0x00000042, 0x00000041, 0x00000069, 0x00000018, 0x0000001B, 0x0000001A, 0x0000001B, 0x0000001A, 0x00000016, 0x00000065, 0x00000042, 0x0000004C, 0x0000007A, 0x00000006, 0x0000002D, 0x0000002C, 0x0000002E, 0x0000005F, 0x00000059, 0x0000005A, 0x00000076, 0x00000077, 0x00000075, 0x0000007B, 0x0000004E, 0x00000040, 0x00000073, 0x00000000, 0x00000021, 0x00000052, 0x00000060, 0x0000006E, 0x00000056, 0x0000002A, 0x00000036, 0x00000047, 0x0000004B, 0x00000078&#125;;\n\n    for(int i&#x3D;374;i&gt;&#x3D;0;i--)\n    &#123;\n        dword_4xx[i]&#x3D;(char)dword_4xx[i]^(char)dword_4xx[i+1]^i;\n    &#125;\n    unsigned __int8 v20;\n    unsigned __int8 v19;\n    unsigned __int8 v18;\n    dword_4xx[375]&#x3D;0x78;\n    char v10[96];\n    char res1[500]&#x3D;&#123;0&#125;;\n    strcpy(v10,&quot;ABCDEFGH&quot;);\n    strcpy(&amp;v10[9],&quot;12345678&quot;);\n    strcpy(&amp;v10[18],&quot;0IJKLMNO&quot;);\n    strcpy(&amp;v10[27],&quot;+OPQRStu&quot;);\n    strcpy(&amp;v10[36],&quot;\\\\vwxyzTU&quot;);\n    strcpy(&amp;v10[45],&quot;abcdefgh&quot;);\n    strcpy(&amp;v10[54],&quot;VWXYZijk&quot;);\n    strcpy(&amp;v10[63],&quot;lmnopqrs&quot;);\n    int ccc&#x3D;0;\n    for(int i&#x3D;0;i&lt;&#x3D;374;i+&#x3D;2)\n    &#123;\n        for(int j&#x3D;0;j&lt;255;j++)\n        &#123;\n            v20&#x3D;(j&gt;&gt;6)&amp;1;\n            v19&#x3D;(j&gt;&gt;3)&amp;7;\n            v18&#x3D;j&amp;7;\n            if(v10[9*v20+v19]&#x3D;&#x3D;dword_4xx[i]&amp;&amp;v10[9*v19+v18]&#x3D;&#x3D;dword_4xx[i+1])\n            &#123;\n              res1[i&#x2F;2]&#x3D;j;\n              ccc+&#x3D;1;\n              break;\n            &#125;\n        &#125;\n    &#125;\n    \n    printf(&quot;%s&quot;,res1);\n    printf(&quot;%d&quot;,ccc);\n&#125;\n\n\n\nc &#x3D; &quot;4d#52#e2#188#2b0#4b3#7a6#c8d#14a1#218d#36a7#5864#8f80#e843#17827#2609d#3d926#63a38#a13c5#104e5c#1a6252#2ab122#4513b3#6fc534#b4d955#1249eb9#1d9786d#2fe179d#4d7906b#7d5a841#cad38cd#1482e18b#&quot;\ntt&#x3D;c.split(&quot;#&quot;)\ntt&#x3D;tt[:-1]\nprint(int(&quot;0x&quot;+tt[0],16))\nflag&#x3D;chr(0x4d)+chr(0x52)\nprint(tt)\nfor i in range(2,len(tt)):\n    tempSum&#x3D;int(&quot;0x&quot;+tt[i-1],16)+int(&quot;0x&quot;+tt[i-2],16)\n    tempSxm&#x3D;int(&quot;0x&quot;+tt[i],16)\n    flag+&#x3D;chr(tempSxm-tempSum)\nprint(flag)\n\n\n\n\n\ndynnamic_debug意思是动态调试，那就动调呗，按之前的经验就是f7就完事了，到一些关键地方，基本就解密完成了，这题也一样\n然后就是tea加密，很常规，key拿到之后，解密就完事了\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &quot;defs.h&quot;\n#include&lt;iostream&gt;\n  \n&#x2F;&#x2F;加密函数  \nvoid encrypt (uint32_t* v, uint32_t* k) &#123;  \n    uint32_t v0&#x3D;v[0], v1&#x3D;v[1], sum&#x3D;0, i;           &#x2F;* set up *&#x2F;  \n    uint32_t delta&#x3D;0x9e3779b9;                     &#x2F;* a key schedule constant *&#x2F;  \n    uint32_t k0&#x3D;k[0], k1&#x3D;k[1], k2&#x3D;k[2], k3&#x3D;k[3];   &#x2F;* cache key *&#x2F;  \n    for (i&#x3D;0; i &lt; 32; i++) &#123;                       &#x2F;* basic cycle start *&#x2F;  \n        sum +&#x3D; delta;  \n        v0 +&#x3D; ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);  \n        v1 +&#x3D; ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);  \n    &#125;                                              &#x2F;* end cycle *&#x2F;  \n    v[0]&#x3D;v0; v[1]&#x3D;v1;  \n&#125;  \n&#x2F;&#x2F;解密函数  \nvoid decrypt (uint32_t* v, uint32_t* k) &#123;  \n    uint32_t v0&#x3D;v[0], v1&#x3D;v[1], sum&#x3D;0xC6EF3720, i;  &#x2F;* set up *&#x2F;  \n    uint32_t delta&#x3D;0x9e3779b9;                     &#x2F;* a key schedule constant *&#x2F;  \n    uint32_t k0&#x3D;k[0], k1&#x3D;k[1], k2&#x3D;k[2], k3&#x3D;k[3];   &#x2F;* cache key *&#x2F;  \n    for (i&#x3D;0; i&lt;32; i++) &#123;                         &#x2F;* basic cycle start *&#x2F;  \n        v1 -&#x3D; ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);  \n        v0 -&#x3D; ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);  \n        sum -&#x3D; delta;  \n    &#125;                                              &#x2F;* end cycle *&#x2F;  \n    v[0]&#x3D;v0; v[1]&#x3D;v1;  \n&#125;  \n  \nint main()  \n&#123;  \n    uint32_t v[] &#x3D;\n&#123;\n  0x5585A199, 0x7E825D68,0x944D0039, 0x71726943, 0x6A514306, 0x4B14AD00, 0x64D20D3F, 0x9F37DB15&#125;;\n    uint32_t k[4]&#x3D;&#123;0x6B696C69,0x79645F65,0x696D616E,0x67626463&#125;;  \n    &#x2F;&#x2F; v为要加密的数据是两个32位无符号整数  \n    &#x2F;&#x2F; k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位   \n    for(int i&#x3D;0;i&lt;8;i+&#x3D;2)\n    &#123;\n        decrypt(v+i, k);  \n    &#125; \n    \n    printf(&quot;%s&quot;,v); \n    return 0;  \n&#125;  \n\n\n","slug":"2021MRCTF-Re-wp","date":"2021-04-17T03:54:09.000Z","categories_index":"writeup","tags_index":"reverse","author_index":"YenKoc"},{"id":"e5bc877fa4a0c33bb045786c11ac5c34","title":"pikachu靶场-RCE","content":"概述\n其实就是没对输入做限制，我们可以构造输入，然后直接在对方的服务器上执行，芜湖\nexec ping\n用管道符隔开，可以执行两段命令，记住就行\nexec eval\n执行不了就会报错，所以我们这里直接输入phpinfo();，理论上php上的任意可执行的命令都可以的\n\n","slug":"pikachu靶场-RCE","date":"2021-04-16T08:13:55.000Z","categories_index":"渗透测试","tags_index":"渗透测试","author_index":"YenKoc"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"概述\n有一说一，这里概述讲的非常清晰了，尤其是xss和csrf的区别，csrf其实就是借用他人的手去干坏事，而不是我们去拿到他的cookie去干坏事的，这里区别还是有的，核心表现就是搞个虚假链接，事先把要接口和参数写好，一点击就立马发送请求，测试了下是会自动加cookie的，所以token就很重要了，如果没有类似token这种校验，那么就无法判断这个玩意是不是他本意发送的。。毕竟cookie的时效会持续一段时间的，\ncsrf(get)\n登录后，发现一个表单是修改信息的，bp上抓包，发现是get请求，好家伙\n\n那么我只要有cookie，把参数一改，我就可以把个人信息改了，那么只需要生成一个链接，点击完事了，bp上\n有生成csrf的按钮，按完就可以操作了2333\n\n测试了一波，发现没啥大毛病，点击后，发现估计是域名识别还是，会自动加上域名的，稳\ncsrf（post）和上面差不多，emm，不过get方法，是可以直接在url上加参数，那么直接点击就处罚，post是只能用表单了\ncsrf（Token)\n和上文的暴力破解差不多的，每次请求，服务器都会返回一个不同的token，不过应该是有时效的，而且时效还不\n短，问题加了token，这个链接如果长时间没去点击就完犊子了，而且token去哪获得2333，所以这题根本没解\n","slug":"pikachu靶场-CSRF","date":"2021-04-16T07:24:58.532Z","categories_index":"","tags_index":"","author_index":"YenKoc"},{"id":"4b815d1a9fd6704c9aee8cee1d9828dc","title":"pikachu靶场-XSS","content":"xss（跨站脚本）概述一般xss可以分为如下几种常见的类型：\n\n反射性xss\n存储型xss\nDom型xss\n\n反射型xss(get)\n一个输入框，然后输入的时候，发现会出现，我输入什么，下面会直接显示出一句话加上我输入的地方，这里就容易出现xss漏洞，先弹窗，弹下\n\n并没有什么过滤，和转义，直接弹窗成功，hhh\n反射性xss（post）\n直接admin/123后，根据提示，是获取cookie，搜了下获取cookie的xss手法，直接打，然后发现还有一种可以将cookie传输到其他服务器的，nb\n存储型xss\n发现一个留言板，输入的会显示在页面上，而且是持久化的，存储在数据库里，大概逻辑就是我们输入，然后发请求，在数据库中，插入一条记录，并返回响应，刷新页面，将新的记录显示出来，，那么如果这里有xss，每次刷新也意味着都会执行一次\n\ndom型xss主要是构造dom树的语法，各种html标签，对我这种垃圾全栈还暂时不是问题\n\n发现我们输入的内容在dom里面，那我们就可以构造输入内容，闭合a标签，然后添加上我们的payload，注意那个函数，里面的单引号，这里得注意，\npayload：’&gt;\ndom xss-a\nxss 盲打\n盲打的意思是前端是没把内容返回出来的，但是后台管理员在查看后台消息时，如果没对xss进行过滤或者转义，那么管理员会看到xss的效果，上图是我提交后，登录后台看到的\nxss过滤观察下源码\n\n发现是过滤了&lt;开头，中间包含script这几个字符的，全部替换成空了，emm，那么全大写不就过了，，或者使用img标签，不也能过\nxss htmlchar这玩意会将我们输入的字符进行转义，\n\n但是并没有对我们的单引号进行转义，我们依然可以构造xss\n‘onclick=’alert(1). 这里第一个单引号是为了闭合href的双引号，第二个单引号，是为了后一个单引号\n\nxss href输出手动fuzz了下，发现单引号什么的，没用了，估计被过滤了，这里href还可以尝试伪协议进行绕过\n\nxss 的js输出在响应包发现我们的输入，赋值给了一个变量，那么我们可以通过构造出自己的js代码，这样也可以执行就像这样\n\n","slug":"pikachu靶场-XSS","date":"2021-04-16T01:34:32.000Z","categories_index":"渗透测试","tags_index":"渗透测试","author_index":"YenKoc"},{"id":"40d02940207fb31febc4e2293b7db511","title":"pikachu靶场-暴力破解","content":"1. 基于表单的暴力破解\n这玩意就是考bp的爆破模块的使用，这里有两个框需要爆破，那么bp的爆破模块的模式选择也得发生变化\n\n将我们需要所要爆破的地方，加$符号，然后攻击类型选择clusterbomb，这个是适用于多个参数进行爆破的，模式是笛卡尔积\n直接跑就完事了\n2. 验证码绕过on server这里加入了验证码，不过不用慌，通过手动测，发现每次输入相同的验证码，只会提示我们用户名或者密码问题，那么说明验证码是具有一定有效性的，大概率是服务器生成一个验证码后，用列表什么的存储起来了，然后提交从池中对比\n3. 验证码绕过on client发现是客户端js生成验证码，同时对比，如果错误就无法发送请求，那么根本就不用鸟这个前端校验，直接发送一个验证码正确的请求，bp上爆破，不走js的判断不就完事了\n4. token防爆破这个比较常见的，也就是每次我们发请求的时候，服务器会事先将服务端生成的token，通过响应，返回到我们浏览器的本地上，可能是cookie，或者是form表单的，隐藏域，这题属于后者，因为我通过搜索html的源码，发现了它，那么我们的思路可以是每次在发送玩玩错误请求后，将返回的html，通过正则表达式，取出token，作为下一次请求的参数，直接爬虫\nimport requests\nimport re\nurl&#x3D;&quot;http:&#x2F;&#x2F;192.168.8.125&#x2F;pikachu&#x2F;vul&#x2F;burteforce&#x2F;bf_token.php&quot;\ndatas&#x3D;&#123;\n    &quot;username&quot;:&quot;admin&quot;,\n    &quot;password&quot;:&quot;123&quot;,\n    &quot;token&quot;:1234124,\n    &quot;submit&quot;:&quot;Login&quot;\n&#125;\npattern&#x3D;re.compile(&quot;token\\&quot; value&#x3D;\\&quot;\\d*&quot;)\nresponse&#x3D;requests.post(url&#x3D;url,data&#x3D;datas)\nprint(pattern.findall(response.text)[0].split(&quot;&#x3D;\\&quot;&quot;)[1])\n#print(response.text)\n\n\n\n\n","slug":"pikachu靶场-暴力破解","date":"2021-04-15T13:31:57.000Z","categories_index":"渗透测试","tags_index":"渗透测试","author_index":"YenKoc"},{"id":"950945665e1fae17418166fca4d96e19","title":"pixel刷入官方镜像以及magisk","content":"前言吐槽下，本来是打算转edxposed，好家伙，tw卡刷，我这一直都是英文，根本安装不了，mmp，刷着刷着成砖头了。。所以就从官方镜像站里下载了官方镜像8.1，开始刷系统，并装入之前的magisk，因为现在magisk据珍惜表哥说对exposed兼容很差，我亲测也确实是这样的，写这篇文章记录下过程\n刷入官方镜像\n先去官方的镜像站下载\n链接: https://developers.google.cn/android/images#sailfish\n\n下载完是一个zip包，解压后，大概是这样的。\n\n\n这时候手机开始了，因为手机变砖头了，所以什么命令行进入fastboot就是狗屁，关机键加音量下键持续几秒，就进入fastboot模式，fastboot也叫做线刷模式，recovery是卡刷，也就是为什么我们喜欢把安装的东西push到sd卡下，然后刷入第三方recory的原因，扯远了233\n\n电脑打开终端，进入这个文件夹下，直接运行sh后缀的可执行文件，等待运行结束就刷完了，还是挺简单的\n\n\n\n\n　# 刷入magisk\n\n之前刷入系统了，已经可以正常开机了，先把usb调试打开，然后把magisk的zip包以及tw的zip包push到sdcard下或者/data/local/tmp下，我这里push到sdcard下就乱码，所以选择另一个了，都差不多的\n\n\n下载个临时的tw的img文件，之后刷入第三方的recovery，链接放下:https://dl.twrp.me/marlin/twrp-3.1.1-1-fastboot-marlin.img\nadb reboot bootloader      fastboot boot xxx/twrp-3.1.1-1-fastboot-marlin.img\n\n进入第三方recovery模式，就不用多说了，进入我们放zip包的目录下，点击安装，重新启动就完事了\n\n\n参考链接\nhttps://www.cnblogs.com/YenKoc/p/14236792.html\nhttps://sspai.com/post/43338\nhttps://blog.csdn.net/a940659387/article/details/109116460\nhttps://www.xzymoe.com/pixel-xl-unlockbl-root/\n\n","slug":"pixel刷入官方镜像以及magisk","date":"2021-04-13T17:32:59.000Z","categories_index":"刷机","tags_index":"刷机","author_index":"YenKoc"},{"id":"94996d3e08d5b007f0ef9d436bcc2ac8","title":"ARM汇编（转载,主要用来查询的)","content":"前言本来想自己写写，发现网上师傅们写的文章已经足够详细和优秀，就打算直接白嫖了，我是懒狗），毕竟汇编这东西还是得多看，然后平常就多查查，不然就像我之前连函数调用返回结果存储到r0，都回答错了，mmp，r0-r4优先存放函数参数的，r11其实就是x86中的ebp和x64的rbp，r13就是rsp和esp，r14存放返回地址，函数调用过程和x64大体差不多，剩下就是多查查2333\n查询链接\nhttps://www.anquanke.com/post/id/86383\nhttps://github.com/bin4re/Learn-and-Think-More/blob/master/Android%20Security/Arm%E6%B1%87%E7%BC%96/arm%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89.md\n\n","slug":"ARM汇编（转载-主要用来查询的","date":"2021-04-13T15:40:54.000Z","categories_index":"ARM汇编","tags_index":"","author_index":"YenKoc"},{"id":"490dee142b27f79f3072c0e4373d70d3","title":"关于某apicloud加密的app的逆向分析以及解密","content":"前言同事发现了一个html和js作为主要逻辑实现的app，好家伙，并且资源文件都被加密，打开就乱码，这波我也没见过，不过看我同事在逆，我因为好奇也去逆了下，好家伙，手机果然出问题了，frida hook不到关键函数，导致卡了很久，把我方向都搞乱了，最终在我同事和我做了对比变量，后排除了代码问题，锁定是手机问题，刷机之后，恢复正常），没有什么问题是刷机解决不了的。\n分析过程实际上直接面对这种，实际上很懵的，逆向如果基于开发的角度去逆向，会加快逆向的速度的，并更容易去定位到关键逻辑，这js在本地加密，那么有一种可能是发送请求，并在服务器上解密后，传回正常js然后解密，或者直接在本地就解密了，搜了下，发现这个框架叫apicloud，看了下开发流程，感觉没涉及到加解密，应该是apicloud自己的sdk，自己帮用户已经封装好了，既然已经知道了这个东西是什么，那么站在巨人的角度上，会不会更好，直接搜，发现看雪之前有大佬已经发了一篇apicloud逆向解密的文章，好奇，直接点进去\n\n发现了这句话，说明这个方法是我们要找的重点，直接jeb搜索\n\n其他的几个方法都跟了下，最终还是回调这个方法，再和之前那篇文章对比下，发现没啥差别的\n跟一下b.d()方法\n\n最终是调用了这个方法，其实就是返回文件后缀的，在调试过程中，愈发发现，很多时候要先从大逻辑开始逆，然后再深入这个大逻辑去逆向细节，也可能就是为什么我习惯f8，再f7，找到什么重要，什么根本就没必要跟。\n下一步跟this.b()方法\n\n重点是f.a()方法，在我使用frida去hook时候，发现返回值就是解密后的字节流，好家伙，那么这玩意加密的意义就不大了，\n代码没混淆，那么我只要hook这个方法，把字节流dump下来，不就完事了，不过这样有个问题就是那没加载的文件无法解密，所以找到核心的加密逻辑才行，继续跟进去\n\n核心加密跟进\n\n\n再继续\n\nnext\n\n发现跟进了native函数里面，ida拿出来，干它，发现是动态注册，找到结构体\n\n通过动态调试，发现核心加密函数\n\n\n就不跟进去了，重点是分析思路，静态分析，很明显的rc4加密，把keydump下来就可以正常解密文件了，我同事也写了一个解密本地文件的cpp脚本，我就不重复造轮子了，就分享下\n","slug":"关于某apicloud加密的app的逆向分析以及解密","date":"2021-04-11T16:00:43.000Z","categories_index":"app实战","tags_index":"a-iCloud","author_index":"YenKoc"},{"id":"7cc37a0c897d960438332a3e8c6a890d","title":"JNI helper插件使用","content":"1. 前言看直播的时候，肉丝表哥讲了r2的jni 插件，讲到了jni helper，evi大佬写的一款，自动识别jni类型的插件，兼容了好几款常见的反编译工具，之前也给了github星星的，但是具体怎么使用没去看，这里刚好讲到了，我也了解了下，最终效果还不错，膜\n2. 使用过程\n先从github上clone 一份项目下来\n\n\n然后这里进入JadxFindJNI目录下，make jni，或者直接下载编译好的jar包，因为需要这个jar包分析apk\n\n\n然后在命令行下使用jar包去分析apk包，得到一份json文件\n\n\nok之后，将jnihelper3.py(因为我这里使用的ida7.5所以，是3)，7.4以下使用普通.py ,复制进plugin目录下就好了，然后打开ida，打开plugin，选择之前生成的json文件，等待几秒，分析完成\n\n\n效果展示\n\n","slug":"JNI-helper插件使用","date":"2021-04-07T17:15:59.000Z","categories_index":"ida插件","tags_index":"ida插件","author_index":"YenKoc"},{"id":"b0f886f319692d13d933a2573c7d3ea9","title":"2021虎符ctf","content":"1.  code通过去观察代码逻辑，发现是先初始化出一个二维数组，然后开始取字符，不过每行中的列数为字符的ascii码值时，而取出来为下一行的行数，再填充回去，而v7那个循环，要想成功的条件，就是必须每次都找到下一行的行数，那么其实flag就是输入的前14位字符，直接提交\n2.  go发现没去掉符号表，直接去看main_main函数，然后发现有几个函数很可疑，通过动调调试发现先经过一个格式的检查，要满足前面5位flag{，后面3类4个0-9a-f，最后是12个字符的0-9a-f，再后面就是使用了两次的xtea加密，不过是魔改的，把常数替换之后就好，直接从网上copy一份xtea的解密脚本，魔改下，解就完事了\n\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nvoid encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;\nunsigned int i;\nuint32_t v0&#x3D;v[0], v1&#x3D;v[1], sum&#x3D;0, delta&#x3D;0x12345678;\nfor (i&#x3D;0; i &lt; num_rounds; i++) &#123;\nv0 +&#x3D; (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);\nsum +&#x3D; delta;\nv1 +&#x3D; (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);\n&#125;\nv[0]&#x3D;v0; v[1]&#x3D;v1;\n&#125;\n\nvoid decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;\nunsigned int i;\nuint32_t v0&#x3D;v[0], v1&#x3D;v[1], delta&#x3D;0x12345678, sum&#x3D;delta*num_rounds;\nfor (i&#x3D;0; i &lt; num_rounds; i++) &#123;\nv1 -&#x3D; (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);\nsum -&#x3D; delta;\nv0 -&#x3D; (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);\n&#125;\nv[0]&#x3D;v0; v[1]&#x3D;v1;\n&#125;\nint main()\n&#123;\nuint32_t v[2]&#x3D;&#123;0x0ec311f0,0x45c79af3&#125;;\n&#x2F;&#x2F;uint32_t v[2]&#x3D;&#123;0xedf5d910,0x542702cb&#125;;\nuint32_t const k[4]&#x3D;&#123;0x010203,0x04050607,0x08090a0b,0x0c0d0e0f&#125;;\nunsigned int r&#x3D;32;&#x2F;&#x2F;num_rounds锟斤拷锟斤拷取值为32\ndecipher(r, v, k);\nprintf(&quot;%x %x\\n&quot;,v[0],v[1]);\nreturn 0;\n&#125;\n\n3.  CrackMe发现两个输入，第一个输入是字符串，第二个是数字，然后发现有一个if，只和数字有关系，然后是int，考虑利用idapython进行爆破，或者和2st大哥一样使用inline hook进行爆破，坏坏的,，放下儒哥的爆破脚本，我写的个ida6的产物，mmp，其实这种idapython就是对inline hook用idapython的形式进行复述了一遍，主要是控制rip寄存器来改变程序流程，同时这种是动态执行的，之前一直想的是类似unicorn那种模拟执行的，emm，想歪了\nimport ida_dbg\nimport idc\n\n\nclass MyDbgHook(ida_dbg.DBG_Hooks):\n  def __init__(self):\n    ida_dbg.DBG_Hooks.__init__(self)  # important\n    self.guess &#x3D; 0\n    self.cin1_addr &#x3D; 0x140001658\n    self.cin2_addr &#x3D; 0x140001762\n    self.before_cin2 &#x3D; 0x14000175B\n    self.after_cin2 &#x3D; 0x140001768\n    self.chk_addr &#x3D; 0x14000184E\n\n  def log(self, msg):\n    print(&quot;&gt;&gt;&gt; %s&quot; % msg)\n\n  def dbg_bpt(self, tid, ea):\n    if ea &#x3D;&#x3D; self.cin1_addr:\n      self.reset()\n    elif ea &#x3D;&#x3D; self.cin2_addr:\n      ida_dbg.set_reg_val(&#39;rip&#39;, self.after_cin2)\n      rsp &#x3D; ida_dbg.get_reg_val(&#39;rsp&#39;)\n      idc.patch_qword(rsp+0x40, self.guess)\n      self.continue_process()\n    elif ea &#x3D;&#x3D; self.chk_addr:\n      ebx &#x3D; ida_dbg.get_reg_val(&#39;ebx&#39;)\n      eax &#x3D; ida_dbg.get_reg_val(&#39;eax&#39;)\n      if ebx !&#x3D; 80643:\n        self.guess +&#x3D; 12379\n        self.reset()\n      elif eax !&#x3D; 1442:\n        self.guess +&#x3D; 1\n        self.reset()\n      else:\n        self.log(str(self.guess))\n        self.continue_process()\n    return 0\n\n  def continue_process(self):\n    pass\n\n  def reset(self):\n    ida_dbg.set_reg_val(&#39;rip&#39;, self.before_cin2)\n    self.continue_process()\n\n  def dbg_process_exit(self, *args):\n    self.unhook()\n    self.log(&quot;unhooked&quot;)\n\n\n# Install the debug hook\ndebughook &#x3D; MyDbgHook()\ndebughook.hook()\nida_dbg.request_start_process()\nida_dbg.run_requests()\n\n\n跑出来一个数字99308，然后就是一个常规的rc4，直接解开就完事了\n","slug":"2021虎符ctf","date":"2021-04-07T14:43:37.000Z","categories_index":"writeup","tags_index":"reverse","author_index":"YenKoc"},{"id":"509e3543271104a33a26b59536e47f22","title":"看雪某数字壳测试题","content":"脱壳发现加了数字壳，直接用frida-的dexdump或者寒冰大佬的fart脱，就完事了，我这里还是比较喜欢objection搭配frida-dexdump插件的方式，比较方便，对这种没抽取的壳，也完全足够了，直接操作\n\n从内存中dump下了，三个dex，命令行输入grep -ril “MainActivity” * ，把主活动找到，发现是d0开头的dex\n\n代码分析将脱下来的dex，拖入jadx中，发现效果并不好，很多地方找不到，这也是为什么寒冰喜欢用gda来反编译吧，国产牛逼！\n\n\n不过发现一个问题，就是所有的方法，都变成native函数了，这不就是dex2c吗，好家伙，直接ida安排上，去找这个onclick方法\n\n发现这个onclick方法中字符串全被加密了，同时加密的函数就在.init段，可以看到一段的代码进行异或\n\n好家伙，这里有两个选择，要么静态的去写ida脚本，要么就是动态直接attach上去，毕竟这个段是在so载入内存中就会执行的，所以我们只要attach上去的话，字符串就是解密后的\n这里我没截图了，昨晚写的了，稍微描述下过程，开启androidserver，端口转发后，直接开始attach，attach上去后，不需要操作了，毕竟我们没在哪个so中下断点，我们只要在内存中找到我们想要的函数，根据so的基地址加上函数偏移，所以根本别慌，这里有个坑点就是搜出来有两个so文件，具体选哪个，得看，我们加上偏移后是否跳转到正确地址上。\n找到正确函数了，f5，然后改jnienv之后，发现就是典型的dex2c，在jni层调用java层的函数，沉思，我就在想那么直接hook，所有的getxxxxid，setxxxid不就完事，找了杨神之前的脚本，直接hook发现，奔溃了。。估计有反frida。。这里有个思想我觉得很好，就是从底层考虑起来，有时候直接去找哪里反调试，压力很大，逆向的去想，既然反调试奔溃了，那必然调用了一个奔溃函数，那么我们是不是可以通过找到奔溃函数的引用，一步一步的反跟上去呢。\n\n在两个so中，都搜了下，发现在libnative-lib.so下还真有，找到了反调试的地方\n\n那么我们第一步就需要把反调试给绕过了，这里是选择hook kill函数，毕竟kill是退出，如果hook为空，程序不就正常了。\n其实还有很多操作，比如hook strstr，getpid（）都是可以的\n直接上脚本\n\n\n&#x2F;*\nGetFieldID is at  0xe39b87c5 _ZN3art3JNI10GetFieldIDEP7_JNIEnvP7_jclassPKcS6_\nGetMethodID is at  0xe39a1a19 _ZN3art3JNI11GetMethodIDEP7_JNIEnvP7_jclassPKcS6_\nNewStringUTF is at  0xe39cff25 _ZN3art3JNI12NewStringUTFEP7_JNIEnvPKc\nRegisterNatives is at  0xe39e08fd _ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi\nGetStaticFieldID is at  0xe39c9635 _ZN3art3JNI16GetStaticFieldIDEP7_JNIEnvP7_jclassPKcS6_\nGetStaticMethodID is at  0xe39be0ed _ZN3art3JNI17GetStaticMethodIDEP7_JNIEnvP7_jclassPKcS6_\nGetStringUTFChars is at  0xe39d06e5 _ZN3art3JNI17GetStringUTFCharsEP7_JNIEnvP8_jstringPh\nFindClass is at  0xe399ae5d _ZN3art3JNI9FindClassEP7_JNIEnvPKc\n*&#x2F;  \nfunction hookkill()\n&#123;\n        var module&#x3D;Process.findModuleByName(&quot;libc.so&quot;);\n        var killAddr&#x3D;module.findExportByName(&quot;kill&quot;);\n        Interceptor.replace(killAddr,new NativeCallback(function(args0,args1)&#123;\n            console.log(&quot;Interceptor.attach myfirstjniJNI args:&quot;,args0,args1);\n            \n            return 11;\n    \n        &#125;,&quot;int&quot;,[&quot;pointer&quot;,&quot;int&quot;]));\n       \n&#125;\nfunction hook_libart() &#123;\n    var symbols &#x3D; Module.enumerateSymbolsSync(&quot;libart.so&quot;);\n    var addrGetStringUTFChars &#x3D; null;\n    var addrNewStringUTF &#x3D; null;\n    var addrFindClass &#x3D; null;\n    var addrGetMethodID &#x3D; null;\n    var addrGetStaticMethodID &#x3D; null;\n    var addrGetFieldID &#x3D; null;\n    var addrGetStaticFieldID &#x3D; null;\n    var addrRegisterNatives &#x3D; null;\n    for (var i &#x3D; 0; i &lt; symbols.length; i++) &#123;\n        var symbol &#x3D; symbols[i];\n        if (symbol.name.indexOf(&quot;art&quot;) &gt;&#x3D; 0 &amp;&amp;\n            symbol.name.indexOf(&quot;JNI&quot;) &gt;&#x3D; 0 &amp;&amp;\n            symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0\n        ) &#123;\n            if (symbol.name.indexOf(&quot;GetStringUTFChars&quot;) &gt;&#x3D; 0) &#123;\n                addrGetStringUTFChars &#x3D; symbol.address;\n                console.log(&quot;GetStringUTFChars is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;NewStringUTF&quot;) &gt;&#x3D; 0) &#123;\n                addrNewStringUTF &#x3D; symbol.address;\n                console.log(&quot;NewStringUTF is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;FindClass&quot;) &gt;&#x3D; 0) &#123;\n                addrFindClass &#x3D; symbol.address;\n                console.log(&quot;FindClass is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;GetMethodID&quot;) &gt;&#x3D; 0) &#123;\n                addrGetMethodID &#x3D; symbol.address;\n                console.log(&quot;GetMethodID is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;GetStaticMethodID&quot;) &gt;&#x3D; 0) &#123;\n                addrGetStaticMethodID &#x3D; symbol.address;\n                console.log(&quot;GetStaticMethodID is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;GetFieldID&quot;) &gt;&#x3D; 0) &#123;\n                addrGetFieldID &#x3D; symbol.address;\n                console.log(&quot;GetFieldID is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;GetStaticFieldID&quot;) &gt;&#x3D; 0) &#123;\n                addrGetStaticFieldID &#x3D; symbol.address;\n                console.log(&quot;GetStaticFieldID is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;&#x3D; 0) &#123;\n                addrRegisterNatives &#x3D; symbol.address;\n                console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);\n            &#125;\n        &#125;\n    &#125;\n\n    if (addrGetStringUTFChars !&#x3D; null) &#123;\n        Interceptor.attach(addrGetStringUTFChars, &#123;\n            onEnter: function (args) &#123;&#125;,\n            onLeave: function (retval) &#123;\n                if (retval !&#x3D; null) &#123;\n                    var bytes &#x3D; Memory.readCString(retval);\n                    console.log(&quot;[GetStringUTFChars] result:&quot; + bytes);\n                &#125;\n            &#125;\n        &#125;);\n    &#125;\n    if (addrNewStringUTF !&#x3D; null) &#123;\n        Interceptor.attach(addrNewStringUTF, &#123;\n            onEnter: function (args) &#123;\n                if (args[1] !&#x3D; null) &#123;\n                    var string &#x3D; Memory.readCString(args[1]);\n                    console.log(&quot;[NewStringUTF] bytes:&quot; + string);\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrFindClass !&#x3D; null) &#123;\n        Interceptor.attach(addrFindClass, &#123;\n            onEnter: function (args) &#123;\n                if (args[1] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[1]);\n                    console.log(&quot;[FindClass] name:&quot; + name);\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrGetMethodID !&#x3D; null) &#123;\n        Interceptor.attach(addrGetMethodID, &#123;\n            onEnter: function (args) &#123;\n                if (args[2] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[2]);\n                    if (args[3] !&#x3D; null) &#123;\n                        var sig &#x3D; Memory.readCString(args[3]);\n                        console.log(&quot;[GetMethodID] name:&quot; + name + &quot;, sig:&quot; + sig);\n                    &#125; else &#123;\n                        console.log(&quot;[GetMethodID] name:&quot; + name);\n                    &#125;\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrGetStaticMethodID !&#x3D; null) &#123;\n        Interceptor.attach(addrGetStaticMethodID, &#123;\n            onEnter: function (args) &#123;\n                if (args[2] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[2]);\n                    if (args[3] !&#x3D; null) &#123;\n                        var sig &#x3D; Memory.readCString(args[3]);\n                        console.log(&quot;[GetStaticMethodID] name:&quot; + name + &quot;, sig:&quot; + sig);\n                    &#125; else &#123;\n                        console.log(&quot;[GetStaticMethodID] name:&quot; + name);\n                    &#125;\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrGetFieldID !&#x3D; null) &#123;\n        Interceptor.attach(addrGetFieldID, &#123;\n            onEnter: function (args) &#123;\n                if (args[2] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[2]);\n                    if (args[3] !&#x3D; null) &#123;\n                        var sig &#x3D; Memory.readCString(args[3]);\n                        console.log(&quot;[GetFieldID] name:&quot; + name + &quot;, sig:&quot; + sig);\n                    &#125; else &#123;\n                        console.log(&quot;[GetFieldID] name:&quot; + name);\n                    &#125;\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrGetStaticFieldID !&#x3D; null) &#123;\n        Interceptor.attach(addrGetStaticFieldID, &#123;\n            onEnter: function (args) &#123;\n                if (args[2] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[2]);\n                    if (args[3] !&#x3D; null) &#123;\n                        var sig &#x3D; Memory.readCString(args[3]);\n                        console.log(&quot;[GetStaticFieldID] name:&quot; + name + &quot;, sig:&quot; + sig);\n                    &#125; else &#123;\n                        console.log(&quot;[GetStaticFieldID] name:&quot; + name);\n                    &#125;\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n\n    if (addrRegisterNatives !&#x3D; null) &#123;\n        Interceptor.attach(addrRegisterNatives, &#123;\n            onEnter: function (args) &#123;\n                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]);\n                var env &#x3D; args[0];\n                var java_class &#x3D; args[1];\n                var class_name &#x3D; Java.vm.tryGetEnv().getClassName(java_class);\n\n                var methods_ptr &#x3D; ptr(args[2]);\n\n                var method_count &#x3D; parseInt(args[3]);\n                for (var i &#x3D; 0; i &lt; method_count; i++) &#123;\n                    var name_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));\n                    var sig_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));\n                    var fnPtr_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));\n\n                    var name &#x3D; Memory.readCString(name_ptr);\n                    var sig &#x3D; Memory.readCString(sig_ptr);\n                    var find_module &#x3D; Process.findModuleByAddress(fnPtr_ptr);\n                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr, &quot;module_name:&quot;, find_module.name, &quot;module_base:&quot;, find_module.base, &quot;offset:&quot;, ptr(fnPtr_ptr).sub(find_module.base));\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n&#125;\nfunction main()\n&#123;\n    hookkill();\n    hook_libart();\n&#125;\nsetImmediate(main);\n\n\n\nhook效果，哦对，最好用attach方式，毕竟hook是libc的函数，肯定还有其他地方会hook到，为了避免太多无用信息，所以选择attach\nfrida -UF com.kanxue.test -l hook_art.js --no-pause\n\n\n\n\n逻辑就很清晰了，非常nice。\n","slug":"看雪某数字壳测试题","date":"2021-04-07T01:48:58.000Z","categories_index":"app实战","tags_index":"d2c","author_index":"YenKoc"},{"id":"da27febfe9a3ffe7e8fc2063f78d23df","title":"ida插件_traceNatives剖析","content":"前言前几天在肉丝朋友圈看到了龙哥的新作，一个名叫trace_native的ida插件项目，我出于好奇就想看看源码，发现好想原理也不难，不过提升了效率，还是很不错的\n源码剖析import os\nfrom idaapi import plugin_t\nfrom idaapi import PLUGIN_PROC\nfrom idaapi import PLGIN_OK\nimport ida_nalt\nimport idaapi\nimport idautils\nimport idc\nimport time\n\n# 获取so文件名和路径\ndef getSoPathAndName()\n&#123;\n  fullpath=ida_nalt.get_input_file_path()\n  #从完整路径中取出，文件路径和文件名\n  filepath,filename=os.path.split(fullpath)\n  return filepath,filename\n&#125;\n# 获取代码段的起始地址和结束地址\ndef getSegAddr()\n&#123;\n  finalStart=0xffffffff\n  finalEnd=0\n  for seg in idautils.Segments():\n  \tif (idc.get_segm_name(seg).lower())=='.text' or (idc.get_segm_name(seg).lower())=='text':\n  \t\ttempStart=idc.get_segm_start(seg)\n  \t\ttempEnd=idc.get_segm_end(seg)\n  \t\tif finalStart>tempStart:\n  \t\t\t\tfinalStart=tempStart\n  \t\tif finalEnd&lt;tempEnd:\n  \t\t\t\tfinalEnd=tempEnd\n\treturn finalStart,textEnd\n&#125;\nclass traceNatives(plugin_t):\n  flags=PLUGIN_PROC\n  comment=\"traceNatives\"\n  help=\"\"\n  wanted_name=\"traceNatives\"\n  wanted_hotkey=\"\"\n  \n  def init(self):\n    print(\"traceNatives(v0.1) plugin has been loaded\")\n    return PLUGIN_OK\n  def run(self,arg):\n    ea,ed=getSegAddr()\n    search_result=[]\n    for func in idautils.Functions(ea,ed):\n      try:\n        functionName=str(idaapi.ida_funcs.get_func_name(func))\n        if len(list(idautils.FuncItems(func)))>10:\n          #如果是thumb模式，地址+1\n          arm_or_thumb=idc.get_sreg(func,\"T\")\n          if arm_or_thumb:\n            func+=1\n          search_result.append(hex(func))\n      except:\n        pass\n    \n    so_path,so_name=getSoPathAndName()\n    search_result=[f\"-a '&#123;so_name&#125;!&#123;offset&#125;'\" for offset in search_result]\n    search_result=\" \".join(search_result)\n    \n    script_name=so_name.split(\".\")[0]+\"_\"+str(int(time.time()))+\".txt\"\n    save_path=os.path.join(so_path,script_name)\n    with open(save_path,\"w\",encoding=\"utf-8\") as f:\n      f.write(search_result)\n    print(\"使用方法如下:\")\n    print(f\"frida-trace -UF -O &#123;save_path&#125;\")\n  def term(self):\n    pass\n \t\ndef PLUGIN_ENTRY():\n  return traceNatives()\n     \n         \n\n实际上，就是通过idapython提供的api，先找出代码段的起始地址和结尾地址，然后对代码段中的函数进行遍历，判断是thumb模式还是arm模式，然后根据什么模式，对地址进行处理，搞完之后，将地址存入一个列表中，之后就进行字符串拼接，为后续使用frida-trace批量hook，作准备，我改了一个地方，感觉那个地方写的有点浪费内存。\n效果演示\n\n","slug":"ida插件-traceNatives剖析","date":"2021-03-29T13:01:59.000Z","categories_index":"ida插件","tags_index":"ida插件","author_index":"YenKoc"},{"id":"6c1a2f5fee044dc2bb2b3084d9a71810","title":"apkleaks的安装与使用","content":"前言上次开会的时候，听小帅有个可以从app中找接口的一个github项目，最近一直忙资产收集，所以没空看，今晚刚好有空，就clone了一份，并安装了，我习惯用kali了，所以这里安装也是以kali作为主力\n安装方法\nclone一份到本地\n\n进入目录后，输入pip3 install -r requirement.txt\n\n然后就可以使用python apkleads.py -f xx.apk\n\n发现提醒没有jadx的话，要选y，就会自动下载并安装，刚刚去github简介下看了，作者说是apkleaks基于jadx来反编译的\n\n\n\n下载后，就会发现同目录下，有一个jadx文件夹了，至此安装完成\n使用方法python apkleaks.py -f xxx.apk\n然后就开始执行扫描，会将ip和端口都提取出来，不过我实测还是不够准确的，如果只找接口的话，怎么会这么多其他的东西扫出来呢。。我也感觉奇怪，我建议在这句命令后-o xx.txt, 有些app还是挺大的，结果估计会很多，找个文件保存比较合适\n\n","slug":"apkleaks的安装与使用","date":"2021-03-26T18:23:40.000Z","categories_index":"","tags_index":"android工具使用","author_index":"YenKoc"},{"id":"c08d96c88052e6a8de3a34b6361e6767","title":"关于某so函数的加解密，以及自修复","content":"前言：意外在看雪上看到一道题，感觉挺不错的，就自己手动复现了下\n分析过程0x01 脱壳这里使用jeb打开后，发现qihoo的字样，明显是数字壳，这里没使用fart去脱，因为我手机目前没刷机，习惯dexdump，膜葫芦娃大哥2333，这里使用objection加载dexdump插件的方式，挺方便的，至于使用方法，见github，全记上面了，基本就是加载插件，然后plugin dexdump search，plugin dexdump dump，有可能会报错，最近肉丝也发了这个问题的解答，其实就是dexdump暴力搜索时，发现并不是真正的dex，所以才会崩溃，可以无视，脱完，再用jeb打开就行\n0x02 核心逻辑分析用jeb打开后，发现核心的判断函数是一个jni函数，拿出ida，将so打开，按照静态注册方法名搜索，发现并没有找到，说明是动态注册了，直接找JNI_Onload\n\n 这里我就不跟进去了，其实就是动态注册，不过呢，一些参数都被加密了，我ctrl+s看了下段，果然有个.init_array段，并且里面有操作的\n\n好家伙，全是异或，我尝试用idapython进行手动patch，真的麻烦，不过这些参数解密后还是很直观的，作用也挺大\n![image-20210327011018899](/Users/mac/Library/Application Support/typora-user-images/image-20210327011018899.png)\n这里算是patch的一部分了，还是挺不错的，接下来看那个动态注册的jni函数，\n![image-20210327011203804](/Users/mac/Library/Application Support/typora-user-images/image-20210327011203804.png)\n![image-20210327011225526](/Users/mac/Library/Application Support/typora-user-images/image-20210327011225526.png)\n发现什么呢，其实就是so函数级的加解密，如果对这个流程不熟悉和elf文件结构不熟，那么恭喜你，会一脸懵逼，我之前看小黄书的时候，还有印象，基本就是查看内存空间，然后通过字符串操作，取出so加载基地址，然后通过程序头表，找到dym段偏移，跟到实际的dym段，因为dym段其实就一个结构体数组，这个结构体包括了dymstr，dymsym.的相对虚拟地址，然后通过.hash段来计算函数名的hash，查找dymsym中函数结构体，取出函数偏移和大小\n\n然后就是对ooxx函数进行解密了，改变内存的可读，使其可写，改变完还是需要改变回去的\n![image-20210327012214500](/Users/mac/Library/Application Support/typora-user-images/image-20210327012214500.png)\n我们发现其实逻辑很简单，就是异或了一组数组，用frida直接dump下来，本地修复就完事了\nfunction main()\n&#123;\n    var soModule&#x3D;Process.findModuleByName(&quot;libnative-lib.so&quot;);\n    var keyadd&#x3D;ptr(Number(soModule.base)+0x1C180);\n    \n    \n    console.log(keyadd.readByteArray(464))\n    &#x2F;&#x2F; for(var i &#x3D;0;i&lt;486;i++)\n    &#x2F;&#x2F; &#123;\n    &#x2F;&#x2F;     keyadd&#x3D;keyadd+i;\n    &#x2F;&#x2F;     console.log(keyadd.;\n    &#x2F;&#x2F; &#125;\n&#125;\n\nsetImmediate(main);\n\n修复的脚本：\nimport mmap\n\nkey&#x3D;[0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,\n0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,\n0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,\n0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,\n0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,\n0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,\n0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,\n0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,\n0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,\n0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,\n0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,\n0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,\n0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,\n0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,\n0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,\n0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,\n0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,\n0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,\n0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,\n0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,\n0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,\n0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,\n0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,\n0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,\n0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,\n0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,\n0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,\n0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,\n0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf]\n\nfile_name&#x3D;&quot;libnative-lib.so&quot;\nprint(&quot;repair begin))&quot;)\nwith open(file_name,&quot;r+b&quot;) as file_descriptor:\n    memory_map&#x3D;mmap.mmap(file_descriptor.fileno(),0)\n    fuc_offest&#x3D;0x8dc5\n    fuc_size&#x3D;584\n    begin_funcc&#x3D;fuc_offest+59\n    end_funncc&#x3D;fuc_offest+fuc_size-61\n    size&#x3D;end_funncc-begin_funcc\n    for i in range(size):\n        orginal_byte&#x3D;int.from_bytes(memory_map[begin_funcc+i:begin_funcc+i+1],&quot;little&quot;)\n        new_byte&#x3D;orginal_byte^key[i]\n        memory_map[begin_funcc+i:begin_funcc+i+1]&#x3D;bytes([new_byte])\n        read_modified_byte &#x3D; int.from_bytes(memory_map[begin_funcc + i:begin_funcc + i + 1], &quot;little&quot;)\n        print(&quot;i: %d, original_byte: 0x%02x, modified_byte: 0x%02x, read_modified_byte: 0x%02x&quot;% (i, orginal_byte, new_byte,read_modified_byte))\n    memory_map.flush()\n    memory_map.close()\nprint(&quot;repair end!&quot;)\n\n\n\n修复效果：\n![image-20210327012502518](/Users/mac/Library/Application Support/typora-user-images/image-20210327012502518.png)\n","slug":"关于某so函数的加解密，以及自修复","date":"2021-03-26T16:52:56.000Z","categories_index":"","tags_index":"so层的加解密","author_index":"YenKoc"},{"id":"2deee02bdc0213108ea703030610df02","title":"吐槽","content":"没想到啊，兜兜转转还是来gitpages，弄博客了，其他平台真没github稳，刚好，GitHub的图床问题搜到个小工具解决了，hh，正式转战hexo，冲冲冲","slug":"expression","date":"2021-03-22T03:15:30.000Z","categories_index":"","tags_index":"日常杂谈","author_index":"YenKoc"}]