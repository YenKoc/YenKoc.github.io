[{"id":"490dee142b27f79f3072c0e4373d70d3","title":"关于某apicloud加密的app的逆向分析以及解密","content":"前言同事发现了一个html和js作为主要逻辑实现的app，好家伙，并且资源文件都被加密，打开就乱码，这波我也没见过，不过看我同事在逆，我因为好奇也去逆了下，好家伙，手机果然出问题了，frida hook不到关键函数，导致卡了很久，把我方向都搞乱了，最终在我同事和我做了对比变量，后排除了代码问题，锁定是手机问题，刷机之后，恢复正常），没有什么问题是刷机解决不了的。\n分析过程实际上直接面对这种，实际上很懵的，逆向如果基于开发的角度去逆向，会加快逆向的速度的，并更容易去定位到关键逻辑，这js在本地加密，那么有一种可能是发送请求，并在服务器上解密后，传回正常js然后解密，或者直接在本地就解密了，搜了下，发现这个框架叫apicloud，看了下开发流程，感觉没涉及到加解密，应该是apicloud自己的sdk，自己帮用户已经封装好了，既然已经知道了这个东西是什么，那么站在巨人的角度上，会不会更好，直接搜，发现看雪之前有大佬已经发了一篇apicloud逆向解密的文章，好奇，直接点进去\n\n发现了这句话，说明这个方法是我们要找的重点，直接jeb搜索\n\n其他的几个方法都跟了下，最终还是回调这个方法，再和之前那篇文章对比下，发现没啥差别的\n跟一下b.d()方法\n\n最终是调用了这个方法，其实就是返回文件后缀的，在调试过程中，愈发发现，很多时候要先从大逻辑开始逆，然后再深入这个大逻辑去逆向细节，也可能就是为什么我习惯f8，再f7，找到什么重要，什么根本就没必要跟。\n下一步跟this.b()方法\n\n重点是f.a()方法，在我使用frida去hook时候，发现返回值就是解密后的字节流，好家伙，那么这玩意加密的意义就不大了，\n代码没混淆，那么我只要hook这个方法，把字节流dump下来，不就完事了，不过这样有个问题就是那没加载的文件无法解密，所以找到核心的加密逻辑才行，继续跟进去\n\n核心加密跟进\n\n\n再继续\n\nnext\n\n发现跟进了native函数里面，ida拿出来，干它，发现是动态注册，找到结构体\n\n通过动态调试，发现核心加密函数\n\n\n就不跟进去了，重点是分析思路，静态分析，很明显的rc4加密，把keydump下来就可以正常解密文件了，我同事也写了一个解密本地文件的cpp脚本，我就不重复造轮子了，就分享下\n","slug":"关于某apicloud加密的app的逆向分析以及解密","date":"2021-04-11T16:00:43.000Z","categories_index":"app实战","tags_index":"a-iCloud","author_index":"YenKoc"},{"id":"5dc0bb0dd64b2cd7c658f0c50eb1781e","title":"MRCTF2021 MR_checkin wp","content":"前言这次北邮赛，没咋打，唉，忙别的事，太忙了，抽不出时间，但是瞄了一眼，有安卓题，打算摸鱼会，看看怎么回事hhh，毕竟几位出题人都是我大哥，过去签个到不过分吧2333，逻辑不复杂，还是挺友好的。\n分析过程jeb3打开，看看逻辑\n沉思，是kotlin写的，不过逻辑俺还是看的懂的，发现两个输入框，一个用户名一个密码，一个按钮，用来登录的，\n并给输入密码的控件设置了监听事件，还调用jni.test() 方法，先不管，先把大逻辑搞清楚\n跟进监听事件的类\n发现又给按钮设置了点击事件，并发现密码位数是39\n跟进点击事件的类\n发现就开始做校验了，用户名为MRCTF,密码前几个字符，是md5加密，然后对比，这玩意直接somd5解开，就完事了，重点是后半部分\n跟进check方法\n发现这段逻辑，先new了一个rand类对象，同时遍历输入密码的另一部分与StringsKt,first方法返回值做异或，我把代码都看了看，这个rand是个假的随机，实际上这个类仅仅是存了一个long数组，以及StringsKt.first这个方法，里面也是对两个数字进行一些移位操作，，这题我的思路就是直接hook那个first方法不就完事了吗。。不过这题会这么容易吗，肯定有诈啊，之前那个test方法不是白执行的\n跟进test方法\n跟进去so文件，习惯先看下j ni_onload方法，果然搞了一手，动态注册，那么静态注册就废掉了，看下结构体\n\n跟进去真正的执行函数、\n\n这里可以动调，但是有反调试，重打包什么的，patch太麻烦了，这里可以hook ptrace，也麻烦，直接hook art就完事了\n，发现就是执行了mainactivity的SetSrand函数，基本就是把之前new rand对象的两个参数改变了，好家伙\n但是我们思考下逻辑，你改了就改了，我们就是需要改过之后的rand对象是吧，所以根本不用操心，直接hook first函数，把返回值拿到不就完事了，不过这里需要把first函数返回值hook成我们设置的，否则无法执行，会直接退出的，把hook结果，拿到就行，放下frida脚本\nfunction hookMM()\n&#123;\n    Java.perform(function()&#123;\n        var tt=[95, 99, 104, 102, 103, 110, 55, 111, 88, 118, 97, 109, 98, 53, 108, 100, 94, 112, 108, 94, 77, 83, 66, 85, 71];\n        var ttt=[]\n        var i =0;\n        Java.use(\"kotlin.text.StringsKt___StringsKt\").first.overload('java.lang.CharSequence').implementation=function(arg1)\n        &#123;\n            console.log(\"arg1\",arg1);\n            ttt.join(arg1);\n            console.log(ttt);\n            var ret=this.first(arg1);\n           console.log(\"ret:\",ret)\n           return ret;\n            //return String.fromCharCode(tt[i++]);\n            \n        &#125;\n        \n        \n    &#125;)\n  \n    \n&#125;\nsetImmediate(hookMM);\n\n\n\n\n\n最后的expw&#x3D;&quot;MRCTF&#123;Andr01d_check1n_welc0me_to_MRCTF&#125;&quot;\nprint(len(w))\n\nc&#x3D;[110, 82, 89, 87, 86, 0x5F, 6, 94, 105, 71, 80, 92, 83, 4, 93, 85, 0x6F, 65, 93, 0x6F, 0x7C, 98, 0x73, 100, 0x76]\na&#x3D;[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;2&quot;,&quot;5&quot;,&quot;4&quot;,&quot;7&quot;,&quot;0&quot;,&quot;6&quot;,&quot;0&quot;,&quot;5&quot;,&quot;0&quot;,&quot;0&quot;,&quot;4&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;5&quot;,&quot;2&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]\nprint(len(a))\nprint(len(c))\nflag&#x3D;&quot;&quot;\nprint(chr(c[0]^1))\n\nfor i in range(len(c)):\n    print(chr(ord(a[i])^c[i]&amp;0xff),end&#x3D;&quot;&quot;)\n\n\n\n","slug":"MRCTF2021-MR-checkin-wp","date":"2021-04-11T14:42:07.000Z","categories_index":"writeup","tags_index":"reverse","author_index":"YenKoc"},{"id":"7cc37a0c897d960438332a3e8c6a890d","title":"JNI helper插件使用","content":"1. 前言看直播的时候，肉丝表哥讲了r2的jni 插件，讲到了jni helper，evi大佬写的一款，自动识别jni类型的插件，兼容了好几款常见的反编译工具，之前也给了github星星的，但是具体怎么使用没去看，这里刚好讲到了，我也了解了下，最终效果还不错，膜\n2. 使用过程\n先从github上clone 一份项目下来\n\n\n然后这里进入JadxFindJNI目录下，make jni，或者直接下载编译好的jar包，因为需要这个jar包分析apk\n\n\n然后在命令行下使用jar包去分析apk包，得到一份json文件\n\n\nok之后，将jnihelper3.py(因为我这里使用的ida7.5所以，是3)，7.4以下使用普通.py ,复制进plugin目录下就好了，然后打开ida，打开plugin，选择之前生成的json文件，等待几秒，分析完成\n\n\n效果展示\n\n","slug":"JNI-helper插件使用","date":"2021-04-07T17:15:59.000Z","categories_index":"ida插件","tags_index":"ida插件","author_index":"YenKoc"},{"id":"b0f886f319692d13d933a2573c7d3ea9","title":"2021虎符ctf","content":"1.  code通过去观察代码逻辑，发现是先初始化出一个二维数组，然后开始取字符，不过每行中的列数为字符的ascii码值时，而取出来为下一行的行数，再填充回去，而v7那个循环，要想成功的条件，就是必须每次都找到下一行的行数，那么其实flag就是输入的前14位字符，直接提交\n2.  go发现没去掉符号表，直接去看main_main函数，然后发现有几个函数很可疑，通过动调调试发现先经过一个格式的检查，要满足前面5位flag{，后面3类4个0-9a-f，最后是12个字符的0-9a-f，再后面就是使用了两次的xtea加密，不过是魔改的，把常数替换之后就好，直接从网上copy一份xtea的解密脚本，魔改下，解就完事了\n\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nvoid encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;\nunsigned int i;\nuint32_t v0&#x3D;v[0], v1&#x3D;v[1], sum&#x3D;0, delta&#x3D;0x12345678;\nfor (i&#x3D;0; i &lt; num_rounds; i++) &#123;\nv0 +&#x3D; (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);\nsum +&#x3D; delta;\nv1 +&#x3D; (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);\n&#125;\nv[0]&#x3D;v0; v[1]&#x3D;v1;\n&#125;\n\nvoid decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;\nunsigned int i;\nuint32_t v0&#x3D;v[0], v1&#x3D;v[1], delta&#x3D;0x12345678, sum&#x3D;delta*num_rounds;\nfor (i&#x3D;0; i &lt; num_rounds; i++) &#123;\nv1 -&#x3D; (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);\nsum -&#x3D; delta;\nv0 -&#x3D; (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);\n&#125;\nv[0]&#x3D;v0; v[1]&#x3D;v1;\n&#125;\nint main()\n&#123;\nuint32_t v[2]&#x3D;&#123;0x0ec311f0,0x45c79af3&#125;;\n&#x2F;&#x2F;uint32_t v[2]&#x3D;&#123;0xedf5d910,0x542702cb&#125;;\nuint32_t const k[4]&#x3D;&#123;0x010203,0x04050607,0x08090a0b,0x0c0d0e0f&#125;;\nunsigned int r&#x3D;32;&#x2F;&#x2F;num_rounds锟斤拷锟斤拷取值为32\ndecipher(r, v, k);\nprintf(&quot;%x %x\\n&quot;,v[0],v[1]);\nreturn 0;\n&#125;\n\n3.  CrackMe发现两个输入，第一个输入是字符串，第二个是数字，然后发现有一个if，只和数字有关系，然后是int，考虑利用idapython进行爆破，或者和2st大哥一样使用inline hook进行爆破，坏坏的,，放下儒哥的爆破脚本，我写的个ida6的产物，mmp，其实这种idapython就是对inline hook用idapython的形式进行复述了一遍，主要是控制rip寄存器来改变程序流程，同时这种是动态执行的，之前一直想的是类似unicorn那种模拟执行的，emm，想歪了\nimport ida_dbg\nimport idc\n\n\nclass MyDbgHook(ida_dbg.DBG_Hooks):\n  def __init__(self):\n    ida_dbg.DBG_Hooks.__init__(self)  # important\n    self.guess &#x3D; 0\n    self.cin1_addr &#x3D; 0x140001658\n    self.cin2_addr &#x3D; 0x140001762\n    self.before_cin2 &#x3D; 0x14000175B\n    self.after_cin2 &#x3D; 0x140001768\n    self.chk_addr &#x3D; 0x14000184E\n\n  def log(self, msg):\n    print(&quot;&gt;&gt;&gt; %s&quot; % msg)\n\n  def dbg_bpt(self, tid, ea):\n    if ea &#x3D;&#x3D; self.cin1_addr:\n      self.reset()\n    elif ea &#x3D;&#x3D; self.cin2_addr:\n      ida_dbg.set_reg_val(&#39;rip&#39;, self.after_cin2)\n      rsp &#x3D; ida_dbg.get_reg_val(&#39;rsp&#39;)\n      idc.patch_qword(rsp+0x40, self.guess)\n      self.continue_process()\n    elif ea &#x3D;&#x3D; self.chk_addr:\n      ebx &#x3D; ida_dbg.get_reg_val(&#39;ebx&#39;)\n      eax &#x3D; ida_dbg.get_reg_val(&#39;eax&#39;)\n      if ebx !&#x3D; 80643:\n        self.guess +&#x3D; 12379\n        self.reset()\n      elif eax !&#x3D; 1442:\n        self.guess +&#x3D; 1\n        self.reset()\n      else:\n        self.log(str(self.guess))\n        self.continue_process()\n    return 0\n\n  def continue_process(self):\n    pass\n\n  def reset(self):\n    ida_dbg.set_reg_val(&#39;rip&#39;, self.before_cin2)\n    self.continue_process()\n\n  def dbg_process_exit(self, *args):\n    self.unhook()\n    self.log(&quot;unhooked&quot;)\n\n\n# Install the debug hook\ndebughook &#x3D; MyDbgHook()\ndebughook.hook()\nida_dbg.request_start_process()\nida_dbg.run_requests()\n\n\n跑出来一个数字99308，然后就是一个常规的rc4，直接解开就完事了\n","slug":"2021虎符ctf","date":"2021-04-07T14:43:37.000Z","categories_index":"writeup","tags_index":"reverse","author_index":"YenKoc"},{"id":"509e3543271104a33a26b59536e47f22","title":"看雪某数字壳测试题","content":"脱壳发现加了数字壳，直接用frida-的dexdump或者寒冰大佬的fart脱，就完事了，我这里还是比较喜欢objection搭配frida-dexdump插件的方式，比较方便，对这种没抽取的壳，也完全足够了，直接操作\n\n从内存中dump下了，三个dex，命令行输入grep -ril “MainActivity” * ，把主活动找到，发现是d0开头的dex\n\n代码分析将脱下来的dex，拖入jadx中，发现效果并不好，很多地方找不到，这也是为什么寒冰喜欢用gda来反编译吧，国产牛逼！\n\n\n不过发现一个问题，就是所有的方法，都变成native函数了，这不就是dex2c吗，好家伙，直接ida安排上，去找这个onclick方法\n\n发现这个onclick方法中字符串全被加密了，同时加密的函数就在.init段，可以看到一段的代码进行异或\n\n好家伙，这里有两个选择，要么静态的去写ida脚本，要么就是动态直接attach上去，毕竟这个段是在so载入内存中就会执行的，所以我们只要attach上去的话，字符串就是解密后的\n这里我没截图了，昨晚写的了，稍微描述下过程，开启androidserver，端口转发后，直接开始attach，attach上去后，不需要操作了，毕竟我们没在哪个so中下断点，我们只要在内存中找到我们想要的函数，根据so的基地址加上函数偏移，所以根本别慌，这里有个坑点就是搜出来有两个so文件，具体选哪个，得看，我们加上偏移后是否跳转到正确地址上。\n找到正确函数了，f5，然后改jnienv之后，发现就是典型的dex2c，在jni层调用java层的函数，沉思，我就在想那么直接hook，所有的getxxxxid，setxxxid不就完事，找了杨神之前的脚本，直接hook发现，奔溃了。。估计有反frida。。这里有个思想我觉得很好，就是从底层考虑起来，有时候直接去找哪里反调试，压力很大，逆向的去想，既然反调试奔溃了，那必然调用了一个奔溃函数，那么我们是不是可以通过找到奔溃函数的引用，一步一步的反跟上去呢。\n\n在两个so中，都搜了下，发现在libnative-lib.so下还真有，找到了反调试的地方\n\n那么我们第一步就需要把反调试给绕过了，这里是选择hook kill函数，毕竟kill是退出，如果hook为空，程序不就正常了。\n其实还有很多操作，比如hook strstr，getpid（）都是可以的\n直接上脚本\n\n\n&#x2F;*\nGetFieldID is at  0xe39b87c5 _ZN3art3JNI10GetFieldIDEP7_JNIEnvP7_jclassPKcS6_\nGetMethodID is at  0xe39a1a19 _ZN3art3JNI11GetMethodIDEP7_JNIEnvP7_jclassPKcS6_\nNewStringUTF is at  0xe39cff25 _ZN3art3JNI12NewStringUTFEP7_JNIEnvPKc\nRegisterNatives is at  0xe39e08fd _ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi\nGetStaticFieldID is at  0xe39c9635 _ZN3art3JNI16GetStaticFieldIDEP7_JNIEnvP7_jclassPKcS6_\nGetStaticMethodID is at  0xe39be0ed _ZN3art3JNI17GetStaticMethodIDEP7_JNIEnvP7_jclassPKcS6_\nGetStringUTFChars is at  0xe39d06e5 _ZN3art3JNI17GetStringUTFCharsEP7_JNIEnvP8_jstringPh\nFindClass is at  0xe399ae5d _ZN3art3JNI9FindClassEP7_JNIEnvPKc\n*&#x2F;  \nfunction hookkill()\n&#123;\n        var module&#x3D;Process.findModuleByName(&quot;libc.so&quot;);\n        var killAddr&#x3D;module.findExportByName(&quot;kill&quot;);\n        Interceptor.replace(killAddr,new NativeCallback(function(args0,args1)&#123;\n            console.log(&quot;Interceptor.attach myfirstjniJNI args:&quot;,args0,args1);\n            \n            return 11;\n    \n        &#125;,&quot;int&quot;,[&quot;pointer&quot;,&quot;int&quot;]));\n       \n&#125;\nfunction hook_libart() &#123;\n    var symbols &#x3D; Module.enumerateSymbolsSync(&quot;libart.so&quot;);\n    var addrGetStringUTFChars &#x3D; null;\n    var addrNewStringUTF &#x3D; null;\n    var addrFindClass &#x3D; null;\n    var addrGetMethodID &#x3D; null;\n    var addrGetStaticMethodID &#x3D; null;\n    var addrGetFieldID &#x3D; null;\n    var addrGetStaticFieldID &#x3D; null;\n    var addrRegisterNatives &#x3D; null;\n    for (var i &#x3D; 0; i &lt; symbols.length; i++) &#123;\n        var symbol &#x3D; symbols[i];\n        if (symbol.name.indexOf(&quot;art&quot;) &gt;&#x3D; 0 &amp;&amp;\n            symbol.name.indexOf(&quot;JNI&quot;) &gt;&#x3D; 0 &amp;&amp;\n            symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0\n        ) &#123;\n            if (symbol.name.indexOf(&quot;GetStringUTFChars&quot;) &gt;&#x3D; 0) &#123;\n                addrGetStringUTFChars &#x3D; symbol.address;\n                console.log(&quot;GetStringUTFChars is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;NewStringUTF&quot;) &gt;&#x3D; 0) &#123;\n                addrNewStringUTF &#x3D; symbol.address;\n                console.log(&quot;NewStringUTF is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;FindClass&quot;) &gt;&#x3D; 0) &#123;\n                addrFindClass &#x3D; symbol.address;\n                console.log(&quot;FindClass is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;GetMethodID&quot;) &gt;&#x3D; 0) &#123;\n                addrGetMethodID &#x3D; symbol.address;\n                console.log(&quot;GetMethodID is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;GetStaticMethodID&quot;) &gt;&#x3D; 0) &#123;\n                addrGetStaticMethodID &#x3D; symbol.address;\n                console.log(&quot;GetStaticMethodID is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;GetFieldID&quot;) &gt;&#x3D; 0) &#123;\n                addrGetFieldID &#x3D; symbol.address;\n                console.log(&quot;GetFieldID is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;GetStaticFieldID&quot;) &gt;&#x3D; 0) &#123;\n                addrGetStaticFieldID &#x3D; symbol.address;\n                console.log(&quot;GetStaticFieldID is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;&#x3D; 0) &#123;\n                addrRegisterNatives &#x3D; symbol.address;\n                console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);\n            &#125;\n        &#125;\n    &#125;\n\n    if (addrGetStringUTFChars !&#x3D; null) &#123;\n        Interceptor.attach(addrGetStringUTFChars, &#123;\n            onEnter: function (args) &#123;&#125;,\n            onLeave: function (retval) &#123;\n                if (retval !&#x3D; null) &#123;\n                    var bytes &#x3D; Memory.readCString(retval);\n                    console.log(&quot;[GetStringUTFChars] result:&quot; + bytes);\n                &#125;\n            &#125;\n        &#125;);\n    &#125;\n    if (addrNewStringUTF !&#x3D; null) &#123;\n        Interceptor.attach(addrNewStringUTF, &#123;\n            onEnter: function (args) &#123;\n                if (args[1] !&#x3D; null) &#123;\n                    var string &#x3D; Memory.readCString(args[1]);\n                    console.log(&quot;[NewStringUTF] bytes:&quot; + string);\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrFindClass !&#x3D; null) &#123;\n        Interceptor.attach(addrFindClass, &#123;\n            onEnter: function (args) &#123;\n                if (args[1] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[1]);\n                    console.log(&quot;[FindClass] name:&quot; + name);\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrGetMethodID !&#x3D; null) &#123;\n        Interceptor.attach(addrGetMethodID, &#123;\n            onEnter: function (args) &#123;\n                if (args[2] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[2]);\n                    if (args[3] !&#x3D; null) &#123;\n                        var sig &#x3D; Memory.readCString(args[3]);\n                        console.log(&quot;[GetMethodID] name:&quot; + name + &quot;, sig:&quot; + sig);\n                    &#125; else &#123;\n                        console.log(&quot;[GetMethodID] name:&quot; + name);\n                    &#125;\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrGetStaticMethodID !&#x3D; null) &#123;\n        Interceptor.attach(addrGetStaticMethodID, &#123;\n            onEnter: function (args) &#123;\n                if (args[2] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[2]);\n                    if (args[3] !&#x3D; null) &#123;\n                        var sig &#x3D; Memory.readCString(args[3]);\n                        console.log(&quot;[GetStaticMethodID] name:&quot; + name + &quot;, sig:&quot; + sig);\n                    &#125; else &#123;\n                        console.log(&quot;[GetStaticMethodID] name:&quot; + name);\n                    &#125;\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrGetFieldID !&#x3D; null) &#123;\n        Interceptor.attach(addrGetFieldID, &#123;\n            onEnter: function (args) &#123;\n                if (args[2] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[2]);\n                    if (args[3] !&#x3D; null) &#123;\n                        var sig &#x3D; Memory.readCString(args[3]);\n                        console.log(&quot;[GetFieldID] name:&quot; + name + &quot;, sig:&quot; + sig);\n                    &#125; else &#123;\n                        console.log(&quot;[GetFieldID] name:&quot; + name);\n                    &#125;\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrGetStaticFieldID !&#x3D; null) &#123;\n        Interceptor.attach(addrGetStaticFieldID, &#123;\n            onEnter: function (args) &#123;\n                if (args[2] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[2]);\n                    if (args[3] !&#x3D; null) &#123;\n                        var sig &#x3D; Memory.readCString(args[3]);\n                        console.log(&quot;[GetStaticFieldID] name:&quot; + name + &quot;, sig:&quot; + sig);\n                    &#125; else &#123;\n                        console.log(&quot;[GetStaticFieldID] name:&quot; + name);\n                    &#125;\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n\n    if (addrRegisterNatives !&#x3D; null) &#123;\n        Interceptor.attach(addrRegisterNatives, &#123;\n            onEnter: function (args) &#123;\n                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]);\n                var env &#x3D; args[0];\n                var java_class &#x3D; args[1];\n                var class_name &#x3D; Java.vm.tryGetEnv().getClassName(java_class);\n\n                var methods_ptr &#x3D; ptr(args[2]);\n\n                var method_count &#x3D; parseInt(args[3]);\n                for (var i &#x3D; 0; i &lt; method_count; i++) &#123;\n                    var name_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));\n                    var sig_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));\n                    var fnPtr_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));\n\n                    var name &#x3D; Memory.readCString(name_ptr);\n                    var sig &#x3D; Memory.readCString(sig_ptr);\n                    var find_module &#x3D; Process.findModuleByAddress(fnPtr_ptr);\n                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr, &quot;module_name:&quot;, find_module.name, &quot;module_base:&quot;, find_module.base, &quot;offset:&quot;, ptr(fnPtr_ptr).sub(find_module.base));\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n&#125;\nfunction main()\n&#123;\n    hookkill();\n    hook_libart();\n&#125;\nsetImmediate(main);\n\n\n\nhook效果，哦对，最好用attach方式，毕竟hook是libc的函数，肯定还有其他地方会hook到，为了避免太多无用信息，所以选择attach\nfrida -UF com.kanxue.test -l hook_art.js --no-pause\n\n\n\n\n逻辑就很清晰了，非常nice。\n","slug":"看雪某数字壳测试题","date":"2021-04-07T01:48:58.000Z","categories_index":"app实战","tags_index":"d2c","author_index":"YenKoc"},{"id":"da27febfe9a3ffe7e8fc2063f78d23df","title":"ida插件_traceNatives剖析","content":"前言前几天在肉丝朋友圈看到了龙哥的新作，一个名叫trace_native的ida插件项目，我出于好奇就想看看源码，发现好想原理也不难，不过提升了效率，还是很不错的\n源码剖析import os\nfrom idaapi import plugin_t\nfrom idaapi import PLUGIN_PROC\nfrom idaapi import PLGIN_OK\nimport ida_nalt\nimport idaapi\nimport idautils\nimport idc\nimport time\n\n# 获取so文件名和路径\ndef getSoPathAndName()\n&#123;\n  fullpath=ida_nalt.get_input_file_path()\n  #从完整路径中取出，文件路径和文件名\n  filepath,filename=os.path.split(fullpath)\n  return filepath,filename\n&#125;\n# 获取代码段的起始地址和结束地址\ndef getSegAddr()\n&#123;\n  finalStart=0xffffffff\n  finalEnd=0\n  for seg in idautils.Segments():\n  \tif (idc.get_segm_name(seg).lower())=='.text' or (idc.get_segm_name(seg).lower())=='text':\n  \t\ttempStart=idc.get_segm_start(seg)\n  \t\ttempEnd=idc.get_segm_end(seg)\n  \t\tif finalStart>tempStart:\n  \t\t\t\tfinalStart=tempStart\n  \t\tif finalEnd&lt;tempEnd:\n  \t\t\t\tfinalEnd=tempEnd\n\treturn finalStart,textEnd\n&#125;\nclass traceNatives(plugin_t):\n  flags=PLUGIN_PROC\n  comment=\"traceNatives\"\n  help=\"\"\n  wanted_name=\"traceNatives\"\n  wanted_hotkey=\"\"\n  \n  def init(self):\n    print(\"traceNatives(v0.1) plugin has been loaded\")\n    return PLUGIN_OK\n  def run(self,arg):\n    ea,ed=getSegAddr()\n    search_result=[]\n    for func in idautils.Functions(ea,ed):\n      try:\n        functionName=str(idaapi.ida_funcs.get_func_name(func))\n        if len(list(idautils.FuncItems(func)))>10:\n          #如果是thumb模式，地址+1\n          arm_or_thumb=idc.get_sreg(func,\"T\")\n          if arm_or_thumb:\n            func+=1\n          search_result.append(hex(func))\n      except:\n        pass\n    \n    so_path,so_name=getSoPathAndName()\n    search_result=[f\"-a '&#123;so_name&#125;!&#123;offset&#125;'\" for offset in search_result]\n    search_result=\" \".join(search_result)\n    \n    script_name=so_name.split(\".\")[0]+\"_\"+str(int(time.time()))+\".txt\"\n    save_path=os.path.join(so_path,script_name)\n    with open(save_path,\"w\",encoding=\"utf-8\") as f:\n      f.write(search_result)\n    print(\"使用方法如下:\")\n    print(f\"frida-trace -UF -O &#123;save_path&#125;\")\n  def term(self):\n    pass\n \t\ndef PLUGIN_ENTRY():\n  return traceNatives()\n     \n         \n\n实际上，就是通过idapython提供的api，先找出代码段的起始地址和结尾地址，然后对代码段中的函数进行遍历，判断是thumb模式还是arm模式，然后根据什么模式，对地址进行处理，搞完之后，将地址存入一个列表中，之后就进行字符串拼接，为后续使用frida-trace批量hook，作准备，我改了一个地方，感觉那个地方写的有点浪费内存。\n效果演示\n\n","slug":"ida插件-traceNatives剖析","date":"2021-03-29T13:01:59.000Z","categories_index":"ida插件","tags_index":"ida插件","author_index":"YenKoc"},{"id":"6c1a2f5fee044dc2bb2b3084d9a71810","title":"apkleaks的安装与使用","content":"前言上次开会的时候，听小帅有个可以从app中找接口的一个github项目，最近一直忙资产收集，所以没空看，今晚刚好有空，就clone了一份，并安装了，我习惯用kali了，所以这里安装也是以kali作为主力\n安装方法\nclone一份到本地\n\n进入目录后，输入pip3 install -r requirement.txt\n\n然后就可以使用python apkleads.py -f xx.apk\n\n发现提醒没有jadx的话，要选y，就会自动下载并安装，刚刚去github简介下看了，作者说是apkleaks基于jadx来反编译的\n\n\n\n下载后，就会发现同目录下，有一个jadx文件夹了，至此安装完成\n使用方法python apkleaks.py -f xxx.apk\n然后就开始执行扫描，会将ip和端口都提取出来，不过我实测还是不够准确的，如果只找接口的话，怎么会这么多其他的东西扫出来呢。。我也感觉奇怪，我建议在这句命令后-o xx.txt, 有些app还是挺大的，结果估计会很多，找个文件保存比较合适\n\n","slug":"apkleaks的安装与使用","date":"2021-03-26T18:23:40.000Z","categories_index":"","tags_index":"android工具使用","author_index":"YenKoc"},{"id":"c08d96c88052e6a8de3a34b6361e6767","title":"关于某so函数的加解密，以及自修复","content":"前言：意外在看雪上看到一道题，感觉挺不错的，就自己手动复现了下\n分析过程0x01 脱壳这里使用jeb打开后，发现qihoo的字样，明显是数字壳，这里没使用fart去脱，因为我手机目前没刷机，习惯dexdump，膜葫芦娃大哥2333，这里使用objection加载dexdump插件的方式，挺方便的，至于使用方法，见github，全记上面了，基本就是加载插件，然后plugin dexdump search，plugin dexdump dump，有可能会报错，最近肉丝也发了这个问题的解答，其实就是dexdump暴力搜索时，发现并不是真正的dex，所以才会崩溃，可以无视，脱完，再用jeb打开就行\n0x02 核心逻辑分析用jeb打开后，发现核心的判断函数是一个jni函数，拿出ida，将so打开，按照静态注册方法名搜索，发现并没有找到，说明是动态注册了，直接找JNI_Onload\n\n 这里我就不跟进去了，其实就是动态注册，不过呢，一些参数都被加密了，我ctrl+s看了下段，果然有个.init_array段，并且里面有操作的\n\n好家伙，全是异或，我尝试用idapython进行手动patch，真的麻烦，不过这些参数解密后还是很直观的，作用也挺大\n![image-20210327011018899](/Users/mac/Library/Application Support/typora-user-images/image-20210327011018899.png)\n这里算是patch的一部分了，还是挺不错的，接下来看那个动态注册的jni函数，\n![image-20210327011203804](/Users/mac/Library/Application Support/typora-user-images/image-20210327011203804.png)\n![image-20210327011225526](/Users/mac/Library/Application Support/typora-user-images/image-20210327011225526.png)\n发现什么呢，其实就是so函数级的加解密，如果对这个流程不熟悉和elf文件结构不熟，那么恭喜你，会一脸懵逼，我之前看小黄书的时候，还有印象，基本就是查看内存空间，然后通过字符串操作，取出so加载基地址，然后通过程序头表，找到dym段偏移，跟到实际的dym段，因为dym段其实就一个结构体数组，这个结构体包括了dymstr，dymsym.的相对虚拟地址，然后通过.hash段来计算函数名的hash，查找dymsym中函数结构体，取出函数偏移和大小\n\n然后就是对ooxx函数进行解密了，改变内存的可读，使其可写，改变完还是需要改变回去的\n![image-20210327012214500](/Users/mac/Library/Application Support/typora-user-images/image-20210327012214500.png)\n我们发现其实逻辑很简单，就是异或了一组数组，用frida直接dump下来，本地修复就完事了\nfunction main()\n&#123;\n    var soModule&#x3D;Process.findModuleByName(&quot;libnative-lib.so&quot;);\n    var keyadd&#x3D;ptr(Number(soModule.base)+0x1C180);\n    \n    \n    console.log(keyadd.readByteArray(464))\n    &#x2F;&#x2F; for(var i &#x3D;0;i&lt;486;i++)\n    &#x2F;&#x2F; &#123;\n    &#x2F;&#x2F;     keyadd&#x3D;keyadd+i;\n    &#x2F;&#x2F;     console.log(keyadd.;\n    &#x2F;&#x2F; &#125;\n&#125;\n\nsetImmediate(main);\n\n修复的脚本：\nimport mmap\n\nkey&#x3D;[0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,\n0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,\n0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,\n0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,\n0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,\n0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,\n0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,\n0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,\n0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,\n0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,\n0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,\n0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,\n0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,\n0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,\n0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,\n0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,\n0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,\n0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,\n0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,\n0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,\n0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,\n0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,\n0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,\n0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,\n0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,\n0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,\n0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,\n0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,\n0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf]\n\nfile_name&#x3D;&quot;libnative-lib.so&quot;\nprint(&quot;repair begin))&quot;)\nwith open(file_name,&quot;r+b&quot;) as file_descriptor:\n    memory_map&#x3D;mmap.mmap(file_descriptor.fileno(),0)\n    fuc_offest&#x3D;0x8dc5\n    fuc_size&#x3D;584\n    begin_funcc&#x3D;fuc_offest+59\n    end_funncc&#x3D;fuc_offest+fuc_size-61\n    size&#x3D;end_funncc-begin_funcc\n    for i in range(size):\n        orginal_byte&#x3D;int.from_bytes(memory_map[begin_funcc+i:begin_funcc+i+1],&quot;little&quot;)\n        new_byte&#x3D;orginal_byte^key[i]\n        memory_map[begin_funcc+i:begin_funcc+i+1]&#x3D;bytes([new_byte])\n        read_modified_byte &#x3D; int.from_bytes(memory_map[begin_funcc + i:begin_funcc + i + 1], &quot;little&quot;)\n        print(&quot;i: %d, original_byte: 0x%02x, modified_byte: 0x%02x, read_modified_byte: 0x%02x&quot;% (i, orginal_byte, new_byte,read_modified_byte))\n    memory_map.flush()\n    memory_map.close()\nprint(&quot;repair end!&quot;)\n\n\n\n修复效果：\n![image-20210327012502518](/Users/mac/Library/Application Support/typora-user-images/image-20210327012502518.png)\n","slug":"关于某so函数的加解密，以及自修复","date":"2021-03-26T16:52:56.000Z","categories_index":"","tags_index":"so层的加解密","author_index":"YenKoc"},{"id":"2deee02bdc0213108ea703030610df02","title":"吐槽","content":"没想到啊，兜兜转转还是来gitpages，弄博客了，其他平台真没github稳，刚好，GitHub的图床问题搜到个小工具解决了，hh，正式转战hexo，冲冲冲","slug":"expression","date":"2021-03-22T03:15:30.000Z","categories_index":"","tags_index":"日常杂谈","author_index":"YenKoc"}]