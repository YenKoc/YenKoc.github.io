[{"id":"509e3543271104a33a26b59536e47f22","title":"看雪某数字壳测试题","content":"脱壳发现加了数字壳，直接用frida-的dexdump或者寒冰大佬的fart脱，就完事了，我这里还是比较喜欢objection搭配frida-dexdump插件的方式，比较方便，对这种没抽取的壳，也完全足够了，直接操作\n\n从内存中dump下了，三个dex，命令行输入grep -ril “MainActivity” * ，把主活动找到，发现是d0开头的dex\n\n代码分析将脱下来的dex，拖入jadx中，发现效果并不好，很多地方找不到，这也是为什么寒冰喜欢用gda来反编译吧，国产牛逼！\n\n\n不过发现一个问题，就是所有的方法，都变成native函数了，这不就是dex2c吗，好家伙，直接ida安排上，去找这个onclick方法\n\n发现这个onclick方法中字符串全被加密了，同时加密的函数就在.init段，可以看到一段的代码进行异或\n\n好家伙，这里有两个选择，要么静态的去写ida脚本，要么就是动态直接attach上去，毕竟这个段是在so载入内存中就会执行的，所以我们只要attach上去的话，字符串就是解密后的\n这里我没截图了，昨晚写的了，稍微描述下过程，开启androidserver，端口转发后，直接开始attach，attach上去后，不需要操作了，毕竟我们没在哪个so中下断点，我们只要在内存中找到我们想要的函数，根据so的基地址加上函数偏移，所以根本别慌，这里有个坑点就是搜出来有两个so文件，具体选哪个，得看，我们加上偏移后是否跳转到正确地址上。\n找到正确函数了，f5，然后改jnienv之后，发现就是典型的dex2c，在jni层调用java层的函数，沉思，我就在想那么直接hook，所有的getxxxxid，setxxxid不就完事，找了杨神之前的脚本，直接hook发现，奔溃了。。估计有反frida。。这里有个思想我觉得很好，就是从底层考虑起来，有时候直接去找哪里反调试，压力很大，逆向的去想，既然反调试奔溃了，那必然调用了一个奔溃函数，那么我们是不是可以通过找到奔溃函数的引用，一步一步的反跟上去呢。\n\n在两个so中，都搜了下，发现在libnative-lib.so下还真有，找到了反调试的地方\n\n那么我们第一步就需要把反调试给绕过了，这里是选择hook kill函数，毕竟kill是退出，如果hook为空，程序不就正常了。\n其实还有很多操作，比如hook strstr，getpid（）都是可以的\n直接上脚本\n\n\n&#x2F;*\nGetFieldID is at  0xe39b87c5 _ZN3art3JNI10GetFieldIDEP7_JNIEnvP7_jclassPKcS6_\nGetMethodID is at  0xe39a1a19 _ZN3art3JNI11GetMethodIDEP7_JNIEnvP7_jclassPKcS6_\nNewStringUTF is at  0xe39cff25 _ZN3art3JNI12NewStringUTFEP7_JNIEnvPKc\nRegisterNatives is at  0xe39e08fd _ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi\nGetStaticFieldID is at  0xe39c9635 _ZN3art3JNI16GetStaticFieldIDEP7_JNIEnvP7_jclassPKcS6_\nGetStaticMethodID is at  0xe39be0ed _ZN3art3JNI17GetStaticMethodIDEP7_JNIEnvP7_jclassPKcS6_\nGetStringUTFChars is at  0xe39d06e5 _ZN3art3JNI17GetStringUTFCharsEP7_JNIEnvP8_jstringPh\nFindClass is at  0xe399ae5d _ZN3art3JNI9FindClassEP7_JNIEnvPKc\n*&#x2F;  \nfunction hookkill()\n&#123;\n        var module&#x3D;Process.findModuleByName(&quot;libc.so&quot;);\n        var killAddr&#x3D;module.findExportByName(&quot;kill&quot;);\n        Interceptor.replace(killAddr,new NativeCallback(function(args0,args1)&#123;\n            console.log(&quot;Interceptor.attach myfirstjniJNI args:&quot;,args0,args1);\n            \n            return 11;\n    \n        &#125;,&quot;int&quot;,[&quot;pointer&quot;,&quot;int&quot;]));\n       \n&#125;\nfunction hook_libart() &#123;\n    var symbols &#x3D; Module.enumerateSymbolsSync(&quot;libart.so&quot;);\n    var addrGetStringUTFChars &#x3D; null;\n    var addrNewStringUTF &#x3D; null;\n    var addrFindClass &#x3D; null;\n    var addrGetMethodID &#x3D; null;\n    var addrGetStaticMethodID &#x3D; null;\n    var addrGetFieldID &#x3D; null;\n    var addrGetStaticFieldID &#x3D; null;\n    var addrRegisterNatives &#x3D; null;\n    for (var i &#x3D; 0; i &lt; symbols.length; i++) &#123;\n        var symbol &#x3D; symbols[i];\n        if (symbol.name.indexOf(&quot;art&quot;) &gt;&#x3D; 0 &amp;&amp;\n            symbol.name.indexOf(&quot;JNI&quot;) &gt;&#x3D; 0 &amp;&amp;\n            symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0\n        ) &#123;\n            if (symbol.name.indexOf(&quot;GetStringUTFChars&quot;) &gt;&#x3D; 0) &#123;\n                addrGetStringUTFChars &#x3D; symbol.address;\n                console.log(&quot;GetStringUTFChars is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;NewStringUTF&quot;) &gt;&#x3D; 0) &#123;\n                addrNewStringUTF &#x3D; symbol.address;\n                console.log(&quot;NewStringUTF is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;FindClass&quot;) &gt;&#x3D; 0) &#123;\n                addrFindClass &#x3D; symbol.address;\n                console.log(&quot;FindClass is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;GetMethodID&quot;) &gt;&#x3D; 0) &#123;\n                addrGetMethodID &#x3D; symbol.address;\n                console.log(&quot;GetMethodID is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;GetStaticMethodID&quot;) &gt;&#x3D; 0) &#123;\n                addrGetStaticMethodID &#x3D; symbol.address;\n                console.log(&quot;GetStaticMethodID is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;GetFieldID&quot;) &gt;&#x3D; 0) &#123;\n                addrGetFieldID &#x3D; symbol.address;\n                console.log(&quot;GetFieldID is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;GetStaticFieldID&quot;) &gt;&#x3D; 0) &#123;\n                addrGetStaticFieldID &#x3D; symbol.address;\n                console.log(&quot;GetStaticFieldID is at &quot;, symbol.address, symbol.name);\n            &#125; else if (symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;&#x3D; 0) &#123;\n                addrRegisterNatives &#x3D; symbol.address;\n                console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);\n            &#125;\n        &#125;\n    &#125;\n\n    if (addrGetStringUTFChars !&#x3D; null) &#123;\n        Interceptor.attach(addrGetStringUTFChars, &#123;\n            onEnter: function (args) &#123;&#125;,\n            onLeave: function (retval) &#123;\n                if (retval !&#x3D; null) &#123;\n                    var bytes &#x3D; Memory.readCString(retval);\n                    console.log(&quot;[GetStringUTFChars] result:&quot; + bytes);\n                &#125;\n            &#125;\n        &#125;);\n    &#125;\n    if (addrNewStringUTF !&#x3D; null) &#123;\n        Interceptor.attach(addrNewStringUTF, &#123;\n            onEnter: function (args) &#123;\n                if (args[1] !&#x3D; null) &#123;\n                    var string &#x3D; Memory.readCString(args[1]);\n                    console.log(&quot;[NewStringUTF] bytes:&quot; + string);\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrFindClass !&#x3D; null) &#123;\n        Interceptor.attach(addrFindClass, &#123;\n            onEnter: function (args) &#123;\n                if (args[1] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[1]);\n                    console.log(&quot;[FindClass] name:&quot; + name);\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrGetMethodID !&#x3D; null) &#123;\n        Interceptor.attach(addrGetMethodID, &#123;\n            onEnter: function (args) &#123;\n                if (args[2] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[2]);\n                    if (args[3] !&#x3D; null) &#123;\n                        var sig &#x3D; Memory.readCString(args[3]);\n                        console.log(&quot;[GetMethodID] name:&quot; + name + &quot;, sig:&quot; + sig);\n                    &#125; else &#123;\n                        console.log(&quot;[GetMethodID] name:&quot; + name);\n                    &#125;\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrGetStaticMethodID !&#x3D; null) &#123;\n        Interceptor.attach(addrGetStaticMethodID, &#123;\n            onEnter: function (args) &#123;\n                if (args[2] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[2]);\n                    if (args[3] !&#x3D; null) &#123;\n                        var sig &#x3D; Memory.readCString(args[3]);\n                        console.log(&quot;[GetStaticMethodID] name:&quot; + name + &quot;, sig:&quot; + sig);\n                    &#125; else &#123;\n                        console.log(&quot;[GetStaticMethodID] name:&quot; + name);\n                    &#125;\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrGetFieldID !&#x3D; null) &#123;\n        Interceptor.attach(addrGetFieldID, &#123;\n            onEnter: function (args) &#123;\n                if (args[2] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[2]);\n                    if (args[3] !&#x3D; null) &#123;\n                        var sig &#x3D; Memory.readCString(args[3]);\n                        console.log(&quot;[GetFieldID] name:&quot; + name + &quot;, sig:&quot; + sig);\n                    &#125; else &#123;\n                        console.log(&quot;[GetFieldID] name:&quot; + name);\n                    &#125;\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n    if (addrGetStaticFieldID !&#x3D; null) &#123;\n        Interceptor.attach(addrGetStaticFieldID, &#123;\n            onEnter: function (args) &#123;\n                if (args[2] !&#x3D; null) &#123;\n                    var name &#x3D; Memory.readCString(args[2]);\n                    if (args[3] !&#x3D; null) &#123;\n                        var sig &#x3D; Memory.readCString(args[3]);\n                        console.log(&quot;[GetStaticFieldID] name:&quot; + name + &quot;, sig:&quot; + sig);\n                    &#125; else &#123;\n                        console.log(&quot;[GetStaticFieldID] name:&quot; + name);\n                    &#125;\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n\n    if (addrRegisterNatives !&#x3D; null) &#123;\n        Interceptor.attach(addrRegisterNatives, &#123;\n            onEnter: function (args) &#123;\n                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]);\n                var env &#x3D; args[0];\n                var java_class &#x3D; args[1];\n                var class_name &#x3D; Java.vm.tryGetEnv().getClassName(java_class);\n\n                var methods_ptr &#x3D; ptr(args[2]);\n\n                var method_count &#x3D; parseInt(args[3]);\n                for (var i &#x3D; 0; i &lt; method_count; i++) &#123;\n                    var name_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));\n                    var sig_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));\n                    var fnPtr_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));\n\n                    var name &#x3D; Memory.readCString(name_ptr);\n                    var sig &#x3D; Memory.readCString(sig_ptr);\n                    var find_module &#x3D; Process.findModuleByAddress(fnPtr_ptr);\n                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr, &quot;module_name:&quot;, find_module.name, &quot;module_base:&quot;, find_module.base, &quot;offset:&quot;, ptr(fnPtr_ptr).sub(find_module.base));\n\n                &#125;\n            &#125;,\n            onLeave: function (retval) &#123;&#125;\n        &#125;);\n    &#125;\n&#125;\nfunction main()\n&#123;\n    hookkill();\n    hook_libart();\n&#125;\nsetImmediate(main);\n\n\n\nhook效果，哦对，最好用attach方式，毕竟hook是libc的函数，肯定还有其他地方会hook到，为了避免太多无用信息，所以选择attach\nfrida -UF com.kanxue.test -l hook_art.js --no-pause\n\n\n\n\n逻辑就很清晰了，非常nice。\n","slug":"看雪某数字壳测试题","date":"2021-04-07T01:48:58.000Z","categories_index":"app实战","tags_index":"d2c","author_index":"YenKoc"},{"id":"da27febfe9a3ffe7e8fc2063f78d23df","title":"ida插件_traceNatives剖析","content":"前言前几天在肉丝朋友圈看到了龙哥的新作，一个名叫trace_native的ida插件项目，我出于好奇就想看看源码，发现好想原理也不难，不过提升了效率，还是很不错的\n源码剖析import os\nfrom idaapi import plugin_t\nfrom idaapi import PLUGIN_PROC\nfrom idaapi import PLGIN_OK\nimport ida_nalt\nimport idaapi\nimport idautils\nimport idc\nimport time\n\n# 获取so文件名和路径\ndef getSoPathAndName()\n&#123;\n  fullpath=ida_nalt.get_input_file_path()\n  #从完整路径中取出，文件路径和文件名\n  filepath,filename=os.path.split(fullpath)\n  return filepath,filename\n&#125;\n# 获取代码段的起始地址和结束地址\ndef getSegAddr()\n&#123;\n  finalStart=0xffffffff\n  finalEnd=0\n  for seg in idautils.Segments():\n  \tif (idc.get_segm_name(seg).lower())=='.text' or (idc.get_segm_name(seg).lower())=='text':\n  \t\ttempStart=idc.get_segm_start(seg)\n  \t\ttempEnd=idc.get_segm_end(seg)\n  \t\tif finalStart>tempStart:\n  \t\t\t\tfinalStart=tempStart\n  \t\tif finalEnd&lt;tempEnd:\n  \t\t\t\tfinalEnd=tempEnd\n\treturn finalStart,textEnd\n&#125;\nclass traceNatives(plugin_t):\n  flags=PLUGIN_PROC\n  comment=\"traceNatives\"\n  help=\"\"\n  wanted_name=\"traceNatives\"\n  wanted_hotkey=\"\"\n  \n  def init(self):\n    print(\"traceNatives(v0.1) plugin has been loaded\")\n    return PLUGIN_OK\n  def run(self,arg):\n    ea,ed=getSegAddr()\n    search_result=[]\n    for func in idautils.Functions(ea,ed):\n      try:\n        functionName=str(idaapi.ida_funcs.get_func_name(func))\n        if len(list(idautils.FuncItems(func)))>10:\n          #如果是thumb模式，地址+1\n          arm_or_thumb=idc.get_sreg(func,\"T\")\n          if arm_or_thumb:\n            func+=1\n          search_result.append(hex(func))\n      except:\n        pass\n    \n    so_path,so_name=getSoPathAndName()\n    search_result=[f\"-a '&#123;so_name&#125;!&#123;offset&#125;'\" for offset in search_result]\n    search_result=\" \".join(search_result)\n    \n    script_name=so_name.split(\".\")[0]+\"_\"+str(int(time.time()))+\".txt\"\n    save_path=os.path.join(so_path,script_name)\n    with open(save_path,\"w\",encoding=\"utf-8\") as f:\n      f.write(search_result)\n    print(\"使用方法如下:\")\n    print(f\"frida-trace -UF -O &#123;save_path&#125;\")\n  def term(self):\n    pass\n \t\ndef PLUGIN_ENTRY():\n  return traceNatives()\n     \n         \n\n实际上，就是通过idapython提供的api，先找出代码段的起始地址和结尾地址，然后对代码段中的函数进行遍历，判断是thumb模式还是arm模式，然后根据什么模式，对地址进行处理，搞完之后，将地址存入一个列表中，之后就进行字符串拼接，为后续使用frida-trace批量hook，作准备，我改了一个地方，感觉那个地方写的有点浪费内存。\n效果演示\n\n","slug":"ida插件-traceNatives剖析","date":"2021-03-29T13:01:59.000Z","categories_index":"","tags_index":"ida插件","author_index":"YenKoc"},{"id":"6c1a2f5fee044dc2bb2b3084d9a71810","title":"apkleaks的安装与使用","content":"前言上次开会的时候，听小帅有个可以从app中找接口的一个github项目，最近一直忙资产收集，所以没空看，今晚刚好有空，就clone了一份，并安装了，我习惯用kali了，所以这里安装也是以kali作为主力\n安装方法\nclone一份到本地\n\n进入目录后，输入pip3 install -r requirement.txt\n\n然后就可以使用python apkleads.py -f xx.apk\n\n发现提醒没有jadx的话，要选y，就会自动下载并安装，刚刚去github简介下看了，作者说是apkleaks基于jadx来反编译的\n\n\n\n下载后，就会发现同目录下，有一个jadx文件夹了，至此安装完成\n使用方法python apkleaks.py -f xxx.apk\n然后就开始执行扫描，会将ip和端口都提取出来，不过我实测还是不够准确的，如果只找接口的话，怎么会这么多其他的东西扫出来呢。。我也感觉奇怪，我建议在这句命令后-o xx.txt, 有些app还是挺大的，结果估计会很多，找个文件保存比较合适\n\n","slug":"apkleaks的安装与使用","date":"2021-03-26T18:23:40.000Z","categories_index":"","tags_index":"android工具使用","author_index":"YenKoc"},{"id":"c08d96c88052e6a8de3a34b6361e6767","title":"关于某so函数的加解密，以及自修复","content":"前言：意外在看雪上看到一道题，感觉挺不错的，就自己手动复现了下\n分析过程0x01 脱壳这里使用jeb打开后，发现qihoo的字样，明显是数字壳，这里没使用fart去脱，因为我手机目前没刷机，习惯dexdump，膜葫芦娃大哥2333，这里使用objection加载dexdump插件的方式，挺方便的，至于使用方法，见github，全记上面了，基本就是加载插件，然后plugin dexdump search，plugin dexdump dump，有可能会报错，最近肉丝也发了这个问题的解答，其实就是dexdump暴力搜索时，发现并不是真正的dex，所以才会崩溃，可以无视，脱完，再用jeb打开就行\n0x02 核心逻辑分析用jeb打开后，发现核心的判断函数是一个jni函数，拿出ida，将so打开，按照静态注册方法名搜索，发现并没有找到，说明是动态注册了，直接找JNI_Onload\n\n 这里我就不跟进去了，其实就是动态注册，不过呢，一些参数都被加密了，我ctrl+s看了下段，果然有个.init_array段，并且里面有操作的\n\n好家伙，全是异或，我尝试用idapython进行手动patch，真的麻烦，不过这些参数解密后还是很直观的，作用也挺大\n![image-20210327011018899](/Users/mac/Library/Application Support/typora-user-images/image-20210327011018899.png)\n这里算是patch的一部分了，还是挺不错的，接下来看那个动态注册的jni函数，\n![image-20210327011203804](/Users/mac/Library/Application Support/typora-user-images/image-20210327011203804.png)\n![image-20210327011225526](/Users/mac/Library/Application Support/typora-user-images/image-20210327011225526.png)\n发现什么呢，其实就是so函数级的加解密，如果对这个流程不熟悉和elf文件结构不熟，那么恭喜你，会一脸懵逼，我之前看小黄书的时候，还有印象，基本就是查看内存空间，然后通过字符串操作，取出so加载基地址，然后通过程序头表，找到dym段偏移，跟到实际的dym段，因为dym段其实就一个结构体数组，这个结构体包括了dymstr，dymsym.的相对虚拟地址，然后通过.hash段来计算函数名的hash，查找dymsym中函数结构体，取出函数偏移和大小\n\n然后就是对ooxx函数进行解密了，改变内存的可读，使其可写，改变完还是需要改变回去的\n![image-20210327012214500](/Users/mac/Library/Application Support/typora-user-images/image-20210327012214500.png)\n我们发现其实逻辑很简单，就是异或了一组数组，用frida直接dump下来，本地修复就完事了\nfunction main()\n&#123;\n    var soModule&#x3D;Process.findModuleByName(&quot;libnative-lib.so&quot;);\n    var keyadd&#x3D;ptr(Number(soModule.base)+0x1C180);\n    \n    \n    console.log(keyadd.readByteArray(464))\n    &#x2F;&#x2F; for(var i &#x3D;0;i&lt;486;i++)\n    &#x2F;&#x2F; &#123;\n    &#x2F;&#x2F;     keyadd&#x3D;keyadd+i;\n    &#x2F;&#x2F;     console.log(keyadd.;\n    &#x2F;&#x2F; &#125;\n&#125;\n\nsetImmediate(main);\n\n修复的脚本：\nimport mmap\n\nkey&#x3D;[0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,\n0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,\n0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,\n0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,\n0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,\n0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,\n0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,\n0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,\n0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,\n0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,\n0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,\n0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,\n0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,\n0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,\n0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,\n0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,\n0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,\n0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,\n0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,\n0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,\n0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,\n0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,\n0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,\n0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,\n0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,\n0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,\n0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,\n0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,\n0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf]\n\nfile_name&#x3D;&quot;libnative-lib.so&quot;\nprint(&quot;repair begin))&quot;)\nwith open(file_name,&quot;r+b&quot;) as file_descriptor:\n    memory_map&#x3D;mmap.mmap(file_descriptor.fileno(),0)\n    fuc_offest&#x3D;0x8dc5\n    fuc_size&#x3D;584\n    begin_funcc&#x3D;fuc_offest+59\n    end_funncc&#x3D;fuc_offest+fuc_size-61\n    size&#x3D;end_funncc-begin_funcc\n    for i in range(size):\n        orginal_byte&#x3D;int.from_bytes(memory_map[begin_funcc+i:begin_funcc+i+1],&quot;little&quot;)\n        new_byte&#x3D;orginal_byte^key[i]\n        memory_map[begin_funcc+i:begin_funcc+i+1]&#x3D;bytes([new_byte])\n        read_modified_byte &#x3D; int.from_bytes(memory_map[begin_funcc + i:begin_funcc + i + 1], &quot;little&quot;)\n        print(&quot;i: %d, original_byte: 0x%02x, modified_byte: 0x%02x, read_modified_byte: 0x%02x&quot;% (i, orginal_byte, new_byte,read_modified_byte))\n    memory_map.flush()\n    memory_map.close()\nprint(&quot;repair end!&quot;)\n\n\n\n修复效果：\n![image-20210327012502518](/Users/mac/Library/Application Support/typora-user-images/image-20210327012502518.png)\n","slug":"关于某so函数的加解密，以及自修复","date":"2021-03-26T16:52:56.000Z","categories_index":"","tags_index":"so层的加解密","author_index":"YenKoc"},{"id":"2deee02bdc0213108ea703030610df02","title":"吐槽","content":"没想到啊，兜兜转转还是来gitpages，弄博客了，其他平台真没github稳，刚好，GitHub的图床问题搜到个小工具解决了，hh，正式转战hexo，冲冲冲","slug":"expression","date":"2021-03-22T03:15:30.000Z","categories_index":"","tags_index":"日常杂谈","author_index":"YenKoc"}]