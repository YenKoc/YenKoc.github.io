[{"id":"da27febfe9a3ffe7e8fc2063f78d23df","title":"ida插件_traceNatives剖析","content":"前言前几天在肉丝朋友圈看到了龙哥的新作，一个名叫trace_native的ida插件项目，我出于好奇就想看看源码，发现好想原理也不难，不过提升了效率，还是很不错的\n源码剖析import os\nfrom idaapi import plugin_t\nfrom idaapi import PLUGIN_PROC\nfrom idaapi import PLGIN_OK\nimport ida_nalt\nimport idaapi\nimport idautils\nimport idc\nimport time\n\n# 获取so文件名和路径\ndef getSoPathAndName()\n&#123;\n  fullpath=ida_nalt.get_input_file_path()\n  #从完整路径中取出，文件路径和文件名\n  filepath,filename=os.path.split(fullpath)\n  return filepath,filename\n&#125;\n# 获取代码段的起始地址和结束地址\ndef getSegAddr()\n&#123;\n  finalStart=0xffffffff\n  finalEnd=0\n  for seg in idautils.Segments():\n  \tif (idc.get_segm_name(seg).lower())=='.text' or (idc.get_segm_name(seg).lower())=='text':\n  \t\ttempStart=idc.get_segm_start(seg)\n  \t\ttempEnd=idc.get_segm_end(seg)\n  \t\tif finalStart>tempStart:\n  \t\t\t\tfinalStart=tempStart\n  \t\tif finalEnd&lt;tempEnd:\n  \t\t\t\tfinalEnd=tempEnd\n\treturn finalStart,textEnd\n&#125;\nclass traceNatives(plugin_t):\n  flags=PLUGIN_PROC\n  comment=\"traceNatives\"\n  help=\"\"\n  wanted_name=\"traceNatives\"\n  wanted_hotkey=\"\"\n  \n  def init(self):\n    print(\"traceNatives(v0.1) plugin has been loaded\")\n    return PLUGIN_OK\n  def run(self,arg):\n    ea,ed=getSegAddr()\n    search_result=[]\n    for func in idautils.Functions(ea,ed):\n      try:\n        functionName=str(idaapi.ida_funcs.get_func_name(func))\n        if len(list(idautils.FuncItems(func)))>10:\n          #如果是thumb模式，地址+1\n          arm_or_thumb=idc.get_sreg(func,\"T\")\n          if arm_or_thumb:\n            func+=1\n          search_result.append(hex(func))\n      except:\n        pass\n    \n    so_path,so_name=getSoPathAndName()\n    search_result=[f\"-a '&#123;so_name&#125;!&#123;offset&#125;'\" for offset in search_result]\n    search_result=\" \".join(search_result)\n    \n    script_name=so_name.split(\".\")[0]+\"_\"+str(int(time.time()))+\".txt\"\n    save_path=os.path.join(so_path,script_name)\n    with open(save_path,\"w\",encoding=\"utf-8\") as f:\n      f.write(search_result)\n    print(\"使用方法如下:\")\n    print(f\"frida-trace -UF -O &#123;save_path&#125;\")\n  def term(self):\n    pass\n \t\ndef PLUGIN_ENTRY():\n  return traceNatives()\n     \n         \n\n实际上，就是通过idapython提供的api，先找出代码段的起始地址和结尾地址，然后对代码段中的函数进行遍历，判断是thumb模式还是arm模式，然后根据什么模式，对地址进行处理，搞完之后，将地址存入一个列表中，之后就进行字符串拼接，为后续使用frida-trace批量hook，作准备，我改了一个地方，感觉那个地方写的有点浪费内存。\n效果演示\n\n","slug":"ida插件-traceNatives剖析","date":"2021-03-29T13:01:59.000Z","categories_index":"","tags_index":"ida插件","author_index":"三钻"},{"id":"6c1a2f5fee044dc2bb2b3084d9a71810","title":"apkleaks的安装与使用","content":"前言上次开会的时候，听小帅有个可以从app中找接口的一个github项目，最近一直忙资产收集，所以没空看，今晚刚好有空，就clone了一份，并安装了，我习惯用kali了，所以这里安装也是以kali作为主力\n安装方法\nclone一份到本地\n\n进入目录后，输入pip3 install -r requirement.txt\n\n然后就可以使用python apkleads.py -f xx.apk\n\n发现提醒没有jadx的话，要选y，就会自动下载并安装，刚刚去github简介下看了，作者说是apkleaks基于jadx来反编译的\n\n\n\n下载后，就会发现同目录下，有一个jadx文件夹了，至此安装完成\n使用方法python apkleaks.py -f xxx.apk\n然后就开始执行扫描，会将ip和端口都提取出来，不过我实测还是不够准确的，如果只找接口的话，怎么会这么多其他的东西扫出来呢。。我也感觉奇怪，我建议在这句命令后-o xx.txt, 有些app还是挺大的，结果估计会很多，找个文件保存比较合适\n\n","slug":"apkleaks的安装与使用","date":"2021-03-26T18:23:40.000Z","categories_index":"","tags_index":"android工具使用","author_index":"三钻"},{"id":"c08d96c88052e6a8de3a34b6361e6767","title":"关于某so函数的加解密，以及自修复","content":"前言：意外在看雪上看到一道题，感觉挺不错的，就自己手动复现了下\n分析过程0x01 脱壳这里使用jeb打开后，发现qihoo的字样，明显是数字壳，这里没使用fart去脱，因为我手机目前没刷机，习惯dexdump，膜葫芦娃大哥2333，这里使用objection加载dexdump插件的方式，挺方便的，至于使用方法，见github，全记上面了，基本就是加载插件，然后plugin dexdump search，plugin dexdump dump，有可能会报错，最近肉丝也发了这个问题的解答，其实就是dexdump暴力搜索时，发现并不是真正的dex，所以才会崩溃，可以无视，脱完，再用jeb打开就行\n0x02 核心逻辑分析用jeb打开后，发现核心的判断函数是一个jni函数，拿出ida，将so打开，按照静态注册方法名搜索，发现并没有找到，说明是动态注册了，直接找JNI_Onload\n\n 这里我就不跟进去了，其实就是动态注册，不过呢，一些参数都被加密了，我ctrl+s看了下段，果然有个.init_array段，并且里面有操作的\n\n好家伙，全是异或，我尝试用idapython进行手动patch，真的麻烦，不过这些参数解密后还是很直观的，作用也挺大\n![image-20210327011018899](/Users/mac/Library/Application Support/typora-user-images/image-20210327011018899.png)\n这里算是patch的一部分了，还是挺不错的，接下来看那个动态注册的jni函数，\n![image-20210327011203804](/Users/mac/Library/Application Support/typora-user-images/image-20210327011203804.png)\n![image-20210327011225526](/Users/mac/Library/Application Support/typora-user-images/image-20210327011225526.png)\n发现什么呢，其实就是so函数级的加解密，如果对这个流程不熟悉和elf文件结构不熟，那么恭喜你，会一脸懵逼，我之前看小黄书的时候，还有印象，基本就是查看内存空间，然后通过字符串操作，取出so加载基地址，然后通过程序头表，找到dym段偏移，跟到实际的dym段，因为dym段其实就一个结构体数组，这个结构体包括了dymstr，dymsym.的相对虚拟地址，然后通过.hash段来计算函数名的hash，查找dymsym中函数结构体，取出函数偏移和大小\n\n然后就是对ooxx函数进行解密了，改变内存的可读，使其可写，改变完还是需要改变回去的\n![image-20210327012214500](/Users/mac/Library/Application Support/typora-user-images/image-20210327012214500.png)\n我们发现其实逻辑很简单，就是异或了一组数组，用frida直接dump下来，本地修复就完事了\nfunction main()\n&#123;\n    var soModule&#x3D;Process.findModuleByName(&quot;libnative-lib.so&quot;);\n    var keyadd&#x3D;ptr(Number(soModule.base)+0x1C180);\n    \n    \n    console.log(keyadd.readByteArray(464))\n    &#x2F;&#x2F; for(var i &#x3D;0;i&lt;486;i++)\n    &#x2F;&#x2F; &#123;\n    &#x2F;&#x2F;     keyadd&#x3D;keyadd+i;\n    &#x2F;&#x2F;     console.log(keyadd.;\n    &#x2F;&#x2F; &#125;\n&#125;\n\nsetImmediate(main);\n\n修复的脚本：\nimport mmap\n\nkey&#x3D;[0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,\n0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,\n0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,\n0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,\n0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,\n0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,\n0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,\n0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,\n0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,\n0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,\n0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,\n0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,\n0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,\n0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,\n0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,\n0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,\n0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,\n0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,\n0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,\n0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,\n0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,\n0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,\n0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,\n0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,\n0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,\n0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,\n0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,\n0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,\n0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf]\n\nfile_name&#x3D;&quot;libnative-lib.so&quot;\nprint(&quot;repair begin))&quot;)\nwith open(file_name,&quot;r+b&quot;) as file_descriptor:\n    memory_map&#x3D;mmap.mmap(file_descriptor.fileno(),0)\n    fuc_offest&#x3D;0x8dc5\n    fuc_size&#x3D;584\n    begin_funcc&#x3D;fuc_offest+59\n    end_funncc&#x3D;fuc_offest+fuc_size-61\n    size&#x3D;end_funncc-begin_funcc\n    for i in range(size):\n        orginal_byte&#x3D;int.from_bytes(memory_map[begin_funcc+i:begin_funcc+i+1],&quot;little&quot;)\n        new_byte&#x3D;orginal_byte^key[i]\n        memory_map[begin_funcc+i:begin_funcc+i+1]&#x3D;bytes([new_byte])\n        read_modified_byte &#x3D; int.from_bytes(memory_map[begin_funcc + i:begin_funcc + i + 1], &quot;little&quot;)\n        print(&quot;i: %d, original_byte: 0x%02x, modified_byte: 0x%02x, read_modified_byte: 0x%02x&quot;% (i, orginal_byte, new_byte,read_modified_byte))\n    memory_map.flush()\n    memory_map.close()\nprint(&quot;repair end!&quot;)\n\n\n\n修复效果：\n![image-20210327012502518](/Users/mac/Library/Application Support/typora-user-images/image-20210327012502518.png)\n","slug":"关于某so函数的加解密，以及自修复","date":"2021-03-26T16:52:56.000Z","categories_index":"","tags_index":"so层的加解密","author_index":"三钻"},{"id":"2deee02bdc0213108ea703030610df02","title":"吐槽","content":"没想到啊，兜兜转转还是来gitpages，弄博客了，其他平台真没github稳，刚好，GitHub的图床问题搜到个小工具解决了，hh，正式转战hexo，冲冲冲","slug":"expression","date":"2021-03-22T03:15:30.000Z","categories_index":"","tags_index":"日常杂谈","author_index":"三钻"}]