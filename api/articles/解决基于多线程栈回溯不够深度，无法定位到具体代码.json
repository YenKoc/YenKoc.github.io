{"title":"解决基于多线程栈回溯不够深度，无法定位到具体代码","uid":"a285eb2e1ce3d42c5752f972d9befc34","slug":"解决基于多线程栈回溯不够深度，无法定位到具体代码","date":"2021-04-21T02:05:56.000Z","updated":"2021-04-21T03:17:27.241Z","comments":true,"path":"api/articles/解决基于多线程栈回溯不够深度，无法定位到具体代码.json","keywords":null,"cover":"https://w.wallhaven.cc/full/g8/wallhaven-g83m3d.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>现在的发包框架都是新起一个线程，然后把一些发包逻辑塞到里面去，之前学习到去hook一些java层的api，可以去栈回溯，但是在实战中发现，就是我们的栈回溯最高层，只能回溯到java.lang.Thread类，但是这个无法让我们快速找到关键代码，而且为什么只能回溯到java.lang.Thread类呢，就只能从源码中去找答案.</p>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><p>先写个安卓里面新建线程的demo</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;helll&quot;);\n            &#125;\n        &#125;).start();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>发现是创建了一个thread对象，并在构造函数中，传入了一个runnable对象，全是匿名的，我们去跟下这个Thread类</p>\n<p>，看看是如何新建线程的，</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210421102128.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210421102155.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210421102506.png\"></p>\n<p>到目前为止，只是new了thread对象，还没开始新建线程，只是把线程的初始化环境配好。再跟下start方法</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210421102825.png\"></p>\n<p>跟进nativeCreate方法</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210421102930.png\"></p>\n<p>好家伙，是jni函数，这里有个技巧，就是jni函数找源码，类名加下划线加jni函数，就能找到。</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210421104008.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210421104047.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210421104449.png\"></p>\n<p>发现最终还是调用libc中的pthreadcreate方法，去新建进程，继续跟下这个线程会执行什么，这时候已经到新建线程里了，</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210421104735.png\"></p>\n<p>发现了为什么我们栈回溯，一直最高层是java.lang.Thread，因为我们新线程最先执行是java.lang.Thread.run方法。</p>\n<p>所以我们的核心问题是找到主线程是在哪里新建线程的，所以我们hook的对象应该是在主进程过程中的执行流程，然后打印</p>\n<p>这里可选的点还是蛮多的，这里选init2，然后还可以把target对象的classname打印出来的，放下frida 脚本</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;package:com.example.hookso\nfunction LogPrint(log) &#123;\n    var theDate &#x3D; new Date();\n    var hour &#x3D; theDate.getHours();\n    var minute &#x3D; theDate.getMinutes();\n    var second &#x3D; theDate.getSeconds();\n    var mSecond &#x3D; theDate.getMilliseconds();\n\n    hour &lt; 10 ? hour &#x3D; &quot;0&quot; + hour : hour;\n    minute &lt; 10 ? minute &#x3D; &quot;0&quot; + minute : minute;\n    second &lt; 10 ? second &#x3D; &quot;0&quot; + second : second;\n    mSecond &lt; 10 ? mSecond &#x3D; &quot;00&quot; + mSecond : mSecond &lt; 100 ? mSecond &#x3D; &quot;0&quot; + mSecond : mSecond;\n    var time &#x3D; hour + &quot;:&quot; + minute + &quot;:&quot; + second + &quot;:&quot; + mSecond;\n    var threadid &#x3D; Process.getCurrentThreadId();\n    console.log(&quot;[&quot; + time + &quot;]&quot; + &quot;-&gt;threadid:&quot; + threadid + &quot;--&quot; + log);\n\n&#125;\n\nfunction printJavaStack(name) &#123;\n    Java.perform(function () &#123;\n        var Exception &#x3D; Java.use(&quot;java.lang.Exception&quot;);\n        var ins &#x3D; Exception.$new(&quot;Exception&quot;);\n        var straces &#x3D; ins.getStackTrace();\n        if (straces !&#x3D; undefined &amp;&amp; straces !&#x3D; null) &#123;\n            var strace &#x3D; straces.toString();\n            var replaceStr &#x3D; strace.replace(&#x2F;,&#x2F;g, &quot; \\n &quot;);\n            LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n            LogPrint(replaceStr);\n            LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; \\n &quot;);\n            Exception.$dispose();\n        &#125;\n    &#125;);\n&#125;\nfunction hookThread()\n&#123;\n    Java.perform(function()&#123;\n         var YThreadClass&#x3D;Java.use(&quot;java.lang.Thread&quot;);\n         YThreadClass.init2.implementation&#x3D;function(arg0)\n         &#123;\n             var target&#x3D;this.target.value;\n             if(target!&#x3D;null)\n             &#123;\n                LogPrint(&quot;go into Thread.init2 -&gt;Runnable class:&quot;+target.$className);\n                printJavaStack(&quot;java.lang.Thread.init2&quot;);\n             &#125;else&#123;\n                 LogPrint(&quot;go into Thread.init2-&gt;Thread.class:&quot;,this.$className);\n                 printJavaStack(&quot;java.lang.Thread.init2&quot;);\n                 var threadclassname&#x3D;this.$className;\n                 var ChindThreadClass.run.implementation&#x3D;function()&#123;\n                     LogPrint(&quot;go into&quot;+threadclassname+&quot;.run&quot;);\n                     printJavaStack(threadclassname+&quot;.run&quot;);\n                     var result&#x3D;this.run();\n                     return result;\n                 &#125;\n             &#125;\n         \n         var res&#x3D;this.init2(arg0);\n         return res;\n        &#125;\n        YThreadClass.run.implementation&#x3D;function()\n        &#123;\n            var target &#x3D; this.target.value;\n            if (target !&#x3D; null) &#123;\n                LogPrint(&quot;go into Thread.run-&gt;Runnable class:&quot; + target.$className);\n                printJavaStack(&quot;java.lang.Thread.run&quot;)\n            &#125;\n\n            var reuslt &#x3D; this.run();\n            return reuslt;\n        &#125;\n\n    &#125;)\n\n    \n&#125;\nfunction main()\n&#123;\n    hookThread();\n&#125;\nsetImmediate(main)    \n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210421111504.png\"></p>\n<p>效果真不错</p>\n","feature":null,"text":"前言现在的发包框架都是新起一个线程，然后把一些发包逻辑塞到里面去，之前学习到去hook一些java层的api，可以去栈回溯，但是在实战中发现，就是我们的栈回溯最高层，只能回溯到java.lang.Thread类，但是这个无法让我们快速找到关键代码，而且为什么只能回溯到java.l...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"app抓包","slug":"app抓包","count":1,"path":"api/categories/app抓包.json"}],"tags":[{"name":"抓包","slug":"抓包","count":1,"path":"api/tags/抓包.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">源码分析</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"DDCTF 黑盒破解","uid":"17e7f940452dda42feb97fd742be4e95","slug":"DDCTF-黑盒破解","date":"2021-04-22T06:07:05.000Z","updated":"2021-04-22T10:13:22.613Z","comments":true,"path":"api/articles/DDCTF-黑盒破解.json","keywords":null,"cover":"https://th.wallhaven.cc/small/e7/e7z65r.jpg","text":"前言最近在出校赛的题，和csu联合出题，压力还是有的，题目不可能出的太水的，所以我最近的想法，搞点有意思的题，看看vm的几种实现，然后自己写写，感受下，然后开始搞搞开发了，嘿嘿，vm做个开胃菜，之后玩点上次github上看到的东西。 开始分析，ida上号这题vm是属于需要自己构造...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"writeup","slug":"writeup","count":8,"path":"api/categories/writeup.json"}],"tags":[{"name":"reverse","slug":"reverse","count":12,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"ZUC密码","uid":"3c82e2c97f4021478c0aae078b24ed3b","slug":"ZUC密码","date":"2021-04-19T12:05:24.000Z","updated":"2021-04-19T12:15:12.560Z","comments":true,"path":"api/articles/ZUC密码.json","keywords":null,"cover":"https://w.wallhaven.cc/full/rd/wallhaven-rddgwm.jpg","text":"前言复现mrctf题中，发现有题涉及到zuc密码，这个之前好像有听说过，但是没去细致看过，所以就看了几篇博客，跟了下流程，把算法抄了一遍，加深下影响，去具体背加密流程，我这脑子也记不下，只能是熟悉流程和特征，对应的看了233 源代码#include &lt;iostream&gt...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"密码学","slug":"密码学","count":1,"path":"api/categories/密码学.json"}],"tags":[{"name":"密码学","slug":"密码学","count":1,"path":"api/tags/密码学.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}