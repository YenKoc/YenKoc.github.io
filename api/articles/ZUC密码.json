{"title":"ZUC密码","uid":"3c82e2c97f4021478c0aae078b24ed3b","slug":"ZUC密码","date":"2021-04-19T12:05:24.000Z","updated":"2021-04-19T12:15:12.560Z","comments":true,"path":"api/articles/ZUC密码.json","keywords":null,"cover":"https://w.wallhaven.cc/full/rd/wallhaven-rddgwm.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>复现mrctf题中，发现有题涉及到zuc密码，这个之前好像有听说过，但是没去细致看过，所以就看了几篇博客，跟了下流程，把算法抄了一遍，加深下影响，去具体背加密流程，我这脑子也记不下，只能是熟悉流程和特征，对应的看了233</p>\n<h1 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;iostream&gt;\n\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n&#x2F;*the state register of LFSR*&#x2F;\ntypedef unsigned char u8;\ntypedef unsigned int u32;\nu32 LFSR_S[16]&#x3D;&#123;0&#125;;\n\n&#x2F;*the register of F*&#x2F;\nu32 F_R1&#x3D;0;\nu32 F_R2&#x3D;0;\n\n&#x2F;*the outputs of BitReorganization*&#x2F;\nu32 BRC_X[4]&#x3D;&#123;0&#125;;\n\n\nu8 S0[256] &#x3D; &#123;\n        0x3e, 0x72, 0x5b, 0x47, 0xca, 0xe0, 0x00, 0x33, 0x04, 0xd1, 0x54, 0x98, 0x09, 0xb9, 0x6d, 0xcb,\n        0x7b, 0x1b, 0xf9, 0x32, 0xaf, 0x9d, 0x6a, 0xa5, 0xb8, 0x2d, 0xfc, 0x1d, 0x08, 0x53, 0x03, 0x90,\n        0x4d, 0x4e, 0x84, 0x99, 0xe4, 0xce, 0xd9, 0x91, 0xdd, 0xb6, 0x85, 0x48, 0x8b, 0x29, 0x6e, 0xac,\n        0xcd, 0xc1, 0xf8, 0x1e, 0x73, 0x43, 0x69, 0xc6, 0xb5, 0xbd, 0xfd, 0x39, 0x63, 0x20, 0xd4, 0x38,\n        0x76, 0x7d, 0xb2, 0xa7, 0xcf, 0xed, 0x57, 0xc5, 0xf3, 0x2c, 0xbb, 0x14, 0x21, 0x06, 0x55, 0x9b,\n        0xe3, 0xef, 0x5e, 0x31, 0x4f, 0x7f, 0x5a, 0xa4, 0x0d, 0x82, 0x51, 0x49, 0x5f, 0xba, 0x58, 0x1c,\n        0x4a, 0x16, 0xd5, 0x17, 0xa8, 0x92, 0x24, 0x1f, 0x8c, 0xff, 0xd8, 0xae, 0x2e, 0x01, 0xd3, 0xad,\n        0x3b, 0x4b, 0xda, 0x46, 0xeb, 0xc9, 0xde, 0x9a, 0x8f, 0x87, 0xd7, 0x3a, 0x80, 0x6f, 0x2f, 0xc8,\n        0xb1, 0xb4, 0x37, 0xf7, 0x0a, 0x22, 0x13, 0x28, 0x7c, 0xcc, 0x3c, 0x89, 0xc7, 0xc3, 0x96, 0x56,\n        0x07, 0xbf, 0x7e, 0xf0, 0x0b, 0x2b, 0x97, 0x52, 0x35, 0x41, 0x79, 0x61, 0xa6, 0x4c, 0x10, 0xfe,\n        0xbc, 0x26, 0x95, 0x88, 0x8a, 0xb0, 0xa3, 0xfb, 0xc0, 0x18, 0x94, 0xf2, 0xe1, 0xe5, 0xe9, 0x5d,\n        0xd0, 0xdc, 0x11, 0x66, 0x64, 0x5c, 0xec, 0x59, 0x42, 0x75, 0x12, 0xf5, 0x74, 0x9c, 0xaa, 0x23,\n        0x0e, 0x86, 0xab, 0xbe, 0x2a, 0x02, 0xe7, 0x67, 0xe6, 0x44, 0xa2, 0x6c, 0xc2, 0x93, 0x9f, 0xf1,\n        0xf6, 0xfa, 0x36, 0xd2, 0x50, 0x68, 0x9e, 0x62, 0x71, 0x15, 0x3d, 0xd6, 0x40, 0xc4, 0xe2, 0x0f,\n        0x8e, 0x83, 0x77, 0x6b, 0x25, 0x05, 0x3f, 0x0c, 0x30, 0xea, 0x70, 0xb7, 0xa1, 0xe8, 0xa9, 0x65,\n        0x8d, 0x27, 0x1a, 0xdb, 0x81, 0xb3, 0xa0, 0xf4, 0x45, 0x7a, 0x19, 0xdf, 0xee, 0x78, 0x34, 0x60&#125;;\n\nu8 S1[256] &#x3D; &#123;\n        0x55, 0xc2, 0x63, 0x71, 0x3b, 0xc8, 0x47, 0x86, 0x9f, 0x3c, 0xda, 0x5b, 0x29, 0xaa, 0xfd, 0x77,\n        0x8c, 0xc5, 0x94, 0x0c, 0xa6, 0x1a, 0x13, 0x00, 0xe3, 0xa8, 0x16, 0x72, 0x40, 0xf9, 0xf8, 0x42,\n        0x44, 0x26, 0x68, 0x96, 0x81, 0xd9, 0x45, 0x3e, 0x10, 0x76, 0xc6, 0xa7, 0x8b, 0x39, 0x43, 0xe1,\n        0x3a, 0xb5, 0x56, 0x2a, 0xc0, 0x6d, 0xb3, 0x05, 0x22, 0x66, 0xbf, 0xdc, 0x0b, 0xfa, 0x62, 0x48,\n        0xdd, 0x20, 0x11, 0x06, 0x36, 0xc9, 0xc1, 0xcf, 0xf6, 0x27, 0x52, 0xbb, 0x69, 0xf5, 0xd4, 0x87,\n        0x7f, 0x84, 0x4c, 0xd2, 0x9c, 0x57, 0xa4, 0xbc, 0x4f, 0x9a, 0xdf, 0xfe, 0xd6, 0x8d, 0x7a, 0xeb,\n        0x2b, 0x53, 0xd8, 0x5c, 0xa1, 0x14, 0x17, 0xfb, 0x23, 0xd5, 0x7d, 0x30, 0x67, 0x73, 0x08, 0x09,\n        0xee, 0xb7, 0x70, 0x3f, 0x61, 0xb2, 0x19, 0x8e, 0x4e, 0xe5, 0x4b, 0x93, 0x8f, 0x5d, 0xdb, 0xa9,\n        0xad, 0xf1, 0xae, 0x2e, 0xcb, 0x0d, 0xfc, 0xf4, 0x2d, 0x46, 0x6e, 0x1d, 0x97, 0xe8, 0xd1, 0xe9,\n        0x4d, 0x37, 0xa5, 0x75, 0x5e, 0x83, 0x9e, 0xab, 0x82, 0x9d, 0xb9, 0x1c, 0xe0, 0xcd, 0x49, 0x89,\n        0x01, 0xb6, 0xbd, 0x58, 0x24, 0xa2, 0x5f, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xb8, 0x95, 0xe4,\n        0xd0, 0x91, 0xc7, 0xce, 0xed, 0x0f, 0xb4, 0x6f, 0xa0, 0xcc, 0xf0, 0x02, 0x4a, 0x79, 0xc3, 0xde,\n        0xa3, 0xef, 0xea, 0x51, 0xe6, 0x6b, 0x18, 0xec, 0x1b, 0x2c, 0x80, 0xf7, 0x74, 0xe7, 0xff, 0x21,\n        0x5a, 0x6a, 0x54, 0x1e, 0x41, 0x31, 0x92, 0x35, 0xc4, 0x33, 0x07, 0x0a, 0xba, 0x7e, 0x0e, 0x34,\n        0x88, 0xb1, 0x98, 0x7c, 0xf3, 0x3d, 0x60, 0x6c, 0x7b, 0xca, 0xd3, 0x1f, 0x32, 0x65, 0x04, 0x28,\n        0x64, 0xbe, 0x85, 0x9b, 0x2f, 0x59, 0x8a, 0xd7, 0xb0, 0x25, 0xac, 0xaf, 0x12, 0x03, 0xe2, 0xf2&#125;;\n\nu32 EK_d[16] &#x3D; &#123;\n        0x44d7, 0x26bc, 0x626b, 0x135e, 0x5789, 0x35e2, 0x7135, 0x09af,\n        0x4d78, 0x2f13, 0x6bc4, 0x1af1, 0x5e26, 0x3c4d, 0x789a, 0x47ac&#125;;\n#define MAKEU31(a,b,c) (((u32)((u32)(0)|(u8)(a))&lt;&lt;23)|(u32)((u32)(0)|(u8)(c)))\n&#x2F;*Bit Reorganization*&#x2F;\nvoid BitReorganization()\n&#123;\n    BRC_X[0]&#x3D;((LFSR_S[15]&amp;0x7FFF8000)&lt;&lt;1)|(LFSR_S[14]&amp;0xFFFF);\n    BRC_X[1]&#x3D;((LFSR_S[11]&amp;0xFFFF)&lt;&lt;16)|(LFSR_S[9]&gt;&gt;15);\n    BRC_X[2]&#x3D;((LFSR_S[7]&amp;0xFFFF)&lt;&lt;16)|(LFSR_S[5]&gt;&gt;15);\n    BRC_X[3]&#x3D;((LFSR_S[2]&amp;0xFFFF)&lt;&lt;16)|(LFSR_S[0]&gt;&gt;15);\n&#125;\n#define MAKEU32(a,b,c,d) (((u32)(a)&lt;&lt;24)|((u32)(b)&lt;&lt;16)|((u32)(c)&lt;&lt;8)|((u32)(d)))\n#define ROT(a,k) (((a)&lt;&lt;k)|((a)&gt;&gt;(32-k)))\n&#x2F;*L1*&#x2F;\nu32 L1(u32 X)\n&#123;\n    return (X^ROT(X,2)^ROT(X,10)^ROT(X,18)^ROT(X,24));\n&#125;\n&#x2F;*L2*&#x2F;\nu32 L2(u32 X)\n&#123;\n    return (X^ROT(X,8)^ROT(X,14)^ROT(X,22)^ROT(X,30));\n&#125;\n\n&#x2F;*F*&#x2F;\nu32 F()&#123;\n    u32 W,W1,W2,u,v;\n    W&#x3D;(BRC_X[0]^F_R1)+F_R2;\n    W1&#x3D;F_R1+BRC_X[1];\n    W2&#x3D;F_R2+BRC_X[2];\n    u&#x3D;L1((W1&lt;&lt;16)|W2&gt;&gt;16);\n    v&#x3D;L2((W2&lt;&lt;16|W1&gt;&gt;16));\n    F_R1&#x3D; MAKEU32(S0[u&gt;&gt;24],S1[(u&gt;&gt;16)&amp;0xFF],S0[(u&gt;&gt;8)&amp;0xFF],S1[u&amp;0xFF]);\n    F_R2&#x3D;MAKEU32(S0[v&gt;&gt;24],S1[(v&gt;&gt;16)&amp;0xFF],S0[(v&gt;&gt;8)&amp;0xFF],S1[v&amp;0xFF]);\n    return W;\n&#125;\nu32 AddM(u32 a,u32 b)\n&#123;\n    u32 c&#x3D;a+b;\n    return (c&amp;0x7FFFFFFF)+(c&gt;&gt;31);\n&#125;\n#define MulByPow2(x,k) ((((x) &lt;&lt; k) | ((x) &gt;&gt; (31 - k))) &amp; 0x7FFFFFFF)\n&#x2F;* LFSR with work mode *&#x2F;\nvoid LFSRWithWorkMode()\n&#123;\n    u32 f,v;\n    u32 i;\n    f&#x3D;LFSR_S[0];\n    v&#x3D;MulByPow2(LFSR_S[0],8);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[4],20);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[10],21);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[13],17);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[15],15);\n    f&#x3D;AddM(f,v);\n    &#x2F;*update the state*&#x2F;\n    for(i&#x3D;0;i&lt;15;i++)&#123;\n        LFSR_S[i]&#x3D;LFSR_S[i+1];\n    &#125;\n    LFSR_S[15]&#x3D;f;\n&#125;\nvoid LFSRWithInitializationMode(u32 u)\n&#123;\n    u32 f,v;\n    u32 i;\n    f&#x3D;LFSR_S[0];\n    v&#x3D;MulByPow2(LFSR_S[0],8);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[4],20);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[10],21);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[13],17);\n    f&#x3D;AddM(f,v);\n\n    v&#x3D;MulByPow2(LFSR_S[15],15);\n    f&#x3D;AddM(f,v);\n    f&#x3D; AddM(f,u);\n    &#x2F;*update the state*&#x2F;\n    for(i&#x3D;0;i&lt;15;i++)&#123;\n        LFSR_S[i]&#x3D;LFSR_S[i+1];\n    &#125;\n    LFSR_S[15]&#x3D;f;\n&#125;\n&#x2F;*initialize*&#x2F;\nvoid Initiallization(u8 *k,u8 *iv)\n&#123;\n    u32 w,nCount;\n    u32 i;\n\n    &#x2F;*expand key*&#x2F;\n    for(i&#x3D;0;i&lt;16;i++)\n    &#123;\n        LFSR_S[i]&#x3D;MAKEU31(k[i],EK_d[i],iv[i]);\n    &#125;\n\n    &#x2F;*set F_R1 and F_R2 to zero*&#x2F;\n    F_R1&#x3D;0;\n    F_R2&#x3D;0;\n    nCount&#x3D;32;\n    while(nCount&gt;0)\n    &#123;\n        BitReorganization();\n        w&#x3D;F();\n        LFSRWithInitializationMode(w&gt;&gt;1);\n        nCount--;\n    &#125;\n    &#x2F;*First generation abandoned*&#x2F;\n    BitReorganization();\n    F();\n    LFSRWithWorkMode();\n\n&#125;\nvoid GenerateKeyStream(u32* pKeyStream,u32 KeyStreamLen)\n&#123;\n    u32 i;\n    for(i&#x3D;0;i&lt;KeyStreamLen;i++)\n    &#123;\n        BitReorganization();\n        pKeyStream[i]&#x3D;F()^BRC_X[3];\n        LFSRWithWorkMode();\n    &#125;\n&#125;\nint main() &#123;\n    u8 key[16]&#x3D;&#123;0x3d,0x4c,0x4b,0xe9,0x6a,0x82,0xfd, 0xae, 0xb5, 0x8f, 0x64, 0x1d, 0xb1, 0x7b, 0x45, 0x5b&#125;;\n    u8 iv[16]&#x3D;&#123;0x84,0x31,0x9a,0xa8,0xde,0x69,0x15,0xca,0x1f,0x6b,0xda,0xd8,0xc7,0x66&#125;;\n    u32 pKeyStream[4]&#x3D;&#123;0&#125;;\n    u32 KeyStreamLen&#x3D;sizeof(pKeyStream)&#x2F;sizeof(pKeyStream[0]);\n    Initiallization(key,iv);\n    GenerateKeyStream(pKeyStream,KeyStreamLen);\n    for(int i&#x3D;0;i&lt;KeyStreamLen;i++)\n    &#123;\n        printf(&quot;z%d:\\t0x%08x\\n&quot;,i,pKeyStream[i]);\n    &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>比较明显的就是四个x寄存器，然后那两张s表，以及最后的x3寄存器的异或，都可以作为判断的标准，自己用c++搞完，编译后，strip去完符号，用ida打开，看了看</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210419201215.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210419201240.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210419201314.png\"></p>\n<h1 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h1><p>研究了下ubuntu的c/c++编译环境，配置了下，感觉还不错，反正比我win虚拟机强mmp，linux用起来还是舒服，去符号找了很久</p>\n<p>参考链接:</p>\n<p><a href=\"https://blog.csdn.net/qq_38737992/article/details/90288994\">https://blog.csdn.net/qq_38737992/article/details/90288994</a></p>\n<p><a href=\"https://blog.csdn.net/qq_43094622/article/details/105823724\">https://blog.csdn.net/qq_43094622/article/details/105823724</a></p>\n<p><a href=\"https://blog.csdn.net/listener51/article/details/53836213\">https://blog.csdn.net/listener51/article/details/53836213</a></p>\n","feature":null,"text":"前言复现mrctf题中，发现有题涉及到zuc密码，这个之前好像有听说过，但是没去细致看过，所以就看了几篇博客，跟了下流程，把算法抄了一遍，加深下影响，去具体背加密流程，我这脑子也记不下，只能是熟悉流程和特征，对应的看了233 源代码#include &lt;iostream&gt...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"密码学","slug":"密码学","count":1,"path":"api/categories/密码学.json"}],"tags":[{"name":"密码学","slug":"密码学","count":1,"path":"api/tags/密码学.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%BA%90%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">源代码</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%93%E5%B0%BE\"><span class=\"toc-text\">结尾</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"解决基于多线程栈回溯不够深度，无法定位到具体代码","uid":"a285eb2e1ce3d42c5752f972d9befc34","slug":"解决基于多线程栈回溯不够深度，无法定位到具体代码","date":"2021-04-21T02:05:56.000Z","updated":"2021-04-21T03:17:27.241Z","comments":true,"path":"api/articles/解决基于多线程栈回溯不够深度，无法定位到具体代码.json","keywords":null,"cover":"https://w.wallhaven.cc/full/g8/wallhaven-g83m3d.jpg","text":"前言现在的发包框架都是新起一个线程，然后把一些发包逻辑塞到里面去，之前学习到去hook一些java层的api，可以去栈回溯，但是在实战中发现，就是我们的栈回溯最高层，只能回溯到java.lang.Thread类，但是这个无法让我们快速找到关键代码，而且为什么只能回溯到java.l...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"app抓包","slug":"app抓包","count":1,"path":"api/categories/app抓包.json"}],"tags":[{"name":"抓包","slug":"抓包","count":1,"path":"api/tags/抓包.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"2021MRCTF Re wp","uid":"62c420e89414aa7b4113290b58fef1bf","slug":"2021MRCTF-Re-wp","date":"2021-04-17T03:54:09.000Z","updated":"2021-04-19T13:32:20.165Z","comments":true,"path":"api/articles/2021MRCTF-Re-wp.json","keywords":null,"cover":"https://w.wallhaven.cc/full/x8/wallhaven-x88o53.jpg","text":"My Register这题我觉得出的非常好，真不错，我都学到了很多，尤其是这种双进程保护，之前其实挺懵逼的，最近可能是自己基础更扎实了，很多概念一点就能通，总体就是父进程创建子进程，根据标记，会走向不同分支，这样还不够刺激，还没达到反调试，我们可以在子进程的代码中强行加入一些异常...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"writeup","slug":"writeup","count":5,"path":"api/categories/writeup.json"}],"tags":[{"name":"reverse","slug":"reverse","count":6,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}