{"title":"Android got hook","uid":"08f55e9615384c7275f59ed241f8ccbd","slug":"Android-got-hook","date":"2021-06-09T06:24:12.000Z","updated":"2021-06-10T07:37:53.107Z","comments":true,"path":"api/articles/Android-got-hook.json","keywords":null,"cover":"https://th.wallhaven.cc/small/6o/6od3px.jpg","content":"<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p> 核心原理就是查找程序头表中的动态segment，然后查看虚拟内存映射到哪个位置，也就是rva，可以直接去ida中查看偏移， 因为我发现ida去解析so文件的时候，是看segment表去解析的，所以ida直接就是一个起始地址为0的虚拟内存（，先去010查看这个段在哪，然后发现里面包含了一些导入的so库名称，还有一个符号表，字符串表，然后还有一个很重要的动态重定位表，里面是包含一个info结构体，这个结构体可以去查询符号的字符串表下标，以及类型，然后还有一个地方，就是这个导入符号对应got表偏移地址，那么我们直接把这个地址中的地址替换成我们想要的，不就完事了，不想放图了，被折磨的有点怕了（，我是懒狗</p>\n<h1 id=\"Demo代码\"><a href=\"#Demo代码\" class=\"headerlink\" title=\"Demo代码:\"></a>Demo代码:</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;jni.h&gt;\n#include &lt;string&gt;\n#include &quot;unistd.h&quot;\n#include &quot;stdio.h&quot;\n#include &quot;stdlib.h&quot;\n#include&lt;android&#x2F;log.h&gt;\n#include&lt;EGL&#x2F;egl.h&gt;\n#include&lt;GLES&#x2F;gl.h&gt;\n#include&lt;elf.h&gt;\n#include&lt;fcntl.h&gt;\n#include&lt;sys&#x2F;mman.h&gt;\n#include&lt;inttypes.h&gt;\n#include&lt;dlfcn.h&gt;\n#include &quot;native-lib.h&quot;\n\n\n#define LOG_TAG    &quot;NativeHook&quot;\n#define LOG_E(format, ...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, format, ##__VA_ARGS__)\n#define LOG_D(format, ...)  __android_log_print(ANDROID_LOG_INFO,  LOG_TAG, format, ##__VA_ARGS__)\n\n#define PAGE_START(address) ((address)&amp;PAGE_MASK)\n#define PAGE_END(address) (PAGE_START(address)+PAGE_SIZE)\n\nsize_t  (*old_fwrite)(const void *buf,size_t size,size_t count,FILE *fp);\n\nsize_t  new_fwrite(const void *buf,size_t size,size_t count,FILE *fp)\n&#123;\n    const char *text&#x3D;&quot;hello&quot;;\n    old_fwrite(text,strlen(text),1,fp);\n    return old_fwrite(buf,size,count,fp);\n&#125;\n\n&#x2F;&#x2F;从&#x2F;proc&#x2F;pi&#x2F;maps文件中，获取so模块的首地址\nvoid * get_module_base(pid_t pid,const char *module_name)\n&#123;\n    FILE *fp;\n    long addr&#x3D;0;\n    char filename[32]&#x3D;&quot;\\n&quot;;\n    char line[1024]&#x3D;&quot;\\n&quot;;\n    if(pid&lt;0)\n    &#123;\n        snprintf(filename,sizeof(filename),&quot;&#x2F;proc&#x2F;self&#x2F;maps&quot;);\n    &#125; else&#123;\n        snprintf(filename,sizeof(filename),&quot;&#x2F;proc&#x2F;%d&#x2F;maps&quot;,pid);\n    &#125;\n\n    fp&#x3D;fopen(filename,&quot;r&quot;);\n    while(fgets(line,sizeof(line),fp))\n    &#123;\n        if(strstr(line,module_name)!&#x3D;NULL&amp;&amp;sscanf(line,&quot;%&quot; PRIxPTR&quot;-%*lx %*4s 00000000&quot;,&amp;addr)&#x3D;&#x3D;1)\n            break;\n    &#125;\n    fclose(fp);\n    return (void*) addr;\n&#125;\nint hook_fwrite(const char *soPath)\n&#123;\n    &#x2F;&#x2F;获取要hook so的模块基地址\n    void* base_addr&#x3D;get_module_base(getpid(),soPath);\n    old_fwrite&#x3D;fwrite;\n    Elf32_Ehdr *header&#x3D;(Elf32_Ehdr*)base_addr;\n    Elf32_Phdr *phdr_table&#x3D;(Elf32_Phdr *)((int)base_addr+header-&gt;e_phoff);\n    if(phdr_table&#x3D;&#x3D;0)\n    &#123;\n        return 0;\n    &#125;\n    size_t phdr_count&#x3D;header-&gt;e_phnum;\n    unsigned long p_vaddr&#x3D;0;\n    unsigned int p_memsz&#x3D;0;\n    int j&#x3D;0;\n    for(j&#x3D;0;j&lt;phdr_count;j++)\n    &#123;\n        if(phdr_table[j].p_type&#x3D;&#x3D;PT_DYNAMIC) &#123;\n            p_vaddr &#x3D; phdr_table[j].p_vaddr + (int) base_addr;\n            p_memsz &#x3D; phdr_table[j].p_memsz;\n        &#125;;\n    &#125;\n    Elf32_Dyn *dynamic_table&#x3D;(Elf32_Dyn*)(p_vaddr);\n    unsigned long jmpRelOff&#x3D;0;\n    unsigned long strTabOff&#x3D;0;\n    unsigned long pltRelSz&#x3D;0;\n    unsigned long symTabOff&#x3D;0;\n    int dynCount&#x3D;p_memsz&#x2F;sizeof(Elf32_Dyn);\n    for(int i&#x3D;0;i&lt;dynCount;i++)\n    &#123;\n        int val&#x3D;dynamic_table[i].d_un.d_val;\n        switch (dynamic_table[i].d_tag) &#123;\n            case DT_JMPREL:\n                jmpRelOff&#x3D;val;\n                break;\n            case DT_STRTAB:\n                strTabOff&#x3D;val;\n                break;\n            case DT_PLTRELSZ:\n                pltRelSz&#x3D;val&#x2F;sizeof(Elf32_Rel);\n                break;\n            case DT_SYMTAB:\n                symTabOff&#x3D;val;\n                break;\n        &#125;\n    &#125;\n    Elf32_Rel *rel_table&#x3D;(Elf32_Rel*)(jmpRelOff+(int)base_addr);\n    for(int i&#x3D;0;i&lt;pltRelSz;i++)\n    &#123;\n        uint16_t ndx&#x3D;ELF32_R_SYM(rel_table[i].r_info);\n        Elf32_Sym *symTableIndex&#x3D;(Elf32_Sym*)(ndx*sizeof(Elf32_Sym)+symTabOff+(int)base_addr);\n        &#x2F;&#x2F;获取符号符号结构体\n        &#x2F;&#x2F;获取符号名字\n        char* funcName&#x3D;(char*)(symTableIndex-&gt;st_name+strTabOff+(int)base_addr);\n        if(memcmp(funcName,&quot;fwrite&quot;,strlen(&quot;fwrite&quot;))&#x3D;&#x3D;0)\n        &#123;\n            &#x2F;&#x2F;获取当前内存分页的大小\n            uint32_t page_size&#x3D;getpagesize();\n            &#x2F;&#x2F;获取内存分页的起始地\n            uint32_t mem_page_start&#x3D;rel_table[i].r_offset+(int)base_addr;\n            mprotect(reinterpret_cast&lt;void *&gt;((uint32_t) PAGE_START(mem_page_start)), page_size, PROT_READ | PROT_WRITE | PROT_EXEC);\n            *(unsigned int*)(rel_table[i].r_offset+(int)base_addr)&#x3D;(int)new_fwrite;\n        &#125;\n\n    &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","feature":null,"text":"原理 核心原理就是查找程序头表中的动态segment，然后查看虚拟内存映射到哪个位置，也就是rva，可以直接去ida中查看偏移， 因为我发现ida去解析so文件的时候，是看segment表去解析的，所以ida直接就是一个起始地址为0的虚拟内存（，先去010查看这个段在哪，然后发现...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":10,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"got表hook","slug":"got表hook","count":1,"path":"api/tags/got表hook.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Demo%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">Demo代码:</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"Android8.0 art下面的几个脱壳点","uid":"05699e0b3c4e02c2136460838badc80b","slug":"Android8-0-art下面的几个脱壳点","date":"2021-06-11T16:10:05.000Z","updated":"2021-06-11T17:09:36.572Z","comments":true,"path":"api/articles/Android8-0-art下面的几个脱壳点.json","keywords":null,"cover":"https://w.wallhaven.cc/full/5w/wallhaven-5w3dm8.jpg","text":"前言搞了一个17年decon 会议的ppt，里面对市面上的一些apk加固方式有一些整体分析，实际上手动脱壳，现在越来越难了，时间成本太大了，各种莫名的反调试和混淆，so的话，俺也不太会搞vmp，在学了在学了（我太菜了，java层的话，还是有突破口的，毕竟dex再怎么加固，最终还是...","link":"","photos":[],"count_time":{"symbolsCount":843,"symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":10,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"AndroidUnPacker","slug":"AndroidUnPacker","count":1,"path":"api/tags/AndroidUnPacker.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"Android热修复类加载方案demo","uid":"a90be964479d5a11087cdb9a691b6994","slug":"Android热修复类加载方案demo","date":"2021-06-04T05:54:30.000Z","updated":"2021-06-09T06:52:44.644Z","comments":true,"path":"api/articles/Android热修复类加载方案demo.json","keywords":null,"cover":"https://th.wallhaven.cc/small/6o/6oqzgq.jpg","text":"前言在逆一些东西的时候，总会遇到热修复的东西，但是之前只是听说并没有了解过这个热修复是啥，所以昨天花了一下午的时间学习了，感觉还可以，主要是跟系统的源码有关系的。 先了解一手系统classloader classloader在热修复中，我们主要就关心两种，pathclassloa...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"安卓开发","slug":"安卓开发","count":1,"path":"api/categories/安卓开发.json"}],"tags":[{"name":"热修复","slug":"热修复","count":1,"path":"api/tags/热修复.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}