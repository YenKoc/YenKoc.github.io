{"title":"2015阿里移动安全挑战赛5道题writeup","uid":"48c7547c87104b3665dc18f2c480b135","slug":"阿里移动安全挑战赛5道题","date":"2021-07-28T03:15:34.000Z","updated":"2021-07-30T02:39:10.290Z","comments":true,"path":"api/articles/阿里移动安全挑战赛5道题.json","keywords":null,"cover":"https://w.wallhaven.cc/full/dg/wallhaven-dg2dog.jpg","content":"<h1 id=\"Alicrackme-1\"><a href=\"#Alicrackme-1\" class=\"headerlink\" title=\"Alicrackme_1\"></a>Alicrackme_1</h1><p>jeb打开</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210728111748.png\"></p>\n<p>逻辑非常简单就是调用了两个方法，返回一张表，和密文，而我们的输入是作为表的下标去进行检索。</p>\n<p>不过在用frida dump下结果后，发现竟然是中文，我还想转换成字节数组，后面发现一个索引对一个中文，</p>\n<p>直接写脚本撸就行</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class getFlag&#123;\n    public static void main(String[] args) &#123;\n        String table&#x3D;&quot;一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们仪白仔他斥瓜乎丛令用甩印乐&quot;;\n                String pw&#x3D;&quot;义弓么丸广之&quot;;\n                String flag&#x3D;&quot;&quot;;\n                for(int i&#x3D;0;i&lt;pw.length();i++)\n                &#123;\n                    flag+&#x3D;(char)table.indexOf(pw.charAt(i));\n                &#125;\n                System.out.println(flag);\n&#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>flag: 581026</p>\n<h1 id=\"Alicrackme-2\"><a href=\"#Alicrackme-2\" class=\"headerlink\" title=\"Alicrackme_2\"></a>Alicrackme_2</h1><p>这题其实没啥太大难点，核心就是要多动调，毕竟很多位置，他是通过程序去进行填充，然后跳转，如果不知道那个位置的话，其实很难去理解什么意思</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210728221419.png\"></p>\n<p>这里是核心逻辑，我这里卡了很久是要调试jniload方法的话，我们需要有一些特殊的手法</p>\n<p>这里简单说下ida的动态调试，先手机服务器起一个server，然后ida这里确保可以attach，</p>\n<p>然后adb shell am start -D -n 包名/.启动的组件名</p>\n<p>接下来就是 attach上去，这里会进入到libc.so，不管它直接f9</p>\n<p>adb shell ps | grep com.yaotong.crackme（包名）</p>\n<p>查看进程id，取出进程id</p>\n<p>adb forward tcp:8700 jdwp: pid（从上面取出的)</p>\n<p>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</p>\n<p>然后就会到linker上了，如果这时候so加载进来，我们就可以自然而然的到</p>\n<p>init段，init array，jni_onload去调试，然后jni_onload执行完，</p>\n<p>我们就正常输入下断点就行</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210728221319.png\"></p>\n<h1 id=\"后面三道题因架构问题，没法搞，我的备用调机还没到，需要等等了\"><a href=\"#后面三道题因架构问题，没法搞，我的备用调机还没到，需要等等了\" class=\"headerlink\" title=\"后面三道题因架构问题，没法搞，我的备用调机还没到，需要等等了\"></a>后面三道题因架构问题，没法搞，我的备用调机还没到，需要等等了</h1>","feature":null,"text":"Alicrackme_1jeb打开 逻辑非常简单就是调用了两个方法，返回一张表，和密文，而我们的输入是作为表的下标去进行检索。 不过在用frida dump下结果后，发现竟然是中文，我还想转换成字节数组，后面发现一个索引对一个中文， 直接写脚本撸就行 public class g...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":22,"path":"api/tags/reverse.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Alicrackme-1\"><span class=\"toc-text\">Alicrackme_1</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Alicrackme-2\"><span class=\"toc-text\">Alicrackme_2</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%90%8E%E9%9D%A2%E4%B8%89%E9%81%93%E9%A2%98%E5%9B%A0%E6%9E%B6%E6%9E%84%E9%97%AE%E9%A2%98%EF%BC%8C%E6%B2%A1%E6%B3%95%E6%90%9E%EF%BC%8C%E6%88%91%E7%9A%84%E5%A4%87%E7%94%A8%E8%B0%83%E6%9C%BA%E8%BF%98%E6%B2%A1%E5%88%B0%EF%BC%8C%E9%9C%80%E8%A6%81%E7%AD%89%E7%AD%89%E4%BA%86\"><span class=\"toc-text\">后面三道题因架构问题，没法搞，我的备用调机还没到，需要等等了</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"修改ro.debuggable的坑以及有效方式","uid":"0558c37e07e30bb941d09a486e640b0f","slug":"修改ro-debuggable的坑以及有效方式","date":"2021-07-28T07:33:43.000Z","updated":"2021-07-28T07:37:09.949Z","comments":true,"path":"api/articles/修改ro-debuggable的坑以及有效方式.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/57/5758y8.jpg","text":"有效方式 android8.1 pixel完美修改，然后mprop，以及xdebuggable，我都使用了，但是还是不行，建议用这个面具来搞，我是用卡刷的，github上下载，然后模块安装 https://github.com/Magisk-Modules-Repo/Magisk...","link":"","photos":[],"count_time":{"symbolsCount":174,"symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":22,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"Xposed编写inlinehook框架插件02","uid":"81adc87c645a49aab325f38e6f3026a2","slug":"Xposed编写inlinehook框架插件02","date":"2021-07-26T08:35:24.000Z","updated":"2021-07-26T08:48:55.416Z","comments":true,"path":"api/articles/Xposed编写inlinehook框架插件02.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/pk/pkw6y3.jpg","text":"前言吐槽下，妈的，应该是框架本身的bug，好像hook自己编写的函数无参数的话，就会莫名报错，这里耽误了我几个小时，最终才发现了这个问题，鬼知道我开关机了几次妈的。 正式开始 被hook的app的核心逻辑 #include &lt;jni.h&gt; #include &lt;s...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"xposed","slug":"xposed","count":2,"path":"api/tags/xposed.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}