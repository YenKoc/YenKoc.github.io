{"title":"unidbg实例使用以及遇到的问题(-)","uid":"6a44b632aa8a379a96226b3336a01d5f","slug":"unidbg实例使用以及遇到的问题","date":"2021-07-30T13:44:05.000Z","updated":"2021-07-31T04:12:26.108Z","comments":true,"path":"api/articles/unidbg实例使用以及遇到的问题.json","keywords":null,"cover":"https://th.wallhaven.cc/small/j3/j3339m.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>对某程app的so进行模拟执行，加深对unidbg的理解和使用(不提供样本)</p>\n<h1 id=\"开始分析\"><a href=\"#开始分析\" class=\"headerlink\" title=\"开始分析\"></a>开始分析</h1><ol>\n<li><p>找到我们的目标</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210730215333.png\"></p>\n<p>打算是模拟执行这个jni函数，再找到这个加载的so</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210730215545.png\"></p>\n<p>​         这个jni函数参数是一个字节数组，一个字符串，返回值也是字符串</p>\n<ol start=\"2\">\n<li><p>用frida hook下，看看啥情况</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210730215917.png\"></p>\n<p>发现就是第一个参数一直在变动，第二个参数getdata倒是不变，返回值也在不断的变动</p>\n</li>\n</ol>\n<h1 id=\"unidbg开始编写\"><a href=\"#unidbg开始编写\" class=\"headerlink\" title=\"unidbg开始编写\"></a>unidbg开始编写</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.xc;\n\nimport com.github.unidbg.AndroidEmulator;\nimport com.github.unidbg.linux.android.AndroidEmulatorBuilder;\nimport com.github.unidbg.linux.android.AndroidResolver;\nimport com.github.unidbg.linux.android.dvm.AbstractJni;\nimport com.github.unidbg.linux.android.dvm.DalvikModule;\nimport com.github.unidbg.linux.android.dvm.VM;\nimport com.github.unidbg.memory.Memory;\n\nimport java.io.File;\n\npublic class SignTestUtil extends AbstractJni &#123;\n    private final AndroidEmulator emulator;\n    private final VM vm;\n    SignTestUtil()\n    &#123;\n        emulator&#x3D; AndroidEmulatorBuilder.for32Bit().build();\n        final Memory memory&#x3D; emulator.getMemory();\n        memory.setLibraryResolver(new AndroidResolver(23));\n\n        vm&#x3D;emulator.createDalvikVM(new File(&quot;unidbg-android&#x2F;src&#x2F;main&#x2F;java&#x2F;xc&#x2F;xc 8-38-2.apk&quot;));\n         vm.setVerbose(true);\n        DalvikModule dm&#x3D;vm.loadLibrary(new File(&quot;unidbg-android&#x2F;src&#x2F;main&#x2F;java&#x2F;xc&#x2F;libscmain.so&quot;),true);\n        vm.setJni(this);\n        dm.callJNI_OnLoad(emulator);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        SignTestUtil st&#x3D;new SignTestUtil();\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里先编写的是加载到模拟内存，以及执行完jnionload，就是初始化的意思，看看执行会发生什么</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210730234205.png\"></p>\n<p>先看第一个报错，实际上可以发现是缺少了依赖库，这里其实就是相对于我们的so的导入函数，也是依赖库的导出函数，如果我们需要执行导入函数，那么依赖的库肯定也是需要加载到内存中的，ida打开这个so文件，查看导入的函数</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210730234831.png\"></p>\n<p>安卓没有懒加载，所以一旦so加载进来，其他依赖的库同时也需要加载进来，所以这个地方才会报错的，所以我们需要去解决这个加载缺失的问题。</p>\n<p>为什么其他so没有加载进来，实际上是unidbg本身就有预置了so文件，在这里</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210731004946.png\"></p>\n<p>并没有我们需要的so，为什么unidbg没有这个so文件，实际上是因为libandroid.so文件所依赖的so实在太多了，如果依赖的so又有依赖的so，那么只会需要越来越多的so，所以这个so并不是默认的so（这里指走安卓那套的）</p>\n<p>那么解决的方式，按龙哥的说法是有两种</p>\n<p>一种是hook，在libscmain中hook libandroid.so的函数，或者直接把那个so加载进来，然后hook 各种函数，然后自己实现这些函数的逻辑，给予正确的返回值</p>\n<p>另一种方法是使用unidbg提供的virtualModule机制，创建一个虚拟的so，手动实现其中的函数，然后加载到内存（这里经过我理解，一般正常按安卓那套，如果加载一个so，对应依赖so也需要加载进来，那么会一直陷入一个很尴尬的地步，需要一直导入，但是虚拟so似乎摆脱安卓这套限制，载入后，只需要实现对应的导入函数逻辑，就可以摆脱困境，但是如果这套源码继续引用其他so呢，引入这个思考）</p>\n<p>这里刚好unidbg提供了两个现成的virtualso，那么我们可以直接使用的。</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210731093635.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210731093826.png\"></p>\n<p>基本上就是根据安卓源码，实现了导入函数的逻辑，真不错，如果还需要其他模块的，那么我们同样需要照着安卓源码，实现对应逻辑（感谢龙哥）</p>\n<h1 id=\"将虚拟so加载到内存\"><a href=\"#将虚拟so加载到内存\" class=\"headerlink\" title=\"将虚拟so加载到内存\"></a>将虚拟so加载到内存</h1><p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210731095350.png\"></p>\n<p>就加一行代码，但是加载依赖必须在被依赖的前面</p>\n<p>再次运行，发现报错消失了一行</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210731101242.png\"></p>\n<h1 id=\"系统调用报错\"><a href=\"#系统调用报错\" class=\"headerlink\" title=\"系统调用报错\"></a>系统调用报错</h1><p>仔细看上文信息，发现是so中调用了syscall，openat，打开了/proc/16148/status，这个文件很熟悉了，一般用来反调试的，中间数字肯定就是pid，不过这个pid是打引号的</p>\n<p>下面还有一个读取cmdline的，这玩意是返回进程名的，是用来防止重打包的</p>\n<p>unidbg并没有文件系统，所以我们可以对文件访问的api全部进行io重定向。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.xc;\n\nimport com.github.unidbg.AndroidEmulator;\nimport com.github.unidbg.Emulator;\nimport com.github.unidbg.file.FileResult;\nimport com.github.unidbg.file.IOResolver;\nimport com.github.unidbg.linux.android.AndroidEmulatorBuilder;\nimport com.github.unidbg.linux.android.AndroidResolver;\nimport com.github.unidbg.linux.android.dvm.AbstractJni;\nimport com.github.unidbg.linux.android.dvm.DalvikModule;\nimport com.github.unidbg.linux.android.dvm.VM;\nimport com.github.unidbg.memory.Memory;\nimport com.github.unidbg.virtualmodule.android.AndroidModule;\n\nimport java.io.File;\n\npublic class SignTestUtil extends AbstractJni implements IOResolver &#123;\n    private final AndroidEmulator emulator;\n    private final VM vm;\n    SignTestUtil()\n    &#123;\n        emulator&#x3D; AndroidEmulatorBuilder.for32Bit().build();\n        &#x2F;&#x2F;2. 绑定IO重定向接口\n        emulator.getSyscallHandler().addIOResolver(this);\n        System.out.println(&quot;当前进程pid:&quot;+emulator.getPid());\n        final Memory memory&#x3D; emulator.getMemory();\n        memory.setLibraryResolver(new AndroidResolver(23));\n\n        vm&#x3D;emulator.createDalvikVM(new File(&quot;unidbg-android&#x2F;src&#x2F;main&#x2F;java&#x2F;xc&#x2F;xc 8-38-2.apk&quot;));\n         vm.setVerbose(true);\n         new AndroidModule(emulator,vm).register(memory);\n        DalvikModule dm&#x3D;vm.loadLibrary(new File(&quot;unidbg-android&#x2F;src&#x2F;main&#x2F;java&#x2F;xc&#x2F;libscmain.so&quot;),true);\n        vm.setJni(this);\n        dm.callJNI_OnLoad(emulator);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        SignTestUtil st&#x3D;new SignTestUtil();\n    &#125;\n\n\n    @Override\n    public FileResult resolve(Emulator emulator, String pathname, int oflags) &#123;\n        System.out.println(&quot;访问:&quot;+pathname);\n        return null;\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>先随便在本类实现一个，也可以新建一个新类实现，不过龙哥昨晚跟我讨论了下，会有一些冲突，具体还得继续深入学习一手再说，先运行下打印</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210731102926.png\"></p>\n<p>发现实现了这个接口后，对io的操作，似乎都开始经过这里了，估计是做了一层hook回调，前面stdin等都是libc初始化的，不用管，ok，接下来需要对搞一手重定向了，自己实现一手</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">  @Override\n    public FileResult resolve(Emulator emulator, String pathname, int oflags) &#123;\n        if((&quot;proc&#x2F;&quot;+emulator.getPid()+&quot;&#x2F;cmdline&quot;).equals(pathname))\n        &#123;\n            return FileResult.success(new ByteArrayFileIO(oflags,pathname,&quot;ctrip.android.view&quot;.getBytes()));\n            &#x2F;&#x2F;return FileResult.success(new SimpleFileIO(oflags,new File(&quot;将进程名完全写入后的那个文件&quot;),pathname));\n        &#125;\n        return null;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>有两种方式，一种是写入文件，然后以文件的形式，另一种就是直接字符串形式，我就比较粗暴一点了，字符串很简洁，或者直接adb pull下来对应的文件，嘿嘿，更省事</p>\n<p>继续补status</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">if ((&quot;proc&#x2F;&quot; + emulator.getPid() + &quot;&#x2F;status&quot;).equals(pathname)) \n&#123; \n\treturn FileResult.success(new ByteArrayFileIO(oflags, pathname, (&quot;Name: ip.android.view\\n&quot; + &quot;State: R (running)\\n&quot; + &quot;Tgid: &quot;+emulator.getPid()+&quot;\\n&quot; + &quot;Pid: &quot;+emulator.getPid()+&quot;\\n&quot; + &quot;PPid: 3000\\n&quot; + &quot;TracerPid: 0\\n&quot; + &quot;Uid: 10163 10163 10163 10163\\n&quot; + &quot;Gid: 10163 10163 10163 10163\\n&quot; + &quot;FDSize: 512\\n&quot; + &quot;Groups: 3002 3003 9997 20163 50163\\n&quot; + &quot;VmPeak: 2319784 kB\\n&quot; + &quot;VmSize: 2240148 kB\\n&quot; + &quot;VmLck: 0 kB\\n&quot; + &quot;VmPin: 0 kB\\n&quot; + &quot;VmHWM: 413060 kB\\n&quot; + &quot;VmRSS: 310988 kB\\n&quot; + &quot;VmData: 427160 kB\\n&quot; + &quot;VmStk: 8192 kB\\n&quot; + &quot;VmExe: 20 kB\\n&quot; + &quot;VmLib: 200676 kB\\n&quot; + &quot;VmPTE: 2100 kB\\n&quot; + &quot;VmSwap: 3356 kB\\n&quot; +\n&quot;Threads: 149\\n&quot; + &quot;SigQ: 1&#x2F;6517\\n&quot; + &quot;SigPnd: 0000000000000000\\n&quot; + &quot;ShdPnd: 0000000000000000\\n&quot; + &quot;SigBlk: 0000000000001204\\n&quot; + &quot;SigIgn: 0000000000000000\\n&quot; + &quot;SigCgt: 00000006400096fc\\n&quot; + &quot;CapInh: 0000000000000000\\n&quot; + &quot;CapPrm: 0000000000000000\\n&quot; + &quot;CapEff: 0000000000000000\\n&quot; + &quot;CapBnd: 0000000000000000\\n&quot; + &quot;CapAmb: 0000000000000000\\n&quot; + &quot;Seccomp: 2\\n&quot; + &quot;Cpus_allowed: 0f\\n&quot; + &quot;Cpus_allowed_list: 0-3\\n&quot; + &quot;Mems_allowed: 1\\n&quot; + &quot;Mems_allowed_list: 0\\n&quot; + &quot;voluntary_ctxt_switches: 6918\\n&quot; + &quot;nonvoluntary_ctxt_switches: 4988&quot;).getBytes())); \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意的点在于两点，一点是保证文件的完整性，避免出错，另一点就是进程id要统一，既然在unicorn上跑，就要遵守unicorn的规则</p>\n<p>再次运行</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210731104850.png\"></p>\n<p>已经没有报错了，挺完美的。</p>\n<h1 id=\"正式运行jni函数\"><a href=\"#正式运行jni函数\" class=\"headerlink\" title=\"正式运行jni函数\"></a>正式运行jni函数</h1><p>利用杨神的脚本，跑出动态注册关系</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function LogPrint(log) &#123;\n    var theDate &#x3D; new Date();\n    var hour &#x3D; theDate.getHours();\n    var minute &#x3D; theDate.getMinutes();\n    var second &#x3D; theDate.getSeconds();\n    var mSecond &#x3D; theDate.getMilliseconds();\n\n    hour &lt; 10 ? hour &#x3D; &quot;0&quot; + hour : hour;\n    minute &lt; 10 ? minute &#x3D; &quot;0&quot; + minute : minute;\n    second &lt; 10 ? second &#x3D; &quot;0&quot; + second : second;\n    mSecond &lt; 10 ? mSecond &#x3D; &quot;00&quot; + mSecond : mSecond &lt; 100 ? mSecond &#x3D; &quot;0&quot; + mSecond : mSecond;\n    var time &#x3D; hour + &quot;:&quot; + minute + &quot;:&quot; + second + &quot;:&quot; + mSecond;\n    var threadid &#x3D; Process.getCurrentThreadId();\n    console.log(&quot;[&quot; + time + &quot;]&quot; + &quot;-&gt;threadid:&quot; + threadid + &quot;--&quot; + log);\n\n&#125;\n\nfunction printNativeStack(context, name) &#123;\n    &#x2F;&#x2F;Debug.\n  &#x2F;&#x2F;  var array &#x3D; Thread.backtrace(context, Backtracer.ACCURATE);\n    &#x2F;&#x2F;var first &#x3D; DebugSymbol.fromAddress(array[0]);\n    Thread.backtrace(context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n&quot;);\n    &#x2F;*if (first.toString().indexOf(&#39;libopenjdk.so!NET_Send&#39;) &lt; 0) &#123;\n        var trace &#x3D; \n        LogPrint(&quot;-----------start:&quot; + name + &quot;--------------&quot;);\n        LogPrint(trace);\n        LogPrint(&quot;-----------end:&quot; + name + &quot;--------------&quot;);\n    &#125;\n    *&#x2F;\n\n&#125;\n\nfunction printJavaStack(name) &#123;\n    Java.perform(function () &#123;\n        var Exception &#x3D; Java.use(&quot;java.lang.Exception&quot;);\n        var ins &#x3D; Exception.$new(&quot;Exception&quot;);\n        var straces &#x3D; ins.getStackTrace();\n        if (straces !&#x3D; undefined &amp;&amp; straces !&#x3D; null) &#123;\n            var strace &#x3D; straces.toString();\n            var replaceStr &#x3D; strace.replace(&#x2F;,&#x2F;g, &quot; \\n &quot;);\n            LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack strat&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n            LogPrint(replaceStr);\n            LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; \\n &quot;);\n            Exception.$dispose();\n        &#125;\n    &#125;);\n&#125;\n\nfunction isprintable(value) &#123;\n    if (value &gt;&#x3D; 32 &amp;&amp; value &lt;&#x3D; 126) &#123;\n        return true;\n    &#125;\n    return false;\n&#125;\n\nfunction hook_RegisterNatives() &#123;\n    var symbols &#x3D; Module.enumerateSymbolsSync(&quot;libart.so&quot;);\n    var addrRegisterNatives &#x3D; null;\n    for (var i &#x3D; 0; i &lt; symbols.length; i++) &#123;\n        var symbol &#x3D; symbols[i];\n        \n        &#x2F;&#x2F;_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi\n        if (symbol.name.indexOf(&quot;art&quot;) &gt;&#x3D; 0 &amp;&amp;\n                symbol.name.indexOf(&quot;JNI&quot;) &gt;&#x3D; 0 &amp;&amp; \n                symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;&#x3D; 0 &amp;&amp; \n                symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123;\n            addrRegisterNatives &#x3D; symbol.address;\n            console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);\n        &#125;\n    &#125;\n\n    if (addrRegisterNatives !&#x3D; null) &#123;\n        Interceptor.attach(addrRegisterNatives, &#123;\n            onEnter: function (args) &#123;\n                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]);\n                var env &#x3D; args[0];\n                var java_class &#x3D; args[1];\n                var class_name &#x3D; Java.vm.tryGetEnv().getClassName(java_class);\n                &#x2F;&#x2F;console.log(class_name);\n\n                var methods_ptr &#x3D; ptr(args[2]);\n\n                var method_count &#x3D; parseInt(args[3]);\n                for (var i &#x3D; 0; i &lt; method_count; i++) &#123;\n                    var name_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));\n                    var sig_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));\n                    var fnPtr_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));\n\n                    var name &#x3D; Memory.readCString(name_ptr);\n                    var sig &#x3D; Memory.readCString(sig_ptr);\n                    var find_module &#x3D; Process.findModuleByAddress(fnPtr_ptr);\n                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr, &quot;module_name:&quot;, find_module.name, &quot;module_base:&quot;, find_module.base, &quot;offset:&quot;, ptr(fnPtr_ptr).sub(find_module.base));\n\n                &#125;\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\nsetImmediate(hook_RegisterNatives);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>找到我们所要的函数偏移，现在很多so都加固了，ida打开对应偏移，都无法识别出函数了</p>\n<p>[RegisterNatives] java_class: ctrip.android.security.SecurityUtil name: simpleSign sig: ([BLjava/lang/String;)Ljava/lang/String; fnPtr: 0xc8c929d9 module_name: libscmain.so module_base: 0xc8c0c000 offset: 0x869d9</p>\n<p>不过加载内存中，就好很多了，开始拼接参数</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public void callSimpleSign()\n &#123;\n     List&lt;Object&gt; list&#x3D;new ArrayList&lt;&gt;(10);\n     list.add(vm.getJNIEnv());\n     list.add(0);\n     String input&#x3D;&quot;7be9f13e7f5426d139cb4e5dbb1fdba7&quot;;\n     byte[] inputByte&#x3D;input.getBytes(StandardCharsets.UTF_8);\n     ByteArray inputByteArray&#x3D;new ByteArray(vm,inputByte);\n     list.add(vm.addLocalObject(inputByteArray));\n     list.add(vm.addLocalObject(new StringObject(vm,&quot;getdata&quot;)));\n     Number number&#x3D;module.callFunction(emulator,0x869d9,list.toArray())[0];\n     System.out.println(vm.getObject(number.intValue()).getValue().toString());\n &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>龙哥说这种自我封装，不用unidbg本身提供的api，更加灵活，抗风险更高，还行233，其实上这个操作去unidbg源码会发现，其实是一样的2333，unidbg比较懒人</p>\n<p>几点注意</p>\n<ul>\n<li>传入native的java参数，除了八个基本类型外(byte, char,short,int,long,float,double,boolean)，都必须vm.addLocalObject添加到局部引用中去</li>\n<li>参数1是jnienv，参数2是jobject，因为jobject一般不怎么样用，所以这里是传空，虽然是有一点小风险的，万一有用咋办2333</li>\n</ul>\n<h1 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h1><p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210731112443.png\"></p>\n<p>成功运行，并打印</p>\n<p>同时龙哥也提出:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">unidbg不是万能的\nunidbg需要使用组合拳\nunidbg适合算法还原，环境稳定，基于unicorn的hook，因为unidbg需要补环境，也就要求我们对算法从一无所知变成至少了解，样本从黑盒变成了灰盒<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n","feature":null,"text":"前言对某程app的so进行模拟执行，加深对unidbg的理解和使用(不提供样本) 开始分析 找到我们的目标 打算是模拟执行这个jni函数，再找到这个加载的so ​ 这个jni函数参数是一个字节数组，一个字符串，返回值也是字符串 用frida hook下，看看啥情况 发现就是第一个...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"unidbg","slug":"unidbg","count":2,"path":"api/categories/unidbg.json"}],"tags":[{"name":"reverse","slug":"reverse","count":18,"path":"api/tags/reverse.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%80%E5%A7%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">开始分析</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#unidbg%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99\"><span class=\"toc-text\">unidbg开始编写</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B0%86%E8%99%9A%E6%8B%9Fso%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98\"><span class=\"toc-text\">将虚拟so加载到内存</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8A%A5%E9%94%99\"><span class=\"toc-text\">系统调用报错</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E5%BC%8F%E8%BF%90%E8%A1%8Cjni%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">正式运行jni函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">运行结果</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"unidbg反ollvm字符串混淆(二)","uid":"826b11e5304e0be8ab8c923b8486f9df","slug":"unidbg反ollvm字符串混淆-二","date":"2021-08-01T10:21:28.000Z","updated":"2021-08-01T10:31:42.498Z","comments":true,"path":"api/articles/unidbg反ollvm字符串混淆-二.json","keywords":null,"cover":"https://w.wallhaven.cc/full/kw/wallhaven-kwjd76.jpg","text":"前言有碰到过ollvm的字符串加密，很常见的特征就在于在init或者init array段里面会有很多字符串解密的函数，对抗的手法也是很多种的，加载内存dump，或者模拟执行patch掉，这里我选择使用模拟执行unidbg来hook出每次字符串解密写入的内存地址以及value 代...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"unidbg","slug":"unidbg","count":2,"path":"api/categories/unidbg.json"}],"tags":[{"name":"reverse","slug":"reverse","count":18,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"修改ro.debuggable的坑以及有效方式","uid":"0558c37e07e30bb941d09a486e640b0f","slug":"修改ro-debuggable的坑以及有效方式","date":"2021-07-28T07:33:43.000Z","updated":"2021-07-28T07:37:09.949Z","comments":true,"path":"api/articles/修改ro-debuggable的坑以及有效方式.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/57/5758y8.jpg","text":"有效方式 android8.1 pixel完美修改，然后mprop，以及xdebuggable，我都使用了，但是还是不行，建议用这个面具来搞，我是用卡刷的，github上下载，然后模块安装 https://github.com/Magisk-Modules-Repo/Magisk...","link":"","photos":[],"count_time":{"symbolsCount":174,"symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":9,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":18,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}