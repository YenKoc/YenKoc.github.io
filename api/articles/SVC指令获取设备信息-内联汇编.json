{"title":"SVC指令获取设备信息&内联汇编","uid":"90a1c6273d337dfc4b6067dd868be1ed","slug":"SVC指令获取设备信息-内联汇编","date":"2021-06-28T07:05:01.000Z","updated":"2021-06-28T15:41:55.182Z","comments":true,"path":"api/articles/SVC指令获取设备信息-内联汇编.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/rd/rdyyjm.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>目前越来越多的api，采用svc进行直接系统调用，syscall也不用了，直接内联汇编，然后svc，可以防止hook，不过最近在看雪也看到一篇修改内核的操作反操作的，之后打算再研究研究。</p>\n<h1 id=\"syscall\"><a href=\"#syscall\" class=\"headerlink\" title=\"syscall\"></a>syscall</h1><p>syscall可以说是系统层给用户层提供的一个调用内核态代码的api，我们使用open，read等函数，实际上最后也会调用到syscall这个系统调用函数，那么如果我们不去使用libc中的函数时，因为太容易被hook，那么我们是不是也可以同样实现它的底层函数，进而实现相同效果，同时还不容易被hook,实际上syscall底层还是调用svc进入内核态的，把libc.so从我的皮鞋上扒下来，ida反汇编看看。</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210628204029.png\"></p>\n<p>上面是f5的样子，实际上的汇编。</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210628204112.png\"></p>\n<p>所以根据这里，我们是不是可以模仿这种写法，自己构造底层函数，以防止被轻易hook，毕竟内核态的内存是不能动的。</p>\n<p>先导入一手头文件，讲道理发现有时候头文件没导全就很烦，所以干脆直接全部导入常用的，方便233</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;jni.h&gt;\n#include &lt;dlfcn.h&gt;\n#include &lt;android&#x2F;log.h&gt;\n#include &lt;malloc.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;regex&gt;\n#include &lt;bits&#x2F;getopt.h&gt;\n#include &lt;asm&#x2F;unistd.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;asm&#x2F;fcntl.h&gt;\n#include&lt;fcntl.h&gt;\n\n#include&lt;sys&#x2F;types.h&gt;\n#include&lt;sys&#x2F;stat.h&gt;\n\n#include &lt;unistd.h&gt;\n#include &lt;sys&#x2F;syscall.h&gt;\n#include &lt;sys&#x2F;types.h&gt;\n#include &lt;sys&#x2F;stat.h&gt;\n#include &lt;fcntl.h&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后我们自己自定义一个函数，</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210628222436.png\"></p>\n<p>这里有个坑点，就是如果不设置你编译的是几位的，那么参数是无法写__NT_open，编译会一直通不过，就设置就是在</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210628222640.png\"></p>\n<h1 id=\"ARM内联汇编\"><a href=\"#ARM内联汇编\" class=\"headerlink\" title=\"ARM内联汇编\"></a>ARM内联汇编</h1><p>沉思，发现很多syscall，为了防止被libc中直接hook，直接自己内嵌一个内联汇编了，就很不讲道理，自己实现一手，其实直接把ida中反汇编的汇编直接扒拉下来就好了，不过androidstudio还是需要设置一下的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">    .text\n    .global raw_syscall\n    .type raw_syscall,%function\n\nraw_syscall:\n        MOV             R12, SP\n        STMFD           SP!, &#123;R4-R7&#125;\n        MOV             R7, R0\n        MOV             R0, R1\n        MOV             R1, R2\n        MOV             R2, R3\n        LDMIA           R12, &#123;R3-R6&#125;\n        SVC             0\n        LDMFD           SP!, &#123;R4-R7&#125;\n        mov             pc, lr\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210628232839.png\"></p>\n<p>在cmakelist中也需要修改下，引入这个汇编文件</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210628232912.png\"></p>\n<p>直接调用这个函数就行</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210628233000.png\"></p>\n<p>和之前是一样的，没啥大问题</p>\n<p>ida反编译后，效果大概是这样的，还行</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210628233408.png\"></p>\n<p>继续跟下去，发现这个函数，和我在libc中反编译出的syscall是一样的，不过这里我已经不需要动态链接进去了，</p>\n<p>直接就是本地的，hh</p>\n<h1 id=\"其他参考\"><a href=\"#其他参考\" class=\"headerlink\" title=\"其他参考\"></a>其他参考</h1><p>内联汇编:<a href=\"https://blog.csdn.net/tidyjiang/article/details/52138598\">https://blog.csdn.net/tidyjiang/article/details/52138598</a></p>\n","feature":null,"text":"前言目前越来越多的api，采用svc进行直接系统调用，syscall也不用了，直接内联汇编，然后svc，可以防止hook，不过最近在看雪也看到一篇修改内核的操作反操作的，之后打算再研究研究。 syscallsyscall可以说是系统层给用户层提供的一个调用内核态代码的api，我们...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":10,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":21,"path":"api/tags/reverse.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#syscall\"><span class=\"toc-text\">syscall</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ARM%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96\"><span class=\"toc-text\">ARM内联汇编</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E5%8F%82%E8%80%83\"><span class=\"toc-text\">其他参考</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"Android锁机勒索病毒分析","uid":"4b0b858a57a6176d5e34068e8d18965f","slug":"Android锁机勒索病毒分析","date":"2021-06-29T03:54:43.000Z","updated":"2021-06-29T08:59:31.243Z","comments":true,"path":"api/articles/Android锁机勒索病毒分析.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/8o/8oev1j.jpg","text":"前言有一说一，我拉了，好几个模拟器运行这个apk，发现没啥特别的，静态分析一看，发现里面有su等一大堆的命令，mmp，所以说没root的话，一切免谈，不打算在真机上试，直接静态分析，嘿嘿 jeb静态分析开始从开始界面找起，因为这种恶意软件的启动肯定要有一个触发点，一般是在必经的地...","link":"","photos":[],"count_time":{"symbolsCount":938,"symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":10,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":21,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"2021强网杯wp","uid":"e711ae4763716495e69aa9bd1f61c2a8","slug":"2021强网杯wp","date":"2021-06-13T17:59:54.000Z","updated":"2021-06-15T08:38:16.032Z","comments":true,"path":"api/articles/2021强网杯wp.json","keywords":null,"cover":"https://img2.baidu.com/it/u=3566088443,3713209594&fm=26&fmt=auto&gp=0.jpg","text":"前言就看了两题安卓加一个timeago，太菜了呀，实属要退役的节奏了，一段时间没调，感觉水平无限下滑（。 ezmath这题不予评价了，感觉挺奇怪的，按道理来说idapython还是inline hook都是可以每两字节爆破出来的，但是精度损失的非常厉害，感觉是出题人机器和我们的不...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"writeup","slug":"writeup","count":8,"path":"api/categories/writeup.json"}],"tags":[{"name":"reverse","slug":"reverse","count":21,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}