{"title":"利用lief重构androidemu的loader","uid":"6fe260c9125d041c2eb579635ea7b945","slug":"利用lief重构androidemu的loader","date":"2021-09-07T08:41:49.000Z","updated":"2021-09-07T09:00:23.699Z","comments":true,"path":"api/articles/利用lief重构androidemu的loader.json","keywords":null,"cover":null,"content":"<p>先放一手代码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import ctypes\n\nUC_MEM_ALIGN &#x3D; 0x1000\n\nPF_X &#x3D; 0x1  # Executable\nPF_W &#x3D; 0x2  # Writable\nPF_R &#x3D; 0x4  # Readable\n\n\n# Thansk to https:&#x2F;&#x2F;github.com&#x2F;lunixbochs&#x2F;usercorn&#x2F;blob&#x2F;master&#x2F;go&#x2F;mem.go\ndef align(addr, size, growl):\n    to &#x3D; ctypes.c_uint64(UC_MEM_ALIGN).value\n    mask &#x3D; ctypes.c_uint64(0xFFFFFFFFFFFFFFFF).value ^ ctypes.c_uint64(to - 1).value\n    right &#x3D; addr + size\n    right &#x3D; (right + to - 1) &amp; mask\n    addr &amp;&#x3D; mask\n    size &#x3D; right - addr\n    if growl:\n        size &#x3D; (size + to - 1) &amp; mask\n    return addr, size\n\n\ndef get_segment_protection(prot_in):\n    prot &#x3D; 0\n\n    if prot_in &amp; PF_R is not 0:\n        prot |&#x3D; 1\n\n    if prot_in &amp; PF_W is not 0:\n        prot |&#x3D; 2\n\n    if prot_in &amp; PF_X is not 0:\n        prot |&#x3D; 4\n\n    return prot\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Module:\n    def __init__(self,filename,address,size,symbols_resolved,init_array&#x3D;[]):\n        self.filename&#x3D;filename\n        self.base&#x3D;address\n        self.size&#x3D;size\n        self.symbols&#x3D;symbols_resolved\n        self.symbol_lookup&#x3D;dict()\n        self.init_array&#x3D;list(init_array)\n\n        for symbol_name,symbol in self.symbols.items():\n            if symbol.address!&#x3D;0:\n                self.symbol_lookup[symbol.address]&#x3D;(symbol_name,symbol)\n    def find_symbol(self,name):\n        if name in self.symbols:\n            return self.symbols[name]\n        return None\n    def is_symbol_addr(self,addr):\n        if addr in self.symbol_lookup:\n            return self.symbol_lookup[addr][0]\n        else:\n            return None<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import lief\nfrom unicorn import *\nfrom unicorn.arm_const import *\nfrom capstone import *\nimport struct\nimport init\nclass SymbolResolved:\n    def __init__(self,address,symbol):\n        self.address&#x3D;address\n        self.symbol&#x3D;symbol\n\n\nclass Elfloader:\n    def __init__(self,mu):\n        self.emu&#x3D;mu\n        self.modules&#x3D;list()\n        self.symbol_collects&#x3D;dict()\n    def add_symbol_collect(self,symbol_name,address):\n        self.symbol_collects[symbol_name]&#x3D;address\n    def find_symbol(self,address):\n        for module in self.modules:\n            if address in module.symbol_lookup:\n                return module.symbol_lookup[address]\n        return None,None\n    def load_module(self,filename):\n        binary&#x3D;lief.parse(filename)\n        fstream&#x3D;open(filename,&quot;rb&quot;)\n        if binary.header.file_type!&#x3D;lief.ELF.E_TYPE.DYNAMIC:\n            raise NotImplementedError(&quot;Only ET_DYN is support at the moment.&quot;)\n\n        load_segments&#x3D;[x for x in binary.segments if x.type&#x3D;&#x3D;lief.ELF.SEGMENT_TYPES.LOAD]\n\n        bound_low&#x3D;0\n        bound_high&#x3D;0\n        for segment in load_segments:\n            if segment.virtual_size&#x3D;&#x3D;0:\n                continue\n            if bound_low&gt;segment.virtual_address:\n                bound_low&#x3D;segment.virtual_address\n            high&#x3D;segment.virtual_address+segment.virtual_size\n\n            if bound_high&lt;high:\n                bound_high&#x3D;high\n        load_base&#x3D;self.emu.memory.mem_reserve(bound_high-bound_low)\n\n        for segment in load_segments:\n            prot&#x3D;init.get_segment_protection(segment.flags)\n            prot&#x3D;prot if prot is not 0 else UC_PROT_ALL\n\n            self.emu.memory.mem_map(load_base+segment.virtual_address,segment.virtual_size,prot)\n            self.emu.memory.mem_write(load_base+segment.virtual_address,segment.content)\n        rel_section&#x3D;None\n        for section in binary.sections:\n            if section.type&#x3D;&#x3D;lief.ELF.SECTION_TYPES.REL:\n                rel_section&#x3D;section\n                break\n        dynsym&#x3D;binary.get_section(&quot;.dynsym&quot;)\n        dynsym&#x3D;binary.get_section(&quot;.dynstr&quot;)\n\n        init_array_size&#x3D;0\n        init_array_offset&#x3D;0\n        init_array&#x3D;[]\n        for x in binary.dynamic_entries:\n            if x.tag&#x3D;&#x3D;lief.ELF.DYNAMIC_TAGS.INIT_ARRAYSZ:\n                init_array_size&#x3D;x.value\n            if x.tag&#x3D;&#x3D;lief.ELF.DYNAMIC_TAGS.INIT_ARRAY:\n                init_array_offset&#x3D;x.value\n        for _ in range(int(init_array_size&#x2F;4)):\n            for seg in load_segments:\n                if seg.virtual_address&lt;&#x3D;init_array_offset&lt;seg.virtual_address+seg.virtual_size:\n                    init_array_foffset&#x3D;init_array_offset-seg.virtual_address+seg.file_offset\n            fstream.seek(init_array_foffset)\n            data&#x3D;fstream.read(4)\n            fun_ptr&#x3D;struct.unpack(&quot;I&quot;,data)[0]\n            if fun_ptr!&#x3D;0:\n                init_array.append(fun_ptr+load_base)\n            else:\n                for rel in binary.relocations:\n                    rel_info_type&#x3D;rel.type\n                    rel_addr&#x3D;rel.address\n                    if rel_info_type&#x3D;&#x3D;lief.ELF.RELOCATION_ARM.ABS32 and rel_addr&#x3D;&#x3D;init_array_offset:\n                        sym&#x3D;rel.symbol\n                        sym_value&#x3D;sym.value\n                        init_array.append(load_base+sym_value)\n            init_array_offset+&#x3D;4\n\n        symbols_resolved&#x3D;dict()\n        for symbol in binary.symbols:\n            symbol_address&#x3D;self._elf_get_symval(load_base,symbol)\n            if symbol_address is not None:\n                symbols_resolved[symbol.name]&#x3D;SymbolResolved(symbol_address,symbol)\n\n        #relocate\n        for relocation in binary.relocations:\n            sym&#x3D;relocation.symbol\n            sym_value&#x3D;sym.value\n\n            rel_addr&#x3D;load_base+relocation.address\n            rel_info_type&#x3D;relocation.type\n\n            if rel_info_type&#x3D;&#x3D;lief.ELF.RELOCATION_ARM.ABS32:\n                value&#x3D;load_base+sym_value\n                self.emu.mu.mem_write(rel_addr,value.to_byte(4,byteorder&#x3D;&#39;little&#39;))\n            elif rel_info_type&#x3D;&#x3D;lief.ELF.RELOCATION_ARM.GLOB_DAT or rel_info_type&#x3D;&#x3D;lief.ELF.RELOCATION_ARM.JUMP_SLOT or rel_info_type&#x3D;&#x3D;lief.ELF.RELOCATION_AARCH64.GLOB_DAT or rel_info_type&#x3D;&#x3D;lief.ELF.RELOCATION_AARCH64.JUMP_SLOT:\n                if sym.name in symbols_resolved:\n                    value&#x3D;symbols_resolved[sym.name].address\n\n                    self.emu.mu.mem_write(rel_addr,value.to_bytes(4,byteorder&#x3D;&#39;little&#39;))\n            elif rel_info_type&#x3D;&#x3D;lief.ELF.RELOCATION_ARM.RELATIVE or rel_info_type&#x3D;&#x3D;lief.ELF.RELOCATION_AARCH64.RELATIVE:\n                if sym_value&#x3D;&#x3D;0:\n                    value_orig_bytes&#x3D;self.emu.mu.mem_read(rel_addr,4)\n                    value_orig&#x3D;int.from_bytes(value_orig_bytes,byteorder&#x3D;&#39;little&#39;)\n\n                    value&#x3D;load_base+value_orig\n\n                    self.emu.mu.mem_write(rel_addr,value.to_bytes(4,byteorder&#x3D;&#39;little&#39;))\n                else:\n                    raise NotImplementedError()\n        module&#x3D;Module(filename,load_base,bound_high-bound_low,symbols_resolved,init_array)\n        self.modules.append(module)\n\n        return module\n\n\n    def _elf_get_symval(self,elf_base,symbol):\n        if symbol.name in self.symbol_collects:\n            return self.symbol_collects[symbol.name]\n        if symbol.shndx&#x3D;&#x3D;&#39;SHN_UNDEF&#39;:\n            target&#x3D;self._elf_lookup_symbol(symbol.name)\n            if target is None:\n                if symbol.binding&#x3D;&#x3D;lief.ELF.SYMBOL_BINDINGS.WEAK:\n                    return 0\n                else:\n                    return None\n            else:\n                return target\n        elif symbol.shndx&#x3D;&#x3D;&#39;SHN_ABS&#39;:\n            return elf_base+symbol.value\n        else:\n            return elf_base+symbol.value\n    def _elf_lookup_symbol(self,name):\n        for module in self.modules:\n            if name in module.symbols:\n                symbol&#x3D;module.symbols[name]\n                if symbol.address!&#x3D;0:\n                    return symbol.address\n\n\n\nmu&#x3D;Uc(UC_ARCH_ARM,UC_MODE_ARM)\nloader&#x3D;Elfloader(mu)\nloader.load_module(&quot;libnative-lib.so&quot;)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>过程大致描述下，看了两天了，基本摸清，差不多首先遍历segment表，将load的segment的加载进内存，然后将考虑到有些so的init和initarray段可能有初始化函数，这些函数也需要去重定位，利用lief直接拿到dymnaic数组，根据DT INIT_ARRAY得到init的位置和size，</p>\n<p>读取出偏移，这里然后加上我们的基地址，之后存入我们的初始化函数列表，如果偏移为0，说明需要重定位，遍历重定位对象，找到init的address的重定位地址，如果是ABS32，就将对应符号的地址，记载入重定位的地方，遍历符号，搜索其他模块的符号，填充我们模块的列表中，这点非常妙，牛逼，剩下就是便利重定位的地方，填充地址就完事了</p>\n","feature":null,"text":"先放一手代码 import ctypes UC_MEM_ALIGN &#x3D; 0x1000 PF_X &#x3D; 0x1 # Executable PF_W &#x3D; 0x2 # Writable PF_R &#x3D; 0x4 # Readable # Thansk ...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":22,"path":"api/tags/reverse.json"}],"toc":"","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{},"next_post":{"title":"利用unicorn实现一个小型调试器","uid":"e82fc54bd55d17936e1dc0d74228fd9d","slug":"利用unicorn实现一个小型调试器","date":"2021-09-04T07:56:58.000Z","updated":"2021-09-04T08:02:12.871Z","comments":true,"path":"api/articles/利用unicorn实现一个小型调试器.json","keywords":null,"cover":"https://th.wallhaven.cc/small/rd/rdyyjm.jpg","text":"代码实现已经写注释 from unicorn import * from unicorn.arm_const import * from capstone import * from pwn import * import hexdump class UnicornDebugge...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"unicorn","slug":"unicorn","count":2,"path":"api/categories/unicorn.json"}],"tags":[{"name":"reverse","slug":"reverse","count":22,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}