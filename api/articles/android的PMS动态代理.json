{"title":"android的PMS动态代理","uid":"668f1dbfd60678f860dbea390d6a69fb","slug":"android的PMS动态代理","date":"2021-07-02T06:26:47.000Z","updated":"2021-07-02T06:54:06.525Z","comments":true,"path":"api/articles/android的PMS动态代理.json","keywords":null,"cover":"https://th.wallhaven.cc/small/28/281d5y.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>目前在java层中签名验证是使用java层的api进行获取，然后进行判断，可以选择hook，也可以使用安卓本身的特性去hook，不使用任何hook框架去实现hook</p>\n<h1 id=\"代理是什么？\"><a href=\"#代理是什么？\" class=\"headerlink\" title=\"代理是什么？\"></a>代理是什么？</h1><p>结合我自己的理解来说，动态代理实际上就是比如你想找别人，但是你不自己去找，而是委托另一个人去找，把事情交给另一个人去办的，这里注意细节，就是当你把事情委托给别人的时候，别人会怎么去办这件事，你是管不着的，不需要你去管，他只需要把事情做完就行，至于diy些其他操作也是属于正常操作。</p>\n<p>用代码说明下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;共同实现的接口\npublic interface IHelloWorld &#123;\n    public void helloWorld(String str);\n&#125;\n \n&#x2F;&#x2F;真实对象\npublic class RealSubject implements IHelloWorld &#123;\n    @Override\n    public void helloWorld() &#123;\n        System.out.println(&quot;RealSubject say hello world&quot;);\n    &#125;\n&#125;\n \n&#x2F;&#x2F;代理对象\npublic class Proxy implements IHelloWorld &#123;    \n    private IHelloWorld subject;\n \n    public Proxy(IHelloWorld subject) &#123;\n        this.subject &#x3D; subject;\n    &#125;\n \n    @Override\n    public void helloWorld() &#123;\n        &#x2F;&#x2F;代理类的私货\n        System.out.println(&quot;Proxy say hello world&quot;);  \n     \n        &#x2F;&#x2F;被代理对象的真实调用\n        subject.helloWorld();\n    &#125;\n&#125;\n \n \n&#x2F;&#x2F;实际调用\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;被代理的对象\n    RealSubject realSubject &#x3D; new RealSubject();\n \n    &#x2F;&#x2F;代理类对象\n    Proxy proxy &#x3D; new Proxy(realSubject);\n \n    &#x2F;&#x2F;调用代理类对象的方法\n    proxySubject.helloWorld();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其实代码写的很清楚了，这是静态代理，我只是用这个举例，本来直接调用的不是很方便吗，为什么出现了一个代理，实际在代理对象中，我们可以搞的事情就很多了，可以在本来调用的方法中加入另外定制的代码，嘿嘿，加上一个是同一个接口，那么方法名都是一样的，实际上就是hook了。。</p>\n<h1 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h1><p>动态代理模式是和静态代理模式差不多，不过就是不在我们自己定义代理对象了，实现接口就可以自动生成动态代理对象，结合代码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Object proxy&#x3D; Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),new Class&lt;?&gt;[]&#123;iPackageManagerInterface&#125;,new PMSHookBinderInvocationHandler(sPackagerManager,signed,appPkgName,0));\n            sPackageManagerField.set(currentActivityThread,proxy);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>new PMS那行代码就是实现了InvocationHandler这个接口的，调用这个Proxy.newProxyInstance方法自动生成了代理对象，另外实现接口的那个类，实际上是彻底补充了代理对象的功能，也就是帮原对象实现功能，同时加入我们的hook代码，当这个代理对象执行方法时，会先跑到我们实现接口的那个对象中的invoke方法。</p>\n<h1 id=\"android里面的pms动态代理实现\"><a href=\"#android里面的pms动态代理实现\" class=\"headerlink\" title=\"android里面的pms动态代理实现\"></a>android里面的pms动态代理实现</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.example.puatest;\n\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.Signature;\nimport android.text.method.SingleLineTransformationMethod;\nimport android.util.Log;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class PMSHookBinderInvocationHandler implements InvocationHandler &#123;\n    private Object base;\n    public final static String yk&#x3D;&quot;YenKoc&quot;;\n\n    &#x2F;&#x2F;应用正确的签名信息\n    private String SIGN;\n    private String appPkgName&#x3D;&quot;&quot;;\n    public PMSHookBinderInvocationHandler(Object sPackagerManager, String signed, String appPkgName, int i) &#123;\n        try&#123;\n            this.base&#x3D;sPackagerManager;\n            this.SIGN&#x3D;signed;\n            this.appPkgName&#x3D;appPkgName;\n        &#125;catch (Exception e)\n        &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n            Log.i(&quot;YenKoc&quot;,&quot;调用了代理方法&quot;);\n        if(&quot;getPackageInfo&quot;.equals(method.getName()))&#123;\n            String pkgName&#x3D;(String)args[0];\n            Integer flag&#x3D;(Integer)args[1];\n            if(flag&#x3D;&#x3D; PackageManager.GET_SIGNATURES&amp;&amp;appPkgName.equals(pkgName))\n            &#123;\n                Signature sign&#x3D;new Signature(SIGN);\n                &#x2F;&#x2F;调用原来的方法\n                PackageInfo info&#x3D;(PackageInfo)method.invoke(base,args);\n                info.signatures[0]&#x3D;sign;\n                return info;\n            &#125;\n        &#125;\n        return method.invoke(base,args);\n    &#125;\n&#125;\n\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.example.puatest;\n\nimport android.content.Context;\nimport android.content.pm.PackageManager;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class ServiceManagerWrapper &#123;\n    public final static String yk&#x3D;&quot;YenKoc&quot;;\n\n    public static void hookPMS(Context context,String signed,String appPkgName,int hashcode)\n    &#123;\n        try&#123;\n            Class&lt;?&gt; activityThreadClass&#x3D;Class.forName(&quot;android.app.ActivityThread&quot;);\n            Method currentActivityThreadMethod&#x3D;activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);\n            Object currentActivityThread&#x3D;currentActivityThreadMethod.invoke(null);\n            &#x2F;&#x2F;获取ActivityThread里面原始sPackageManager\n            Field sPackageManagerField&#x3D;activityThreadClass.getDeclaredField(&quot;sPackageManager&quot;);\n            sPackageManagerField.setAccessible(true);\n            Object sPackagerManager&#x3D;sPackageManagerField.get(currentActivityThread);\n            &#x2F;&#x2F;准备好代理对象\n            Class&lt;?&gt; iPackageManagerInterface&#x3D;Class.forName(&quot;android.content.pm.IPackageManager&quot;);\n            Object proxy&#x3D; Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),new Class&lt;?&gt;[]&#123;iPackageManagerInterface&#125;,new PMSHookBinderInvocationHandler(sPackagerManager,signed,appPkgName,0));\n            sPackageManagerField.set(currentActivityThread,proxy);\n            &#x2F;&#x2F;替换applicationpackageManager里面的mPM对象\n            PackageManager pm&#x3D;context.getPackageManager();\n            Field mPmField&#x3D;pm.getClass().getField(&quot;mPM&quot;);\n            mPmField.setAccessible(true);\n            mPmField.set(pm,proxy);\n\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    public  static void hookPMS(Context base)\n    &#123;\n        String sigg&#x3D;&quot;12342355&quot;;\n        hookPMS(base,sigg,&quot;com.example.puatest&quot;,0);\n    &#125;\n\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.example.puatest;\n\nimport android.app.Application;\nimport android.content.Context;\nimport android.util.Log;\n\npublic class wrapApplication extends Application &#123;\n    @Override\n    protected void attachBaseContext(Context base) &#123;\n        Log.i(&quot;YenKoc&quot;,&quot;进入&quot;);\n        ServiceManagerWrapper.hookPMS(base);\n        super.attachBaseContext(base);\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","feature":null,"text":"前言目前在java层中签名验证是使用java层的api进行获取，然后进行判断，可以选择hook，也可以使用安卓本身的特性去hook，不使用任何hook框架去实现hook 代理是什么？结合我自己的理解来说，动态代理实际上就是比如你想找别人，但是你不自己去找，而是委托另一个人去找，把...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":5,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":14,"path":"api/tags/reverse.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">代理是什么？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">动态代理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#android%E9%87%8C%E9%9D%A2%E7%9A%84pms%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">android里面的pms动态代理实现</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{},"next_post":{"title":"Android锁机勒索病毒分析","uid":"4b0b858a57a6176d5e34068e8d18965f","slug":"Android锁机勒索病毒分析","date":"2021-06-29T03:54:43.000Z","updated":"2021-06-29T08:59:31.243Z","comments":true,"path":"api/articles/Android锁机勒索病毒分析.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/8o/8oev1j.jpg","text":"前言有一说一，我拉了，好几个模拟器运行这个apk，发现没啥特别的，静态分析一看，发现里面有su等一大堆的命令，mmp，所以说没root的话，一切免谈，不打算在真机上试，直接静态分析，嘿嘿 jeb静态分析开始从开始界面找起，因为这种恶意软件的启动肯定要有一个触发点，一般是在必经的地...","link":"","photos":[],"count_time":{"symbolsCount":938,"symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":5,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":14,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}