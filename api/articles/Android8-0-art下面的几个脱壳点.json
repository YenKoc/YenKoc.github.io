{"title":"Android8.0 art下面的几个脱壳点","uid":"05699e0b3c4e02c2136460838badc80b","slug":"Android8-0-art下面的几个脱壳点","date":"2021-06-11T16:10:05.000Z","updated":"2021-06-11T17:09:36.572Z","comments":true,"path":"api/articles/Android8-0-art下面的几个脱壳点.json","keywords":null,"cover":"https://w.wallhaven.cc/full/5w/wallhaven-5w3dm8.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>搞了一个17年decon 会议的ppt，里面对市面上的一些apk加固方式有一些整体分析，实际上手动脱壳，现在越来越难了，时间成本太大了，各种莫名的反调试和混淆，so的话，俺也不太会搞vmp，在学了在学了（我太菜了，java层的话，还是有突破口的，毕竟dex再怎么加固，最终还是要经过classloader，加载到内存中的，整体的dump下来，不过目前都是抽取壳，就算扒拉下来依旧是需要修复的（，这是fart解决的事</p>\n<h1 id=\"分析源码\"><a href=\"#分析源码\" class=\"headerlink\" title=\"分析源码\"></a>分析源码</h1><p>安卓8.0会有一个比较大的变动，多了一个inmemorydexclassloader，这个classloader支持不落地加载的，所以有些壳可能会选择这个classloader去加载dex，而不使用传统的dexclassloader，我们可以先跟一下两种dexclassloader的源码，然后作一个比较，如果找到交叉点的话，直接hook这个交叉点，不就可以实现通杀了。</p>\n<h2 id=\"DexClassLoader\"><a href=\"#DexClassLoader\" class=\"headerlink\" title=\"DexClassLoader\"></a>DexClassLoader</h2><p>前面一大堆跟的就不放了，太easy了，直接跟到上次玩热修复，没继续跟下去的地方。</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210612003148.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210612003223.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210612003302.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210612003436.png\"></p>\n<p>这里有个很明显的将dex转换为oat格式的函数，这里因为art中会先将dex转换oat格式，加快运行速度，</p>\n<p>我们继续跟进去，我们跟的目的就是找到dex加载到内存中的首地址和size。</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210612004658.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210612004745.png\"></p>\n<p>这里有点类似java反射的操作，反正就是调用了dex转换为oat格式的函数，这里涉及一个点就是目前的壳，一般都会采用禁用dex转换成oat的方式，所以我们的思路需要做一个转换，走另一个分支</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210612005350.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210612005826.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210612005953.png\"></p>\n<p>终于出现了我们想要的了，继续跟下去，多找几个点</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210612010035.png\"></p>\n<p>基本找到了，接着看另一个classloader</p>\n<h1 id=\"InmemoryClassLoader\"><a href=\"#InmemoryClassLoader\" class=\"headerlink\" title=\"InmemoryClassLoader\"></a>InmemoryClassLoader</h1><p>和上文基本一致的分析流程，不过分析到后面发现和上面的dexclassloader有了交叉点，也就是他们最终都会调用的函数openCommon和dexfile，那么我们直接hook这两个函数不就完事了</p>\n<h1 id=\"hook\"><a href=\"#hook\" class=\"headerlink\" title=\"hook\"></a>hook</h1><p>找到源码，开始hook，然后编译刷机</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210612010916.png\"></p>\n","feature":null,"text":"前言搞了一个17年decon 会议的ppt，里面对市面上的一些apk加固方式有一些整体分析，实际上手动脱壳，现在越来越难了，时间成本太大了，各种莫名的反调试和混淆，so的话，俺也不太会搞vmp，在学了在学了（我太菜了，java层的话，还是有突破口的，毕竟dex再怎么加固，最终还是...","link":"","photos":[],"count_time":{"symbolsCount":843,"symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"AndroidUnPacker","slug":"AndroidUnPacker","count":1,"path":"api/tags/AndroidUnPacker.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">分析源码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DexClassLoader\"><span class=\"toc-text\">DexClassLoader</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#InmemoryClassLoader\"><span class=\"toc-text\">InmemoryClassLoader</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#hook\"><span class=\"toc-text\">hook</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"2021强网杯wp","uid":"e711ae4763716495e69aa9bd1f61c2a8","slug":"2021强网杯wp","date":"2021-06-13T17:59:54.000Z","updated":"2021-06-15T08:38:16.032Z","comments":true,"path":"api/articles/2021强网杯wp.json","keywords":null,"cover":"https://img2.baidu.com/it/u=3566088443,3713209594&fm=26&fmt=auto&gp=0.jpg","text":"前言就看了两题安卓加一个timeago，太菜了呀，实属要退役的节奏了，一段时间没调，感觉水平无限下滑（。 ezmath这题不予评价了，感觉挺奇怪的，按道理来说idapython还是inline hook都是可以每两字节爆破出来的，但是精度损失的非常厉害，感觉是出题人机器和我们的不...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"writeup","slug":"writeup","count":8,"path":"api/categories/writeup.json"}],"tags":[{"name":"reverse","slug":"reverse","count":22,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"Android got hook","uid":"08f55e9615384c7275f59ed241f8ccbd","slug":"Android-got-hook","date":"2021-06-09T06:24:12.000Z","updated":"2021-06-10T07:37:53.107Z","comments":true,"path":"api/articles/Android-got-hook.json","keywords":null,"cover":"https://th.wallhaven.cc/small/6o/6od3px.jpg","text":"原理 核心原理就是查找程序头表中的动态segment，然后查看虚拟内存映射到哪个位置，也就是rva，可以直接去ida中查看偏移， 因为我发现ida去解析so文件的时候，是看segment表去解析的，所以ida直接就是一个起始地址为0的虚拟内存（，先去010查看这个段在哪，然后发现...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"got表hook","slug":"got表hook","count":1,"path":"api/tags/got表hook.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}