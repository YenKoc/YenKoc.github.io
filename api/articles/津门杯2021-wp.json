{"title":"津门杯2021 wp","uid":"5f3262e9c2aa5e7df63089bc650eb7bf","slug":"津门杯2021-wp","date":"2021-05-10T02:48:37.000Z","updated":"2021-05-10T08:16:33.413Z","comments":true,"path":"api/articles/津门杯2021-wp.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/72/72jwp3.jpg","content":"<h1 id=\"mobile\"><a href=\"#mobile\" class=\"headerlink\" title=\"mobile\"></a>mobile</h1><p>加了360的壳子，frida-dexdump，脱下来就完事了，发现没native层, 好家伙，纯java呗），找到关键的dex开始审计</p>\n<p>，找到了两段逻辑，一段是加密的，一段是解密的，大概逆了一下，发现这题有两种做法，一种是白嫖解密接口，把给出的数据，通过替换xml，txt，db文件，再hook输入就可以直接实现傻瓜式解密，另一种就是本地复现加密接口，然后直接逆向解密。</p>\n<h2 id=\"1-正向的操作\"><a href=\"#1-正向的操作\" class=\"headerlink\" title=\"1.正向的操作\"></a>1.正向的操作</h2><p>先看下代码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public void i() throws NoSuchPaddingException, InvalidKeyException, NoSuchAlgorithmException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException, InvalidKeySpecException, CertificateException, UnrecoverableEntryException, KeyStoreException, NoSuchProviderException, IOException &#123;\n      String v0 &#x3D; this.f0.getText().toString(); &#x2F;&#x2F;取出data\n      String v1 &#x3D; this.e0.getText().toString(); &#x2F;&#x2F;取出key\n      this.d0 &#x3D; v1;\n      int v2 &#x3D; 0;\n      if((v1.equals(&quot;&quot;) | v0.equals(&quot;&quot;)) !&#x3D; 0) &#123;  &#x2F;&#x2F;不为空\n          Toast.makeText(StubApp.getOrigApplicationContext(this.getApplicationContext()), &quot;The user password or data is null, please check!&quot;, 0).show();\n          return;\n      &#125;\n\n      new a(this);\n      String v1_1 &#x3D; this.d0;\n      if(a.b &#x3D;&#x3D; 0) &#123;\n          a.a &#x3D; new SecureRandom().generateSeed(8);  &#x2F;&#x2F;这里生成了一个随机数种子\n          a.b &#x3D; 10;\n      &#125;\n\n      BigInteger v3 &#x3D; new BigInteger(a.a); &#x2F;&#x2F;生成了一个大整数\n      Key v1_2 &#x3D; a.a(v1_1); &#x2F;&#x2F;以前面生成的种子，生成一个key\n      Cipher v4 &#x3D; Cipher.getInstance(&quot;PBEWITHSHA256AND128BITAES-CBC-BC&quot;);\n      v4.init(1, v1_2);\n      String v1_3 &#x3D; new String(Base64.encode(v4.doFinal(v0.getBytes()), 1)); &#x2F;&#x2F;先aes加密，然后base64\n      --a.b;\n      this.k0 &#x3D; v3 + &quot;_&quot; + v1_3;  &#x2F;&#x2F;flag加密成 随机数种子大整数+下划线+aes加base64加密后的数据\n      TextView v0_1 &#x3D; this.g0;\n      StringBuilder v1_4 &#x3D; c.a.a.a.a.a(&quot;The flag is encrypted!\\n&quot;);\n      v1_4.append(this.k0);\n      v1_4.append(&quot;\\n&quot;);\n      v0_1.setText(v1_4.toString());\n      Log.i(&quot;KeyDistribution:&quot;, &quot;encString:&quot; + this.k0);\n      if(this.k0 &#x3D;&#x3D; null) &#123;\n          Toast.makeText(StubApp.getOrigApplicationContext(this.getApplicationContext()), &quot;Encryption failed！！&quot;, 0).show();\n      &#125;\n      else &#123;\n          Toast.makeText(StubApp.getOrigApplicationContext(this.getApplicationContext()), &quot;Encrypted successfully！\\n&quot;, 0).show();\n      &#125;\n\n      b v0_2 &#x3D; new b(this); &#x2F;&#x2F;创建一个本地的sqllite数据库\n      this.h0.setLength(0);\n      this.i0.setLength(0);\n      this.j0 &#x3D; null;\n      v0_2.Q &#x3D; this.d0; &#x2F;&#x2F;一开始输入的key\n      SecureRandom v6 &#x3D; new SecureRandom();\n      BigInteger[] v8 &#x3D; new BigInteger[3]; &#x2F;&#x2F;创建了一个大数的数组\n      int v9;\n      for(v9 &#x3D; 0; v9 &lt; 3; ++v9) &#123;\n          v8[v9] &#x3D; new BigInteger(0x20, v6);  生成了三个随机大整数\n          Log.i(&quot;upDateR:&quot;, v8[v9].toString());\n      &#125;\n\n      v0_2.P &#x3D; v8;\n      SecureRandom v6_1 &#x3D; new SecureRandom();\n      ArrayList v8_1 &#x3D; new ArrayList();\n      while(v8_1.size() &lt; 7) &#123;\n          BigInteger v9_1 &#x3D; new BigInteger(16, v6_1); 生成了7个随机大整数\n          if(!v8_1.contains(v9_1)) &#123;\n              v8_1.add(v9_1);\n          &#125;\n\n          Log.i(&quot;upDateX:&quot;, v8_1.toString());\n      &#125;\n\n      v0_2.R &#x3D; v8_1;\n      this.g0.append(&quot;Random numbers R and X have been successfully generated！\\n&quot;);\n      BigInteger v8_2 &#x3D; new BigInteger(v0_2.Q.getBytes()); &#x2F;&#x2F;key转换成大整数\n      BigInteger[] v6_2 &#x3D; new BigInteger[7];\n      int v9_2;\n      for(v9_2 &#x3D; 0; v9_2 &lt; 7; ++v9_2) &#123;\n          v6_2[v9_2] &#x3D; v8_2.add(v0_2.P[0].multiply(((BigInteger)v0_2.R.get(v9_2))).add(v0_2.P[1].multiply(((BigInteger)v0_2.R.get(v9_2)).pow(2))).add(v0_2.P[2].multiply(((BigInteger)v0_2.R.get(v9_2)).pow(3)))); &#x2F;&#x2F;这里有个计算，然后把值算出来，其实就是给出文件的下划线的后半段\n      &#125;\n\n      List v8_3 &#x3D; v0_2.R;\n      String[] v9_3 &#x3D; new String[7];\n      int v12;\n      for(v12 &#x3D; 0; v12 &lt; 7; ++v12) &#123;\n          v9_3[v12] &#x3D; ((BigInteger)v8_3.get(v12)).toString() + &quot;_&quot; + v6_2[v12].toString(); &#x2F;&#x2F;存放各个文件中的值，前半段就是v8_3的值，\n          StringBuilder v13 &#x3D; c.a.a.a.a.a(&quot;formatShareKey:&quot;);\n          v13.append(v9_3[v12]);\n          Log.i(&quot;KeyDistribution:&quot;, v13.toString());\n      &#125;\n\t&#x2F;&#x2F;下面就是数据存放到文件里就行\n      v0_2.S &#x3D; v9_3;\n      SharedPreferences.Editor v3_1 &#x3D; v0_2.T.getSharedPreferences(&quot;shareKeys&quot;, 0).edit();\n      v3_1.putString(&quot;key1&quot;, v0_2.S[0]);\n      v3_1.putString(&quot;key2&quot;, v0_2.S[1]);\n      v3_1.putString(&quot;key3&quot;, v0_2.S[2]);\n      v3_1.apply();\n      Log.i(&quot;KeyDistribution:&quot;, &quot;SharedPreferences store 3keys success! &quot;);\n      FileOutputStream v3_2 &#x3D; v0_2.T.openFileOutput(&quot;shareKeys.txt&quot;, 0);\n      v3_2.write(v0_2.S[3].getBytes());\n      v3_2.write(&quot;\\n&quot;.getBytes());\n      v3_2.write(v0_2.S[4].getBytes());\n      v3_2.close();\n      Log.i(&quot;KeyDistribution:&quot;, &quot;file store 2keys success! &quot;);\n      SQLiteDatabase v3_3 &#x3D; new b(v0_2.T).getWritableDatabase();\n      v0_2.onCreate(v3_3);\n      v3_3.execSQL(&quot;insert into shareKey(keyStr) values(\\&quot;&quot; + v0_2.S[5] + &quot;\\&quot;)&quot;);\n      v3_3.execSQL(&quot;insert into shareKey(keyStr) values(\\&quot;&quot; + v0_2.S[6] + &quot;\\&quot;)&quot;);\n      Log.i(&quot;KeyDistribution:&quot;, &quot;database store 2keys success! &quot;);\n      while(v2 &lt; 7) &#123;\n          StringBuilder v0_3 &#x3D; this.h0;\n          v0_3.append(&quot;output&quot;);\n          int v1_5 &#x3D; v2 + 1;\n          v0_3.append(v1_5);\n          v0_3.append(&quot;: &quot;);\n          v0_3.append(v9_3[v2]);\n          v0_3.append(&quot;\\n&quot;);\n          v2 &#x3D; v1_5;\n      &#125;\n  &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>仔细发现，这玩意核心还是在于找出key对吧，毕竟aes 对称加密，拿到key就可以解密，在后面的解密函数也有体现，这一大堆数据，在经过shit的计算，发现最终把key还原出来的，这也就是为什么后面白嫖接口是没毛病的，那么这里我们只需要去解方程，7个方程，解4个未知数，绰绰有余，解方程，z3必须得安排一手，我发现z3这东西是真好用，尤其是那种不可逆的，用方程约束解，是真的香。贴下exp</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from z3 import *\nfrom Crypto.Util.number import long_to_bytes\n&#39;&#39;&#39;encString:-7821488970927517137_qaoNj5jP05riAKvxmIju6o3tg90BdCcAlBkGtP&#x2F;x4rlJGUtVwBJY+5LlhPO3YRjP\n\noutput1:8885_37582432166857160353847123081\noutput2:9640_37582432426358548450758074236\noutput3:24762_37582451494960253781775215346\noutput4:51615_37582614757994549493283390711\noutput5:31533_37582473078165981182199222865\noutput6:63809_37582777982366357470099779581\noutput7:3560_37582431290919704469684029756&#39;&#39;&#39;\nt&#x3D;[8885,9640,24762,51615,31533,63809,3560]\ncmp_data&#x3D;[37582432166857160353847123081,37582432426358548450758074236,37582451494960253781775215346,37582614757994549493283390711,37582473078165981182199222865,37582777982366357470099779581,37582431290919704469684029756]\ns&#x3D;Solver()\nkey&#x3D;Int(&#39;key&#39;)\nv8_3&#x3D;[Int(&#39;v%d&#39;% i) for i in range(3)]\nfor i in range(7):\n    s.add(key+v8_3[0]*t[i]+v8_3[1]*t[i]**2+v8_3[2]*t[i]**3&#x3D;&#x3D;cmp_data[i])\nif s.check()&#x3D;&#x3D;sat:\n    print(s.model())\n    key &#x3D; s.model()[key].as_long()\n    print long_to_bytes(key)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.example.jm;\n\nimport androidx.appcompat.app.AppCompatActivity;\n\nimport android.content.Context;\nimport android.os.Bundle;\nimport android.util.Base64;\nimport android.widget.TextView;\n\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.spec.InvalidKeySpecException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\n\npublic class MainActivity extends AppCompatActivity &#123;\n\n    TextView textView;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) &#123;\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        textView&#x3D;findViewById(R.id.text1);\n        try &#123;\n            textView.setText(check());\n        &#125; catch (BadPaddingException e) &#123;\n            e.printStackTrace();\n        &#125; catch (IllegalBlockSizeException e) &#123;\n            e.printStackTrace();\n        &#125; catch (NoSuchPaddingException e) &#123;\n            e.printStackTrace();\n        &#125; catch (NoSuchAlgorithmException e) &#123;\n            e.printStackTrace();\n        &#125; catch (InvalidKeySpecException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    public String check() throws BadPaddingException, IllegalBlockSizeException, NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeySpecException &#123;\n        a.a &#x3D; new BigInteger(&quot;-7821488970927517137&quot;).toByteArray();\n        String v3_5&#x3D;&quot;qaoNj5jP05riAKvxmIju6o3tg90BdCcAlBkGtP&#x2F;x4rlJGUtVwBJY+5LlhPO3YRjP&quot;;\n        byte[] v1_1 &#x3D; Base64.decode(v3_5, 2);\n        Key v2_6 &#x3D; a.a(&quot;you_are_good&quot;);\n        Cipher v3_6 &#x3D; Cipher.getInstance(&quot;PBEWITHSHA256AND128BITAES-CBC-BC&quot;);\n        try &#123;\n            v3_6.init(2, v2_6);\n        &#125; catch (InvalidKeyException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return new String(v3_6.doFinal(v1_1));\n    &#125;\n\n&#125;\n&#x2F;* class a &#123;\n    public static byte[] a &#x3D; null;\n    public static int b &#x3D; 10;\n\n    public a(Context arg2) &#123;\n        this.a &#x3D; new SecureRandom().generateSeed(8);\n    &#125;\n\n    public static Key a(String arg4) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;\n        PBEKeySpec v0 &#x3D; new PBEKeySpec(arg4.toCharArray(), a, 10000, 0x80);\n        return SecretKeyFactory.getInstance(&quot;PBEWITHSHA256AND128BITAES-CBC-BC&quot;).generateSecret(v0);\n    &#125;\n&#125;\n*&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.example.jm;\n\nimport android.content.Context;\n\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.spec.InvalidKeySpecException;\n\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\n\npublic class a &#123;\n\n    public static byte[] a &#x3D; null;\n    public static int b &#x3D; 10;\n\n    public a(Context arg2) &#123;\n        this.a &#x3D; new SecureRandom().generateSeed(8);\n    &#125;\n\n    public static Key a(String arg4) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;\n        PBEKeySpec v0 &#x3D; new PBEKeySpec(arg4.toCharArray(), a, 10000, 0x80);\n        return SecretKeyFactory.getInstance(&quot;PBEWITHSHA256AND128BITAES-CBC-BC&quot;).generateSecret(v0);\n    &#125;\n&#125;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210510132325.png\"></p>\n<h1 id=\"re\"><a href=\"#re\" class=\"headerlink\" title=\"re\"></a>re</h1><h2 id=\"1-easyre\"><a href=\"#1-easyre\" class=\"headerlink\" title=\"1. easyre\"></a>1. easyre</h2><p>就不放图了，出题人故意修改了elf文件的字段值，导致无法运行，尝试修改oep，发现还有段错误，所以就放弃了，群里大哥聊到和sctf的一题算法一样，找到了链接，然后发现这道题根本就是sctf orz的缩小版，把des加密的部分去掉了，所以连exp都是可以白嫖的，不过还有一个lua程序，发现是先解密，然后在后面程序中调用了这个算法，所以我们的exp还需要微调一下，直接从指纹爷那里嫖一手exp，魔改一下，然后记得约束还要确保是ascii码，否则跑出来就是乱码,z3绝对是一个爆破好手，最终转化成等式就可以开始乱杀）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from z3 import *\n\ndest_enc&#x3D;[0x005B3600, 0x000000CB, 0x005B3422, 0x0000025D, 0x005B38EA, 0x00000F5B, 0x005B34F0, 0x00000057, 0x005B372A, 0x00000504, 0x005B3429, 0x00001365, 0x005B2542, 0x00000293, 0x005B35EA, 0x00000D6E, 0x005B3B2B, 0x00000697, 0x005B4282, 0x00000941, 0x005B33F9, 0x0000772B, 0x005B2839, 0x00000D8A, 0x005B3CFE, 0x00000861, 0x005B28BC, 0x00007710, 0x005B1224, 0x0000326E, 0x005B26AC, 0x00001DE8]\nfrom Crypto.Cipher import DES\nimport struct\nimport time\n\n\ndef Z3(xor_data, cmp_data):\n    s&#x3D;Solver()\n\n    flag &#x3D; [BitVec((&#39;x%d&#39; % i), 8) for i in range(32)]\n    xor_result &#x3D; [0 for i in range(64)]\n    for i in range(32):\n        for j in range(33):\n            a &#x3D; flag[i] ^ xor_data[j]\n            xor_result[i + j] +&#x3D; a\n            xor_result[i+j]&#x3D;(xor_result[i+j]^5977654)\n\n    for i in range(0, 32):\n        s.add(flag[i]&lt;&#x3D;127)\n        s.add(flag[i]&gt;&#x3D;32)\n        s.add(xor_result[i] &#x3D;&#x3D; cmp_data[i])\n\n    if s.check() &#x3D;&#x3D; sat:\n        model &#x3D; s.model()\n        str &#x3D; [chr(model[flag[i]].as_long().real) for i in range(32)]\n        print(&quot;&quot;.join(str))\n        time.sleep(5)\n        exit()\n    else:\n        print(&quot;unsat&quot;)\n\ndef myrandint( start,end,seed):\n    a&#x3D;32310901\n    b&#x3D;1729\n    rOld&#x3D;seed\n    m&#x3D;end-start\n    while True:\n        rNew&#x3D;int((a*rOld+b)%m)\n        yield rNew\n        rOld &#x3D; rNew\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n\n    for seed in range(0xfff):\n        xor_data &#x3D; []\n        # r &#x3D; myrandint(1, 255, 99)\n        r &#x3D; myrandint(1, 255, seed)\n        for i in range(33):\n            xor_data.append(next(r))\n        # r &#x3D; myrandint(1, 255, 99)\n\n        Z3(xor_data, dest_enc)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"2-GOODRE\"><a href=\"#2-GOODRE\" class=\"headerlink\" title=\"2.  GOODRE\"></a>2.  GOODRE</h2><p>这题算比较easy一点的，重点在于要动调，多逆，静态分析有时候头晕的话，动调看汇编，很快会走出去困局，直接看注释吧</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210510161405.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210510161500.png\"></p>\n<p>很明显的tea加密，就不多bb了，一个是tea常数，特别注意就是密钥是硬编码的，要自己根据算法流程去找就行了，其他没什么好说的</p>\n","feature":null,"text":"mobile加了360的壳子，frida-dexdump，脱下来就完事了，发现没native层, 好家伙，纯java呗），找到关键的dex开始审计 ，找到了两段逻辑，一段是加密的，一段是解密的，大概逆了一下，发现这题有两种做法，一种是白嫖解密接口，把给出的数据，通过替换xml，t...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"writeup","slug":"writeup","count":8,"path":"api/categories/writeup.json"}],"tags":[{"name":"reverse","slug":"reverse","count":14,"path":"api/tags/reverse.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#mobile\"><span class=\"toc-text\">mobile</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%AD%A3%E5%90%91%E7%9A%84%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">1.正向的操作</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#re\"><span class=\"toc-text\">re</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-easyre\"><span class=\"toc-text\">1. easyre</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-GOODRE\"><span class=\"toc-text\">2.  GOODRE</span></a></li></ol></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"看雪ctf 第二题 南冥神功","uid":"43f61f74963677e07981d8eac779d6cf","slug":"看雪ctf-第二题-南冥神功","date":"2021-05-12T02:44:04.000Z","updated":"2021-05-12T02:44:30.770Z","comments":true,"path":"api/articles/看雪ctf-第二题-南冥神功.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"记录下修改smail的骚操作以及如何重打包","uid":"65a729b015fbeb895e9e3c25a8f4953e","slug":"记录下修改smail的骚操作以及如何重打包","date":"2021-05-06T09:20:45.000Z","updated":"2021-05-06T14:15:09.666Z","comments":true,"path":"api/articles/记录下修改smail的骚操作以及如何重打包.json","keywords":null,"cover":"https://w.wallhaven.cc/full/6o/wallhaven-6olw9x.jpg","text":"前言在被各种的重打包工具折磨之后，群里大佬推荐我看看珍惜哥的视频学学，这肯定得冲了呀，看了一小时，看完了，感觉学到一点骚操作，挺好玩的，就记录下 smail的修改在patch java层的时候，我们通常是去反编译apk，然后去修改smail，之后再重新编译打包签名，得把几个过程分...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"安卓小技巧","slug":"安卓小技巧","count":1,"path":"api/categories/安卓小技巧.json"}],"tags":[{"name":"reverse","slug":"reverse","count":14,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}