{"title":"mrctf的游戏逆向","uid":"99d6abf837e88eebd0687f5f9fc4ecea","slug":"mrctf的游戏逆向","date":"2021-05-24T05:57:54.000Z","updated":"2021-05-25T23:45:20.353Z","comments":true,"path":"api/articles/mrctf的游戏逆向.json","keywords":null,"cover":"https://th.wallhaven.cc/small/z8/z887yw.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>之前ctf中的游戏逆向都是比较直接，都是dnspy然后搜索关键字，然后开始逆向的，比较简单些，这题的话和其他的游戏题还是有很大的不同的，昂哥出的题确实有质量，后续的官方wp中也有昂哥用dll注入，直接破掉的操作，先看几题，常规的题，之后再与这题进行一个对比。</p>\n<h1 id=\"BJD-hamburger-competition\"><a href=\"#BJD-hamburger-competition\" class=\"headerlink\" title=\"BJD hamburger competition\"></a>BJD hamburger competition</h1><p>这题挺有节目效果的，老八奥力给</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524142602.png\"></p>\n<p>估计就是我们选择正确的食物组合，然后才能getflag，一看就是unity3d的游戏，还有mono的运行库，很明显了</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524142821.png\"></p>\n<p>因为c#都编译到Assembly-CSharp.dll中去了，所以我们入手点在这个文件中，dnspy安排上</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524143038.png\"></p>\n<p>先通过搜索字符串，定位一下核心逻辑</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524143228.png\"></p>\n<p>直接搜到了核心逻辑了，我们看下逻辑，看看要怎么逆</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524143406.png\"></p>\n<p>发现逻辑其实很简单，和之前猜想的一样，就是不同食材的组合，不同食材对应的不同分数，恰好组合才可以getflag，发现是除了汉堡顶和底，7种食物要选4种，直接爆破所有情况，不过也有非预期解，就是直接sha1解开</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import hashlib\ndef enc(a):\n    tmp&#x3D;997\n    for i in a:\n        if i&#x3D;&#x3D;1:\n            tmp-&#x3D;127\n        elif i&#x3D;&#x3D;2:\n            tmp*&#x3D;3\n        elif i&#x3D;&#x3D;3:\n            tmp^&#x3D;18\n        elif i&#x3D;&#x3D;4:\n            tmp+&#x3D;29\n        elif i&#x3D;&#x3D;5:\n            tmp-&#x3D;47\n        elif i&#x3D;&#x3D;6:\n            tmp*&#x3D;5\n        elif i&#x3D;&#x3D;7:\n            tmp^&#x3D;87\n    tmp^&#x3D;127\n    return str(tmp)\nindex&#x3D;[1,2,3,4,5,6,7]\nres&#x3D;[]\nfor yk1 in index:\n    for yk2 in index:\n        for yk3 in index:\n            for yk4 in index:\n                res.append(yk1)\n                res.append(yk2)\n                res.append(yk3)\n                res.append(yk4)\n                t&#x3D;enc(res).encode(&quot;utf-8&quot;)\n                if (hashlib.sha1(t).hexdigest().upper()&#x3D;&#x3D;&quot;DD01903921EA24941C26A48F2CEC24E0BB0E8CC7&quot;):\n                    print t\n                res&#x3D;[]\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"MRCTF-EZ-GAME\"><a href=\"#MRCTF-EZ-GAME\" class=\"headerlink\" title=\"MRCTF EZ_GAME\"></a>MRCTF EZ_GAME</h1><p>这题有两种做法，一种是骚操作，一种就是正常的思路，dll注入</p>\n<p>先重温下骚操作，不得不说，现在的骚操作确实猛且骚，哈哈哈</p>\n<p>第一步先打开文件夹，看下这个程序的架构，一看就是unity，但是现在unity还有icpp，为了提高运行速度，所以需要去识别的下，</p>\n<p>发现就是I2cpp的</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524181254.png\"></p>\n<p>然后出题人有点狠，直接加的是themida的壳，不讲武德！，这种题i2cpp还是有现成的工具去查看一些类信息的，不过通过类信息去定位核心逻辑，估计是凉了，毕竟加了强壳，不过还是可以对我们的分析起到很关键的地方的，这个工具叫II2CppDumper，放下github链接. <a href=\"https://github.com/Perfare/Il2CppDumper%EF%BC%8C%E8%AE%B0%E5%BE%97%E7%9B%B4%E6%8E%A5%E4%B8%8B%E7%BC%96%E8%AF%91%E5%A5%BD%E7%9A%84\">https://github.com/Perfare/Il2CppDumper，记得直接下编译好的</a></p>\n<p>用法如下:</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524195928.png\"></p>\n<p>然后在生成的Dumpdll文件夹下面找到Assemable文件，拖入dnspy，可以查看一些类信息和定义</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524200324.png\"></p>\n<p>可以发现这题无法用ce搞出来，因为发现不仅仅是数量修改了，就完事了，因为这个key的update是要根据吃的星星，每吃一个，计算一次，也就是必须吃满105个星星，update了105次，才是正确的key，这点我们可以用ce做一个验证,哦对，本来这些信息的rva，我们可以利用这个偏移，直接打开ida去看的，然而加了壳，你懂的，难顶。</p>\n<h2 id=\"ce的操作\"><a href=\"#ce的操作\" class=\"headerlink\" title=\"ce的操作\"></a>ce的操作</h2><p>先打开ce，我这里用的是风叶人的加强版，确实🐂，对结构体以及类这块有加强，挺香的，我们先吃几个星星，然后开始内存搜索，看看是哪里在修改</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524202808.png\"></p>\n<p>发现什么问题呢，后面的八个字节一直在变动，然后我标注的地方就是之前我们死亡的次数，这个结构是可以完全对应上之前我们用工具搞出来的类定义的信息的，</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524203201.png\"></p>\n<p>ok的，那也就是说我们的猜想是没有问题的，那么我们要如何去找到这个updatekey的地方呢，ce有这个功能去跟踪是哪里改写了这个地址，方便我们更快的找到核心逻辑，这个强壳，有些反调试，所以需要去设置下ce</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524204147.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524204229.png\"></p>\n<p>会弹出旁边的那个窗，不管它，再去吃钻石，去触发这个内存断点（我估计就是下了一个内存访问的断点）,发现成功触发了</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524204437.png\"></p>\n<p>这里可以选择直接撸汇编，不过太麻烦了，所以还是选择从内存中dump下来，然后ida打开，阅读伪代码好一些</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524210142.png\"></p>\n<p>直接火绒剑安排上，把内存先dump下来</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524210305.png\"></p>\n<p>用ida打开之后，有些结构被打乱了，所以需要我们手动去找函数头</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524220701.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524220638.png\"></p>\n<p>把初始的值拿出来，然后本地复现加密算法，再填充回ce就可以直接拿到flag了，冲</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;cstdio&gt;\n#include &quot;defs.h&quot;\nvoid calc(__int64* key)\n&#123;\n    for (int i &#x3D; 0; i &lt; 4; i++)\n    &#123;\n        __int64 k &#x3D; 1, l &#x3D; 0;\n        for (__int64 j &#x3D; 0; j &lt; 64; j++)\n        &#123;      \n            l ^&#x3D; (unsigned __int64)(k &amp; *key) &gt;&gt; (j &amp; 0x3F);\n            k &#x3D; __ROL8__(k, 1);\n        &#125;\n        *key &#x3D; l | (2 * *key);\n    &#125;\n&#125;\n\nint main()\n&#123;\n    __int64 key &#x3D; 0xDEADBEEFAA114514;\n    for (int i &#x3D; 0; i &lt; 105; i++)\n        calc(&amp;key);\n    printf(&quot;0x%llX&quot;, key);\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>拿到最终的key，然后就是重新启动游戏，直接填充数据，0xEA8451453BD5B7DD, 把对应偏移的内存地址的值都填上，就能拿到flag了</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524222205.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210524222137.png\"></p>\n<h1 id=\"DLL注入\"><a href=\"#DLL注入\" class=\"headerlink\" title=\"DLL注入\"></a>DLL注入</h1><p>利用i2cpp导出的函数，然后可以利用这些导出函数类似反射的功能，又因为我们把dll注入进去了，也是同一个进程了，所以我们去使用这个函数是全局的，绝对有影响的</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210525115027.png\"></p>\n<p>以上就是大致的导出函数，然后利用 GetProcAddress(dll_name,api_name)，获取每个导出函数的地址，然后把每个api的地址都存放到一个数据结构里面的，核心逻辑是这样的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void getclass(PTR clazz,void *data)\n&#123;\n    char *str&#x3D;(char*)il2cpp_class_get_name(clazz);\n    if(!strcmp(str,&quot;GetFlag&quot;))\n    &#123;\n        \n        void *iter&#x3D;0;\n        PTR method&#x3D;NULL;\n        do \n        &#123;\n            method&#x3D;il2cpp_class_get_methods(clazz,&amp;iter);\n            char *name&#x3D;il2cpp_method_get_name(method);\n            \n            if(!strcmp(name,&quot;EatTokenUpdateKey&quot;))\n            &#123;\n                MessageBoxA(NULL,name,name,NULL);\n                PTR eatCookie&#x3D;il2cpp_class_get_field_from_name(clazz,&quot;eatCookie&quot;);\n                PTR goHome&#x3D;il2cpp_class_get_field_from_name(clazz,&quot;goHome&quot;);\n                PTR findAlien&#x3D;il2cpp_class_get_field_from_name(clazz,&quot;findAlien&quot;);\n                bool b&#x3D;true;\n                PTR b_ptr&#x3D;(PTR)&amp;b;\n                il2cpp_field_static_set_value(eatCookie,b_ptr);\n                il2cpp_field_static_set_value(goHome,b_ptr);\n                il2cpp_field_static_set_value(findAlien,b_ptr);\n                PTR o&#x3D;NULL;\n                PTR objs[1]&#x3D;&#123;NULL&#125;;\n                for(int i&#x3D;0;i&lt;105;i++)\n                    il2cpp_runtime_invoke(method,(PTR)&amp;o,objs);\n                return;\n            &#125;\n        &#125;while(method!&#x3D;NULL);\n        \n    &#125;\n    \n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后至于为什么dll注入之后，就会启动某个函数的呢，这个我也是查了很多资料，发现每个DLL都有一个入口点函数，系统会在不同时刻进行调用这个函数，比如这里,就是注入的dll的函数入口点，</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">BOOL APIENTRY DllMain(HMODULE hModule,DWORD  ul_reason_for_call,LPVOID lpReserved)\n&#123;\n    \n    switch (ul_reason_for_call)\n    &#123;\n        case DLL_PROCESS_ATTACH:\n            FillFunctionTable();\n            il2cpp_class_for_each(getclass,NULL); &#x2F;&#x2F;遍历每个类，查看是否是我们要找的那个类\n            if(enable_hijack)\n            &#123;\n                main_dll&#x3D;LoadLibraryA(&quot;UnityPlayer_Original.dll&quot;);\n                if(main_dll&#x3D;&#x3D;NULL)\n                &#123;\n                    MessageBoxA(NULL,&quot;Error&quot;,&quot;Error&quot;,MB_OK);\n                    TerminateProcess(GetCurrentProcess(),0);\n                    return FALSE;\n                &#125;\n                else\n                    UnityMainCall&#x3D;(PTR (*)())GetProcAddress(main_dll,&quot;UnityMain&quot;);\n            &#125;\n            &#x2F;&#x2F;Sleep(10000);\n           \n            &#x2F;&#x2F;il2cpp_alloc(64);\n            break;\n        case DLL_PROCESS_DETACH:\n            if(enable_hijack)\n                FreeLibrary(main_dll);\n            break;\n    &#125;\n    return TRUE;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>至于什么时刻，怎么辨别，就是靠传入的信号值，不同来辨别，比如DLL_PROCESS_ATTACH，就是当dll载入内存空间时，进行调用，其他的调用方式，看下图(copy得到):</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2.每个DLL都可以有一个入口点函数DllMain,系统会在不同的时刻调用此函数。以下是DllMain的一般形式：\n\nBOOL WINAPI DllMain(\n    HINSTANCE hinstDLL,  &#x2F;&#x2F; handle to DLL module\n    DWORD fdwReason,     &#x2F;&#x2F; reason for calling function\n    LPVOID lpReserved )  &#x2F;&#x2F; reserved\n&#123;\n    &#x2F;&#x2F; Perform actions based on the reason for calling.\n    switch( fdwReason ) \n    &#123; \n        case DLL_PROCESS_ATTACH:\n         &#x2F;&#x2F; Initialize once for each new process.\n         &#x2F;&#x2F; Return FALSE to fail DLL load.\n            break;\n\n        case DLL_THREAD_ATTACH:\n         &#x2F;&#x2F; Do thread-specific initialization.\n            break;\n\n        case DLL_THREAD_DETACH:\n         &#x2F;&#x2F; Do thread-specific cleanup.\n            break;\n\n        case DLL_PROCESS_DETACH:\n         &#x2F;&#x2F; Perform any necessary cleanup.\n            break;\n    &#125;\n    return TRUE;  &#x2F;&#x2F; Successful DLL_PROCESS_ATTACH.\n&#125;\n先来看一下这个函数传递进来的参数：\n1、 HINSTANCE hinstDLL\n这个参数是该DLL实例的句柄，也就是此DLL映射到进程地址空间后，在该进程地址空间中的位置。\n2、 DWORD fdwReason\n此参数标示了调用DllMain函数的原因。有四种值，就是函数中case后的取值。各个取值的含义，稍后论述。\n3、 LPVOID lpReserved \n保留。\n\n现在我们来讨论一下fdwReason的四种取值，这些取值，也直接反映了操作系统会在何种情况下调用DllMain。\n1、DLL_PROCESS_ATTACH\n当系统第一次将一个DLL映射到进程地址空间中时，会调用DllMain，并为fdwReason传入DLL_PROCESS_ATTACH。\n注意，只有在第一次映射的时候，才会这样。如之后，另一线程再次显式加载此DLL，则操作系统只是增加该DLL的使用计数，而不会再次使用DLL_PROCESS_ATTACH来调用DllMain。\n对DLL_PROCESS_ATTACH的处理，代表了DLL的初始化。\nDllMain的返回值，也是针对DLL_PROCESS_ATTACH消息的。对于其余的三种取值，不起作用。\n对于隐式加载，如DllMain返回FALSE，则程序会启动失败。对于显式加载，则会使LoadLibrary返回NULL。\n2、DLL_PROCESS_DETACH\n当系统将一个DLL从进程地址空间中撤销映射时，则会向DllMain传入DLL_PROCESS_DETACH。我们应当在此处放置一些清理代码。\n当使用FreeLibrary时，如该线程的使用计数为0时，操作系统才会使用DLL_PROCESS_DETACH来调用DllMain。如使用计数大于0，则只是单纯的减少该DLL的计数。\n3、DLL_THREAD_ATTACH\n当进程创建一个线程，则系统会检查当前已映射到该进程空间中的所有DLL映像，并用DLL_THREAD_ATTACH来调用每个DLL的DllMain。\n只有当所有DLL都完成了对DLL_THREAD_ATTACH的处理后，新线程才会执行它的线程函数。\n另外，主线程不可能用DLL_THREAD_ATTACH来调用DllMain，因为主线程必然是在进程初始化的时候，用DLL_PROCESS_ATTACH调用DllMain的。\n4、DLL_THREAD_DETACH\n线程若要终止，会调用ExitThread，但是此函数不会立即终止线程，而是会利用DLL_THREAD_DETACH来调用当前进程地址空间中的所有DLL镜像的DllMain.\n当每个DLL的DllMain都处理完后，系统才会真正的结束线程。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","feature":null,"text":"前言之前ctf中的游戏逆向都是比较直接，都是dnspy然后搜索关键字，然后开始逆向的，比较简单些，这题的话和其他的游戏题还是有很大的不同的，昂哥出的题确实有质量，后续的官方wp中也有昂哥用dll注入，直接破掉的操作，先看几题，常规的题，之后再与这题进行一个对比。 BJD hamb...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"gameReverse","slug":"gameReverse","count":1,"path":"api/categories/gameReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":10,"path":"api/tags/reverse.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#BJD-hamburger-competition\"><span class=\"toc-text\">BJD hamburger competition</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MRCTF-EZ-GAME\"><span class=\"toc-text\">MRCTF EZ_GAME</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ce%E7%9A%84%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">ce的操作</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#DLL%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">DLL注入</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{},"next_post":{"title":"pintool in CTF","uid":"884cdb3da3fbfd31ea764ff186f03018","slug":"pintool-in-CTF","date":"2021-05-22T12:28:18.000Z","updated":"2021-05-22T13:24:10.554Z","comments":true,"path":"api/articles/pintool-in-CTF.json","keywords":null,"cover":"https://th.wallhaven.cc/small/6o/6oqzgq.jpg","text":"前言突然发现pintools对一些单字节验证的题目还挺好使的，所以就打算整整学学，唉，就是玩，2333 安装(ubuntu16.04)不要问我，kali怎么装，应该是一样的）,无脑输入下面的shell命令就完事了 wget -c https:&#x2F;&#x2F;softwar...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"pintool","slug":"pintool","count":1,"path":"api/categories/pintool.json"}],"tags":[{"name":"reverse","slug":"reverse","count":10,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}