{"title":"ISCC某安卓题","uid":"b380b394179f19e6fa4ccc3b184ec926","slug":"ISCC某安卓题","date":"2021-05-02T11:56:33.000Z","updated":"2021-05-02T12:16:04.086Z","comments":true,"path":"api/articles/ISCC某安卓题.json","keywords":null,"cover":"https://w.wallhaven.cc/full/28/wallhaven-281d5y.png","content":"<p>口述下:ctf的安卓题，不能以实战的角度去逆了，毕竟从ctf角度出发，我们需要的是最短时间拿到flag，而不是把整体app代码全部分析出来，昨晚睡前，大概看了下文件就睡了，早上把逻辑理了下，就开始了，首先是java2c，这个问题，其实就是和java层的代码一样，不过是写在ndk中的，样子比较丑，和反射长的差不多，可以去hook art，也可以直接看逻辑，我用了下杨神的轮子，大概打印了下，发现流程是正常，不过这样其实也偏了，就算前期把一些数剧改了，也没关系，反正后期我们用的是改完之后的数据去获得flag的，所以根本不需要在意他怎么改，嫖就完事了，直接定位到点击事件，onclick方法，也是一个native方法，直接跟进去，发现这里就是核心逻辑，不过先调用了一个check1方法，跟进去，发现是ollvm 虚假控制流，看了下混淆比较轻，直接手调，发现就是一个验证code长度是不是为6，组成是不是只有小写的字母，然后继续下一步，就是正式调试，发现先经过一个md5加密，然后每个字节每4位开始转换成字符，其实就是md5成32位的字符串，然后经过一个等式，来判断code是否正确，看了下不可逆，不过是可以直接爆破的，写exp开始跑</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import hashlib\n\ntt&#x3D;&quot;&quot;\nflag&#x3D;&quot;abcdefghijklmnopqrstuvwxyz&quot;\nv35&#x3D;0\nfor a in range(26):\n    for b in range(26):\n        for c in range(26):\n            for d in range(26):\n                for e in range(26):\n                    for f in range(26):\n                        #tt+&#x3D;\n                        m &#x3D; hashlib.md5()\n                        tt&#x3D;flag[a]+flag[b]+flag[c]+flag[d]+flag[e]+flag[f]\n                        m.update(bytes(tt, encoding&#x3D;&quot;utf8&quot;))\n                        res&#x3D;m.hexdigest()\n                        v33&#x3D;0\n                        v34&#x3D;0\n\n                        for yk in range(len(res)):\n                            if ord(res[yk])&#x3D;&#x3D;48:\n                                v35&#x3D;yk\n                            else:\n                                v35&#x3D;0\n                            if ord(res[yk])&#x3D;&#x3D;48:\n                                v33+&#x3D;1\n                            v34+&#x3D;v35\n                        if v34+10*v33&#x3D;&#x3D;403:\n                            print(&quot;right!:&quot;+tt)\n                            exit(0)\n                        else:\n                            print(&quot;wrong answer:&quot;+tt)\n                        tt&#x3D;&quot;&quot;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里注意hashlib.md5()这个方法，每次只调用一次，否则会一直变动，之前跑了一次，但是没跑出来，调试了下源程序，发现了这个问题，改过来后，直接就可以跑出来了，大概3个小时，</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210502201249.png\"></p>\n<p>然后接下来就是用code中的一些字符作为伪随机的种子，之前以为是前4位，调试后，发现不是，不过和我们输入的flag没关系，那么说明是跟着code变化，code的正确，值也必然对，直接dump下来，就完事了，写个exp，搞定</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.util.Random;\n\npublic class getFlag &#123;\n    public static void main(String[] args) &#123;\n        String test&#x3D;&quot;ozulmt&quot;;\n        char[] tt&#x3D;new char[]&#123;&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;;\n        int v49&#x3D;test.charAt(0);\n        int v50&#x3D;test.charAt(1);\n        int v51&#x3D;test.charAt(2);\n        int v52&#x3D;test.charAt(3);\n        System.out.println(v49);\n        Random rd&#x3D;new Random(0xcc18);\n        StringBuilder sb&#x3D;new StringBuilder();\n        for(int w&#x3D;0;w&lt;32;w++)\n        &#123;\n           sb.append(tt[rd.nextInt(16)]);\n        &#125;\n        System.out.println(sb.toString());\n\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>6ab457d7223583baa46d8b2cb1c3c406</p>\n<p>code和flag正确输入，发现弹出ISCC{6ab457d7223583baa46d8b2cb1c3c406}，结束，总体出的还行</p>\n","feature":null,"text":"口述下:ctf的安卓题，不能以实战的角度去逆了，毕竟从ctf角度出发，我们需要的是最短时间拿到flag，而不是把整体app代码全部分析出来，昨晚睡前，大概看了下文件就睡了，早上把逻辑理了下，就开始了，首先是java2c，这个问题，其实就是和java层的代码一样，不过是写在ndk中...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"writeup","slug":"writeup","count":8,"path":"api/categories/writeup.json"}],"tags":[{"name":"reverse","slug":"reverse","count":17,"path":"api/tags/reverse.json"}],"toc":"","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"记录下修改smail的骚操作以及如何重打包","uid":"65a729b015fbeb895e9e3c25a8f4953e","slug":"记录下修改smail的骚操作以及如何重打包","date":"2021-05-06T09:20:45.000Z","updated":"2021-05-06T14:23:01.029Z","comments":true,"path":"api/articles/记录下修改smail的骚操作以及如何重打包.json","keywords":null,"cover":"https://w.wallhaven.cc/full/6o/wallhaven-6olw9x.jpg","text":"前言在被各种的重打包工具折磨之后，群里大佬推荐我看看珍惜哥的视频学学，这肯定得冲了呀，看了一小时，看完了，感觉学到一点骚操作，挺好玩的，就记录下 smail的修改在patch java层的时候，我们通常是去反编译apk，然后去修改smail，之后再重新编译打包签名，得把几个过程分...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"安卓小技巧","slug":"安卓小技巧","count":1,"path":"api/categories/安卓小技巧.json"}],"tags":[{"name":"reverse","slug":"reverse","count":17,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"肉丝的任务罢了","uid":"ab7fd6f31dafc73ffe830b8abfe31bb7","slug":"肉丝的任务罢了","date":"2021-04-25T14:03:22.000Z","updated":"2021-04-25T15:39:54.323Z","comments":true,"path":"api/articles/肉丝的任务罢了.json","keywords":null,"cover":"https://w.wallhaven.cc/full/dp/wallhaven-dpgk5o.jpg","text":"第一道题 逻辑很简单，就是输入一个username，然后经过一个native函数，和字符串做对比 调用了一个base64， 第二题和第一题java层逻辑差不多，稍微复杂一点，大概就是数字先md5加密，然后原数字经过一个aes-cbc加密，和md5加密后的进行拼接，进行一波对比。c...","link":"","photos":[],"count_time":{"symbolsCount":895,"symbolsTime":"1 mins."},"categories":[{"name":"writeup","slug":"writeup","count":8,"path":"api/categories/writeup.json"}],"tags":[{"name":"reverse","slug":"reverse","count":17,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}