{"title":"2021虎符ctf","uid":"b0f886f319692d13d933a2573c7d3ea9","slug":"2021虎符ctf","date":"2021-04-07T14:43:37.000Z","updated":"2021-04-07T15:00:31.990Z","comments":true,"path":"api/articles/2021虎符ctf.json","keywords":null,"cover":null,"content":"<h1 id=\"1-code\"><a href=\"#1-code\" class=\"headerlink\" title=\"1.  code\"></a>1.  code</h1><p>通过去观察代码逻辑，发现是先初始化出一个二维数组，然后开始取字符，不过每行中的列数为字符的ascii码值时，而取出来为下一行的行数，再填充回去，而v7那个循环，要想成功的条件，就是必须每次都找到下一行的行数，那么其实flag就是输入的前14位字符，直接提交</p>\n<h1 id=\"2-go\"><a href=\"#2-go\" class=\"headerlink\" title=\"2.  go\"></a>2.  go</h1><p>发现没去掉符号表，直接去看main_main函数，然后发现有几个函数很可疑，通过动调调试发现先经过一个格式的检查，要满足前面5位flag{，后面3类4个0-9a-f，最后是12个字符的0-9a-f，再后面就是使用了两次的xtea加密，不过是魔改的，把常数替换之后就好，直接从网上copy一份xtea的解密脚本，魔改下，解就完事了</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nvoid encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;\nunsigned int i;\nuint32_t v0&#x3D;v[0], v1&#x3D;v[1], sum&#x3D;0, delta&#x3D;0x12345678;\nfor (i&#x3D;0; i &lt; num_rounds; i++) &#123;\nv0 +&#x3D; (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);\nsum +&#x3D; delta;\nv1 +&#x3D; (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);\n&#125;\nv[0]&#x3D;v0; v[1]&#x3D;v1;\n&#125;\n\nvoid decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;\nunsigned int i;\nuint32_t v0&#x3D;v[0], v1&#x3D;v[1], delta&#x3D;0x12345678, sum&#x3D;delta*num_rounds;\nfor (i&#x3D;0; i &lt; num_rounds; i++) &#123;\nv1 -&#x3D; (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);\nsum -&#x3D; delta;\nv0 -&#x3D; (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);\n&#125;\nv[0]&#x3D;v0; v[1]&#x3D;v1;\n&#125;\nint main()\n&#123;\nuint32_t v[2]&#x3D;&#123;0x0ec311f0,0x45c79af3&#125;;\n&#x2F;&#x2F;uint32_t v[2]&#x3D;&#123;0xedf5d910,0x542702cb&#125;;\nuint32_t const k[4]&#x3D;&#123;0x010203,0x04050607,0x08090a0b,0x0c0d0e0f&#125;;\nunsigned int r&#x3D;32;&#x2F;&#x2F;num_rounds锟斤拷锟斤拷取值为32\ndecipher(r, v, k);\nprintf(&quot;%x %x\\n&quot;,v[0],v[1]);\nreturn 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"3-CrackMe\"><a href=\"#3-CrackMe\" class=\"headerlink\" title=\"3.  CrackMe\"></a>3.  CrackMe</h1><p>发现两个输入，第一个输入是字符串，第二个是数字，然后发现有一个if，只和数字有关系，然后是int，考虑利用idapython进行爆破，或者和2st大哥一样使用inline hook进行爆破，坏坏的,，放下儒哥的爆破脚本，我写的个ida6的产物，mmp，其实这种idapython就是对inline hook用idapython的形式进行复述了一遍，主要是控制rip寄存器来改变程序流程，同时这种是动态执行的，之前一直想的是类似unicorn那种模拟执行的，emm，想歪了</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import ida_dbg\nimport idc\n\n\nclass MyDbgHook(ida_dbg.DBG_Hooks):\n  def __init__(self):\n    ida_dbg.DBG_Hooks.__init__(self)  # important\n    self.guess &#x3D; 0\n    self.cin1_addr &#x3D; 0x140001658\n    self.cin2_addr &#x3D; 0x140001762\n    self.before_cin2 &#x3D; 0x14000175B\n    self.after_cin2 &#x3D; 0x140001768\n    self.chk_addr &#x3D; 0x14000184E\n\n  def log(self, msg):\n    print(&quot;&gt;&gt;&gt; %s&quot; % msg)\n\n  def dbg_bpt(self, tid, ea):\n    if ea &#x3D;&#x3D; self.cin1_addr:\n      self.reset()\n    elif ea &#x3D;&#x3D; self.cin2_addr:\n      ida_dbg.set_reg_val(&#39;rip&#39;, self.after_cin2)\n      rsp &#x3D; ida_dbg.get_reg_val(&#39;rsp&#39;)\n      idc.patch_qword(rsp+0x40, self.guess)\n      self.continue_process()\n    elif ea &#x3D;&#x3D; self.chk_addr:\n      ebx &#x3D; ida_dbg.get_reg_val(&#39;ebx&#39;)\n      eax &#x3D; ida_dbg.get_reg_val(&#39;eax&#39;)\n      if ebx !&#x3D; 80643:\n        self.guess +&#x3D; 12379\n        self.reset()\n      elif eax !&#x3D; 1442:\n        self.guess +&#x3D; 1\n        self.reset()\n      else:\n        self.log(str(self.guess))\n        self.continue_process()\n    return 0\n\n  def continue_process(self):\n    pass\n\n  def reset(self):\n    ida_dbg.set_reg_val(&#39;rip&#39;, self.before_cin2)\n    self.continue_process()\n\n  def dbg_process_exit(self, *args):\n    self.unhook()\n    self.log(&quot;unhooked&quot;)\n\n\n# Install the debug hook\ndebughook &#x3D; MyDbgHook()\ndebughook.hook()\nida_dbg.request_start_process()\nida_dbg.run_requests()\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>跑出来一个数字99308，然后就是一个常规的rc4，直接解开就完事了</p>\n","feature":null,"text":"1. code通过去观察代码逻辑，发现是先初始化出一个二维数组，然后开始取字符，不过每行中的列数为字符的ascii码值时，而取出来为下一行的行数，再填充回去，而v7那个循环，要想成功的条件，就是必须每次都找到下一行的行数，那么其实flag就是输入的前14位字符，直接提交 2. g...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"writeup","slug":"writeup","count":7,"path":"api/categories/writeup.json"}],"tags":[{"name":"reverse","slug":"reverse","count":10,"path":"api/tags/reverse.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-code\"><span class=\"toc-text\">1.  code</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-go\"><span class=\"toc-text\">2.  go</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-CrackMe\"><span class=\"toc-text\">3.  CrackMe</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"JNI helper插件使用","uid":"7cc37a0c897d960438332a3e8c6a890d","slug":"JNI-helper插件使用","date":"2021-04-07T17:15:59.000Z","updated":"2021-04-07T17:25:53.165Z","comments":true,"path":"api/articles/JNI-helper插件使用.json","keywords":null,"cover":[],"text":"1. 前言看直播的时候，肉丝表哥讲了r2的jni 插件，讲到了jni helper，evi大佬写的一款，自动识别jni类型的插件，兼容了好几款常见的反编译工具，之前也给了github星星的，但是具体怎么使用没去看，这里刚好讲到了，我也了解了下，最终效果还不错，膜 2. 使用过程 ...","link":"","photos":[],"count_time":{"symbolsCount":381,"symbolsTime":"1 mins."},"categories":[{"name":"ida插件","slug":"ida插件","count":2,"path":"api/categories/ida插件.json"}],"tags":[{"name":"ida插件","slug":"ida插件","count":2,"path":"api/tags/ida插件.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"看雪某数字壳测试题","uid":"509e3543271104a33a26b59536e47f22","slug":"看雪某数字壳测试题","date":"2021-04-07T01:48:58.000Z","updated":"2021-04-19T13:32:42.714Z","comments":true,"path":"api/articles/看雪某数字壳测试题.json","keywords":null,"cover":"https://w.wallhaven.cc/full/x8/wallhaven-x88o53.jpg","text":"脱壳发现加了数字壳，直接用frida-的dexdump或者寒冰大佬的fart脱，就完事了，我这里还是比较喜欢objection搭配frida-dexdump插件的方式，比较方便，对这种没抽取的壳，也完全足够了，直接操作 从内存中dump下了，三个dex，命令行输入grep -ri...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"app实战","slug":"app实战","count":2,"path":"api/categories/app实战.json"}],"tags":[{"name":"d2c","slug":"d2c","count":1,"path":"api/tags/d2c.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}