{"title":"unidbg反ollvm字符串混淆(二)","uid":"826b11e5304e0be8ab8c923b8486f9df","slug":"unidbg反ollvm字符串混淆-二","date":"2021-08-01T10:21:28.000Z","updated":"2021-08-01T10:31:42.498Z","comments":true,"path":"api/articles/unidbg反ollvm字符串混淆-二.json","keywords":null,"cover":"https://w.wallhaven.cc/full/kw/wallhaven-kwjd76.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>有碰到过ollvm的字符串加密，很常见的特征就在于在init或者init array段里面会有很多字符串解密的函数，对抗的手法也是很多种的，加载内存dump，或者模拟执行patch掉，这里我选择使用模拟执行unidbg来hook出每次字符串解密写入的内存地址以及value</p>\n<h1 id=\"代码编写\"><a href=\"#代码编写\" class=\"headerlink\" title=\"代码编写\"></a>代码编写</h1><p>这里我特意去学了原始unicorn的操作，发现unicorn本身就支持对内存访问的hook，基本就是一个类型，一个回调，在unidbg上也是一样的，直接放下代码, 原理也是不难的，就是记录下访问地址，以及值，再算出偏移，patch生成新文件，主要坑点就是这里减去基地址后，偏移在ida中是准的，不过对于文件的偏移需要再减少0x1000</p>\n<p>DeStrWriteHook.java</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.xc;\n\nimport com.github.unidbg.arm.backend.Backend;\nimport com.github.unidbg.arm.backend.WriteHook;\nimport unicorn.Unicorn;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class DeStrWriteHook implements WriteHook &#123;\n    &#x2F;&#x2F;找个key-value数据结构来进行存储\n    public Map&lt;Long,byte[]&gt; dstr_datas&#x3D;new HashMap&lt;Long,byte[]&gt;();\n    &#x2F;&#x2F;long类型转换成小端\n    public byte[] long2little(long value)\n    &#123;\n        byte[] yks&#x3D;new byte[8];\n        yks[0]&#x3D;(byte)(value&amp;0xff);\n        yks[1]&#x3D;(byte)(value&gt;&gt;8&amp;0xff);\n        yks[2]&#x3D;(byte) (value&gt;&gt;16&amp;0xff);\n        yks[3]&#x3D;(byte) (value&gt;&gt;24&amp;0xff);\n        yks[4]&#x3D;(byte)(value&gt;&gt;32&amp;0xff);\n        yks[5]&#x3D;(byte)(value&gt;&gt;40&amp;0xff);\n        yks[6]&#x3D;(byte)(value&gt;&gt;48&amp;0xff);\n        yks[7]&#x3D;(byte) (value&gt;&gt;56&amp;0xff);\n        return yks;\n    &#125;\n    &#x2F;&#x2F;long类型转换成大端\n    public byte[] long2big(long value)\n    &#123;\n        byte[] yks&#x3D;new byte[8];\n        yks[7]&#x3D;(byte)(value&amp;0xff);\n        yks[6]&#x3D;(byte)(value&gt;&gt;8&amp;0xff);\n        yks[5]&#x3D;(byte) (value&gt;&gt;16&amp;0xff);\n        yks[4]&#x3D;(byte) (value&gt;&gt;24&amp;0xff);\n        yks[3]&#x3D;(byte)(value&gt;&gt;32&amp;0xff);\n        yks[2]&#x3D;(byte)(value&gt;&gt;40&amp;0xff);\n        yks[1]&#x3D;(byte)(value&gt;&gt;48&amp;0xff);\n        yks[0]&#x3D;(byte) (value&gt;&gt;56&amp;0xff);\n        return yks;\n    &#125;\n    @Override\n    public void hook(Backend backend, long address, int size, long value, Object user) &#123;\n        &#x2F;&#x2F;写入地址，写入数据的长度，写入该地址的值\n        byte[] writedata&#x3D;long2little(value);\n        byte[] newWritedata&#x3D;new byte[size];\n        System.arraycopy(writedata,0,newWritedata,0,size);\n        dstr_datas.put(address,newWritedata);\n    &#125;\n\n    @Override\n    public void onAttach(Unicorn.UnHook unHook) &#123;\n\n    &#125;\n\n    @Override\n    public void detach() &#123;\n\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>DestrOlllvm.java（主逻辑）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.xc;\n\nimport com.github.unidbg.AndroidEmulator;\nimport com.github.unidbg.Module;\nimport com.github.unidbg.linux.android.AndroidEmulatorBuilder;\nimport com.github.unidbg.linux.android.AndroidResolver;\nimport com.github.unidbg.linux.android.dvm.AbstractJni;\nimport com.github.unidbg.linux.android.dvm.DalvikModule;\nimport com.github.unidbg.linux.android.dvm.VM;\nimport com.github.unidbg.memory.Memory;\n\nimport java.io.*;\nimport java.util.Map;\n\npublic class DestrOllvm extends AbstractJni&#123;\n    private final AndroidEmulator emulator;\n    private final VM vm;\n    private final Module module;\n    private static DeStrWriteHook deStrWriteHook;\n    public  DestrOllvm()\n    &#123;\n        emulator&#x3D; AndroidEmulatorBuilder.for32Bit().build();\n        System.out.println(&quot;当前进程pid:&quot;+emulator.getPid());\n        final Memory memory&#x3D; emulator.getMemory();\n        memory.setLibraryResolver(new AndroidResolver(23));\n        deStrWriteHook&#x3D;new DeStrWriteHook();\n        emulator.getBackend().hook_add_new(deStrWriteHook,0,Long.MAX_VALUE,null);\n        vm&#x3D;emulator.createDalvikVM();\n        vm.setVerbose(false); &#x2F;&#x2F;打印jni调用细节\n        DalvikModule dm&#x3D;vm.loadLibrary(new File(&quot;unidbg-android&#x2F;src&#x2F;main&#x2F;java&#x2F;DeStrOllvm&#x2F;obf.so&quot;),true);\n        module&#x3D;dm.getModule();\n        vm.setJni(this); &#x2F;&#x2F;设置jni接口\n        dm.callJNI_OnLoad(emulator);\n    &#125;\n    public static String byte2string(byte[] input)\n    &#123;\n        String ret&#x3D;&quot;&quot;;\n        for(int i&#x3D;0;i&lt;input.length;i++)\n        &#123;\n            int v&#x3D;input[i]&amp;0xff;\n            ret+&#x3D;(Integer.toHexString(v));\n        &#125;\n        return ret;\n    &#125;\n    public static byte[] readFile(String strFile)\n    &#123;\n        try&#123;\n            InputStream is&#x3D;new FileInputStream(strFile);\n            int iAvail&#x3D;is.available();\n            byte[] bytes&#x3D;new byte[iAvail];\n            is.read(bytes); &#x2F;&#x2F;将文件的字节流读取byte数组中\n            is.close();\n            return bytes;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n        return null;\n    &#125;\n    public static void writeFile(byte[] data,String savefile)\n    &#123;\n        try&#123;\n            FileOutputStream fos&#x3D;new FileOutputStream(savefile);\n            BufferedOutputStream bos&#x3D;new BufferedOutputStream(fos);\n            bos.write(data,0,data.length);\n            bos.flush();\n            bos.close();\n\n        &#125;catch (Exception e)\n        &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        DestrOllvm destrOllvm&#x3D;new DestrOllvm();\n        &#x2F;&#x2F;patch后的文件生成位置\n         String savepath&#x3D;&quot;unidbg-android&#x2F;src&#x2F;main&#x2F;java&#x2F;DeStrOllvm&#x2F;obf_new.so&quot;;\n         byte[] sodata&#x3D;readFile(&quot;unidbg-android&#x2F;src&#x2F;main&#x2F;java&#x2F;DeStrOllvm&#x2F;obf.so&quot;);\n         long base_addr&#x3D;destrOllvm.module.base;\n         long module_size&#x3D;destrOllvm.module.size;\n        ByteArrayOutputStream byteArrayOutputStream&#x3D;new ByteArrayOutputStream();\n         for(Map.Entry&lt;Long,byte[]&gt; item:deStrWriteHook.dstr_datas.entrySet())&#123;\n             if(item.getKey()&gt;base_addr&amp;&amp;item.getKey()&lt;base_addr+module_size) &#123;\n                 Long offset &#x3D; item.getKey() - base_addr - 0x1000;\n                 byteArrayOutputStream&#x3D;new ByteArrayOutputStream();\n                 System.out.println(String.format(&quot;address:0x%x data:%s&quot;, offset, byte2string(item.getValue())));\n                 &#x2F;&#x2F;先把前面部分取出来\n                 byte[] front &#x3D; new byte[offset.intValue()];\n                 System.arraycopy(sodata, 0, front, 0, offset.intValue());\n                 &#x2F;&#x2F;然后把后半部分的大小计算出来\n                 int endsize &#x3D; sodata.length - offset.intValue() - item.getValue().length;\n                 &#x2F;&#x2F;把后半部分的取出\n                 byte[] last &#x3D; new byte[endsize];\n                 System.arraycopy(sodata, offset.intValue() + item.getValue().length, last, 0, endsize);\n                 &#x2F;&#x2F;将三个位置的数据填充上\n                 byteArrayOutputStream.write(front, 0, front.length);\n                 byteArrayOutputStream.write(item.getValue(), 0, item.getValue().length);\n                 byteArrayOutputStream.write(last, 0, last.length);\n                 &#x2F;&#x2F;最后保存上\n                 sodata &#x3D; byteArrayOutputStream.toByteArray();\n             &#125;\n         &#125;\n            writeFile(byteArrayOutputStream.toByteArray(),savepath);\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><p>没运行前</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210801183031.png\"></p>\n<p>运行后</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210801183123.png\"></p>\n<p>效果来说，还是不错的</p>\n","feature":null,"text":"前言有碰到过ollvm的字符串加密，很常见的特征就在于在init或者init array段里面会有很多字符串解密的函数，对抗的手法也是很多种的，加载内存dump，或者模拟执行patch掉，这里我选择使用模拟执行unidbg来hook出每次字符串解密写入的内存地址以及value 代...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"unidbg","slug":"unidbg","count":2,"path":"api/categories/unidbg.json"}],"tags":[{"name":"reverse","slug":"reverse","count":19,"path":"api/tags/reverse.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99\"><span class=\"toc-text\">代码编写</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%88%E6%9E%9C\"><span class=\"toc-text\">效果</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"unicorn自动化解决迷宫问题","uid":"6946deb52774246dc7e3f9d367660594","slug":"unicorn自动化解决迷宫问题","date":"2021-08-02T04:11:18.000Z","updated":"2021-08-02T04:27:30.643Z","comments":true,"path":"api/articles/unicorn自动化解决迷宫问题.json","keywords":null,"cover":[],"text":"unicorn简单使用unicorn是一个跨平台的模拟执行框架，在我最近使用看来，是具有对内存和指令有着完全操纵权的框架，具有很高的可定制化，是一种天然的沙盒 from unicorn import * from unicorn.arm_const import * ARM_CO...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"unicorn","slug":"unicorn","count":1,"path":"api/categories/unicorn.json"}],"tags":[{"name":"reverse","slug":"reverse","count":19,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"unidbg实例使用以及遇到的问题(-)","uid":"6a44b632aa8a379a96226b3336a01d5f","slug":"unidbg实例使用以及遇到的问题","date":"2021-07-30T13:44:05.000Z","updated":"2021-07-31T04:12:26.108Z","comments":true,"path":"api/articles/unidbg实例使用以及遇到的问题.json","keywords":null,"cover":"https://th.wallhaven.cc/small/j3/j3339m.jpg","text":"前言对某程app的so进行模拟执行，加深对unidbg的理解和使用(不提供样本) 开始分析 找到我们的目标 打算是模拟执行这个jni函数，再找到这个加载的so ​ 这个jni函数参数是一个字节数组，一个字符串，返回值也是字符串 用frida hook下，看看啥情况 发现就是第一个...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"unidbg","slug":"unidbg","count":2,"path":"api/categories/unidbg.json"}],"tags":[{"name":"reverse","slug":"reverse","count":19,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}