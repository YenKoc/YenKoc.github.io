{"title":"Android热修复类加载方案demo","uid":"a90be964479d5a11087cdb9a691b6994","slug":"Android热修复类加载方案demo","date":"2021-06-04T05:54:30.000Z","updated":"2021-06-09T06:52:44.644Z","comments":true,"path":"api/articles/Android热修复类加载方案demo.json","keywords":null,"cover":"https://th.wallhaven.cc/small/6o/6oqzgq.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在逆一些东西的时候，总会遇到热修复的东西，但是之前只是听说并没有了解过这个热修复是啥，所以昨天花了一下午的时间学习了，感觉还可以，主要是跟系统的源码有关系的。</p>\n<h1 id=\"先了解一手系统classloader\"><a href=\"#先了解一手系统classloader\" class=\"headerlink\" title=\"先了解一手系统classloader\"></a>先了解一手系统classloader</h1><ol>\n<li><p>classloader在热修复中，我们主要就关心两种，pathclassloader和dexClassloader，第一个是我们的系统类加载器，第二个是我们自定义的类加载器，可以任意加载zip，jar，apk中的dex文件，我们从系统源码的角度出发，去看看他们加载dex，主要是做了哪些事</p>\n</li>\n<li><p>这里是选择跟一手Android8.1的源码，源码网站可以选择:<a href=\"http://aosp.opersys.com/xref/android-8.1.0_r81/\">http://aosp.opersys.com/xref/android-8.1.0_r81/</a></p>\n<p>个人认为比那个啥androidxref快一些，先看下DexClassLoader这个类</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210604140351.png\"></p>\n<p>再点进去，我们一般就是直接调用它的构造函数的。</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210604140435.png\"></p>\n<p>发现有四个参数，第一个参数是载入dex文件的路径，第二个参数是其他类似zip和jar，apk是需要解压的，解压后的文件放入的路径，第三个的是加载dex需要的库，第四个是继承的父类加载器，继续调用了父类的构造方法，第二个参数设置为空了，8.0后的系统，已经把第二个参数废掉了（，发现是继续baseclassloader，再跟上去</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210604140859.png\"></p>\n<p>发现好家伙，这里主要是干了什么呢，其实就是给pathList赋值，调用了DexPathList的构造方法</p>\n<p>，我们再跟进去。</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210604142202.png\"></p>\n<p>发现，好家伙，疯狂套娃，给pathList这个对象的字段dexElements赋值了，直接跟进去</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210604142616.png\"></p>\n<p>这个files.size方法基本判断说，就是当我们加载的是多dex情况，每个elements都对应一个dex，可以看这里，遍历dex文件，然后把dex文件搞成一个dexfile对象，我们可以跟进</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210604143020.png\"></p>\n<p>第一种就是直接dex文件的，第二种就是需要解压的，懂的都懂，我们直接跟第一种</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210604143138.png\"></p>\n<p>给dexfile三个字段进行赋值，再跟下去就到native层去了，就不跟了我们的目的也达到了，发现loaddexfile，就是将传入的dex文件，打成了一个dexfile对象</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210604143355.png\"></p>\n<p>发现这个elements字段核心就是为了给它的两个字段赋值而已。</p>\n</li>\n</ol>\n<h2 id=\"系统中是如何去查找一个类的呢？\"><a href=\"#系统中是如何去查找一个类的呢？\" class=\"headerlink\" title=\"系统中是如何去查找一个类的呢？\"></a>系统中是如何去查找一个类的呢？</h2><p>我们可以继续跟着源码，平常我们的代码都是先生成一个classloader对象，然后使用它的ge tClass()方法，去dex中去寻找类对象。</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210604151336.png\"></p>\n<p>发现调用了pathList的findClass方法，继续跟</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210604151605.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210604151748.png\"></p>\n<p>最后也是跟着native层去了，然后发现什么问题，就是先遍历了这个dexelements数组，每个数组元素不就相当于一个dexfile嘛，当发现有同名的类的时候，就返回类对象，所以我们要热修复的话，必须插到这个数组的前面才行。</p>\n<h1 id=\"分享下热修复的代码\"><a href=\"#分享下热修复的代码\" class=\"headerlink\" title=\"分享下热修复的代码\"></a>分享下热修复的代码</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.example.hotfixtest;\n\nimport android.content.Context;\n\nimport java.io.File;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.nio.file.Path;\nimport java.util.HashSet;\n\nimport dalvik.system.DexClassLoader;\nimport dalvik.system.PathClassLoader;\n\npublic class FixDex &#123;\n    &#x2F;&#x2F;修复的文件后缀\n    private static final String DEX_SUFFIX&#x3D;&quot;.dex&quot;;\n    private static final String APK_SUFFIX&#x3D;&quot;.apk&quot;;\n    private static final String JAR_SUFFIX&#x3D;&quot;.jar&quot;;\n    private static final String ZIP_SUFFIX&#x3D;&quot;.zip&quot;;\n    public static final String DEX_DIR&#x3D;&quot;odex&quot;;\n    public static final String OPTIMIZE_DEX_DIR&#x3D;&quot;optimize_dex&quot;;\n    private static HashSet&lt;File&gt; loadedDex&#x3D;new HashSet&lt;File&gt;();\n\n    static &#123;\n        &#x2F;&#x2F;初始化\n        loadedDex.clear();\n    &#125;\n    &#x2F;&#x2F;反射工具包\n    &#x2F;&#x2F;给对象字段赋值\n    public static void setObjectField(Object object,Class&lt;?&gt; objectClass,String fieldName,Object value) throws NoSuchFieldException, IllegalAccessException &#123;\n        Field field&#x3D;objectClass.getDeclaredField(fieldName);\n        field.setAccessible(true);\n        field.set(object,value);\n    &#125;\n    &#x2F;&#x2F;取出对象的字段值\n    public static Object getObjectField(Object object,Class&lt;?&gt; objectClass,String fieldName) throws NoSuchFieldException, IllegalAccessException &#123;\n        Field field&#x3D;objectClass.getDeclaredField(fieldName);\n        field.setAccessible(true);\n        return field.get(object);\n    &#125;\n    &#x2F;&#x2F;拿到pathList对象\n    public static Object getPathList(Object baseDexClassLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;\n        return getObjectField(baseDexClassLoader,Class.forName(&quot;dalvik.system.BaseDexClassLoader&quot;),&quot;pathList&quot;);\n    &#125;\n    &#x2F;&#x2F;拿到pathList对象中的dexElements对象\n    public static Object getDexElement(Object PathList) throws NoSuchFieldException, IllegalAccessException &#123;\n        return getObjectField(PathList,PathList.getClass(),&quot;dexElements&quot;);\n    &#125;\n    &#x2F;&#x2F;数组合并\n    private static Object combineArray(Object arrayLhs,Object arrayRhs)\n    &#123;\n        Class&lt;?&gt; componentType&#x3D;arrayLhs.getClass().getComponentType(); &#x2F;&#x2F;dexElements对象的雷\n        int oLength&#x3D;Array.getLength(arrayLhs);\n        int nLength&#x3D;Array.getLength(arrayRhs);\n        int NewLength&#x3D;oLength+nLength;\n        &#x2F;&#x2F;创建一个新的dexElements对象数组，不过目前是空的\n        Object dexElements&#x3D;Array.newInstance(componentType,NewLength);\n        System.arraycopy(arrayLhs,0,dexElements,0,oLength);\n        System.arraycopy(arrayRhs,0,dexElements,oLength,nLength);\n        return dexElements;\n    &#125;\n    private static void deDexInject(Context appContext,HashSet&lt;File&gt; loadedDex)\n    &#123;\n        String optimizeDir&#x3D;appContext.getFilesDir().getAbsolutePath()+File.pathSeparator+OPTIMIZE_DEX_DIR;\n        File fopt&#x3D;new File(optimizeDir);\n        if(!fopt.exists())\n        &#123;\n            fopt.mkdirs();\n        &#125;\n        try&#123;\n            &#x2F;&#x2F;记载应用程序的dex\n            PathClassLoader pathClassLoader&#x3D; (PathClassLoader) appContext.getClassLoader();\n            for(File dex:loadedDex) &#123;\n                DexClassLoader dexClassLoader &#x3D; new DexClassLoader(dex.getAbsolutePath(), fopt.getAbsolutePath(), null, pathClassLoader);\n                &#x2F;&#x2F;3.合并\n                Object dexPathList&#x3D;getPathList(dexClassLoader);\n                Object pathPathList&#x3D;getPathList(pathClassLoader);\n                Object leftDexElements&#x3D;getDexElement(dexPathList);\n                Object rightDexElements&#x3D;getDexElement(pathPathList);\n                &#x2F;&#x2F;合并完成\n                Object newDexElements&#x3D;combineArray(leftDexElements,rightDexElements);\n                &#x2F;&#x2F; 重写给pathList中的elements数组赋值\n                Object pathPathList1&#x3D;getPathList(pathClassLoader);\n                setObjectField(pathPathList1,pathPathList1.getClass(),&quot;dexElements&quot;,newDexElements);\n\n            &#125;\n        &#125;catch (Exception e)\n        &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    public static void loadFixedDex(Context context,File patchFilsDir)\n    &#123;\n        if(context&#x3D;&#x3D;null) &#123;\n            return;\n        &#125;\n        File fileDir&#x3D;patchFilsDir!&#x3D;null? patchFilsDir: new File(context.getFilesDir().getAbsoluteFile(),DEX_DIR);\n        File[] f&#x3D;fileDir.listFiles();\n        for(File tmp:f)\n        &#123;\n            if(tmp.getName().startsWith(&quot;class&quot;)||tmp.getName().endsWith(DEX_SUFFIX)||tmp.getName().endsWith(APK_SUFFIX)||tmp.getName().endsWith(JAR_SUFFIX)|| tmp.getName().endsWith(ZIP_SUFFIX))\n            &#123;\n                loadedDex.add(tmp);\n            &#125;\n        &#125;\n        &#x2F;&#x2F;合并之前的dex\n        deDexInject(context,loadedDex);\n    &#125;\n\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>主要通过反射进行的操作，所以和系统版本有关系，安卓9已经把反射禁了，得需要另一种方式突破限制，不展开了</p>\n","feature":null,"text":"前言在逆一些东西的时候，总会遇到热修复的东西，但是之前只是听说并没有了解过这个热修复是啥，所以昨天花了一下午的时间学习了，感觉还可以，主要是跟系统的源码有关系的。 先了解一手系统classloader classloader在热修复中，我们主要就关心两种，pathclassloa...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"安卓开发","slug":"安卓开发","count":1,"path":"api/categories/安卓开发.json"}],"tags":[{"name":"热修复","slug":"热修复","count":1,"path":"api/tags/热修复.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%88%E4%BA%86%E8%A7%A3%E4%B8%80%E6%89%8B%E7%B3%BB%E7%BB%9Fclassloader\"><span class=\"toc-text\">先了解一手系统classloader</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%8E%BB%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">系统中是如何去查找一个类的呢？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%86%E4%BA%AB%E4%B8%8B%E7%83%AD%E4%BF%AE%E5%A4%8D%E7%9A%84%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">分享下热修复的代码</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"Android got hook","uid":"08f55e9615384c7275f59ed241f8ccbd","slug":"Android-got-hook","date":"2021-06-09T06:24:12.000Z","updated":"2021-06-10T07:37:53.107Z","comments":true,"path":"api/articles/Android-got-hook.json","keywords":null,"cover":"https://th.wallhaven.cc/small/6o/6od3px.jpg","text":"原理 核心原理就是查找程序头表中的动态segment，然后查看虚拟内存映射到哪个位置，也就是rva，可以直接去ida中查看偏移， 因为我发现ida去解析so文件的时候，是看segment表去解析的，所以ida直接就是一个起始地址为0的虚拟内存（，先去010查看这个段在哪，然后发现...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":11,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"got表hook","slug":"got表hook","count":1,"path":"api/tags/got表hook.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"哈工大编译原理第二节笔记","uid":"ab71dbe1e9c18adee445c559bc9eb61a","slug":"哈工大编译原理第二节笔记","date":"2021-06-02T17:36:06.000Z","updated":"2021-06-02T19:58:36.795Z","comments":true,"path":"api/articles/哈工大编译原理第二节笔记.json","keywords":null,"cover":"https://w.wallhaven.cc/full/v9/wallhaven-v9xzm3.jpg","text":"前言本来打算早上起来学的，没想到失眠了，直接起床学（，被动学习加一 2-1 词法语法分析基本概念 这里讲了一个集合乘积的概念，字母表的n次方，就是几个字母表的乘积，这里的乘积和我们说的乘法不同，这里的乘积，其实更多的概念叫连接，几次方，相当于是连接后字符串的长度，类似于每位从字符...","link":"","photos":[],"count_time":{"symbolsCount":495,"symbolsTime":"1 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":2,"path":"api/categories/编译原理.json"}],"tags":[{"name":"计算机基础","slug":"计算机基础","count":2,"path":"api/tags/计算机基础.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}