{"title":"哈工大编译原理第一节笔记","uid":"77bc24379b69ae18331fff6632b0555b","slug":"哈工大编译原理第一节笔记","date":"2021-06-01T11:15:47.000Z","updated":"2021-06-01T17:28:38.215Z","comments":true,"path":"api/articles/哈工大编译原理第一节笔记.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/l3/l3zmwy.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在看哈工大的编译原理视频ing，顺便做做笔记（，要考试了，太惨了</p>\n<h1 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h1><h2 id=\"1-1-什么是编译\"><a href=\"#1-1-什么是编译\" class=\"headerlink\" title=\"1-1 什么是编译\"></a>1-1 什么是编译</h2><p>源程序进行编译器，编译成汇编，然后汇编生成可重定位的机器代码，再经过链接，生成目标机器代码，大体流程是这样的，具体的流程，我又去翻了一遍程序员的自我修养的第二章。</p>\n<ul>\n<li><p>先经过预处理操作</p>\n<p>这里的过程主要是处理那些源文件中以”#”开始的预编译指令。比如#include,#define等，主要处理规则:</p>\n<ol>\n<li>将所有的“#define”指令删除，并且展开所有的宏定义</li>\n<li>处理所有条件预编译指令，比如”#if“，”#idef“，#elif”，“#else”</li>\n<li>处理#include预编译指令，将被包含的文件插入到该预编指令的位置，不断包含，因为头文件也包含其他头文件</li>\n<li>删除所有的注释</li>\n<li>添加行号和文件名标识</li>\n<li>保留所有的#prama编译器指令</li>\n</ol>\n<p>经过预编译后的.i文件不包含任何宏定义，因为所有的宏定义都已经展开了，包含的文件也已经插入到文件当中了。</p>\n</li>\n<li><p>编译</p>\n<p>编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析以及优化后生产相应的汇编代码文件。</p>\n</li>\n<li><p>汇编</p>\n<p>汇编器是将汇编代码转变成机器可以执行的指令，其实汇编就是机器码的翻译，可以对应起来的，所以汇编也是和cpu架构对应起来的。</p>\n</li>\n<li><p>链接</p>\n<p>主要是将各种模块经过汇编后的重定位目标模块，组装在一起，下面这图我觉得挺贴切的</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210601233015.png\"></p>\n</li>\n</ul>\n<h2 id=\"1-2-编译系统的结构\"><a href=\"#1-2-编译系统的结构\" class=\"headerlink\" title=\"1-2 编译系统的结构\"></a>1-2 编译系统的结构</h2><p>老师这边举了一个英文翻译成汉语的例子，我觉得挺不错的，首先我们肯定得知道这个句子是什么意思嘛，所以需要语义分析，然后语义分析是需要分析句子的结构，划分句子的，句子结构是分析他们的分别是什么状语的，那么我们的问题又转到分析状语的过程，是语法分析，识别短语，同时要识别短语，是需要确定词性的，是需要词法分析的，真不错的，实际编译器上是倒着来的</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210602000918.png\"></p>\n<h2 id=\"1-3-词法分析\"><a href=\"#1-3-词法分析\" class=\"headerlink\" title=\"1-3 词法分析\"></a>1-3 词法分析</h2><p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210602001222.png\"></p>\n<p>同种类型就是靠属性值来进行区分的，来个例子，其实就是搜索，然后再拆分</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210602002203.png\"></p>\n<h1 id=\"1-4-语法分析概述\"><a href=\"#1-4-语法分析概述\" class=\"headerlink\" title=\"1-4 语法分析概述\"></a>1-4 语法分析概述</h1><p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210602002412.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210602002835.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210602003220.png\"></p>\n<p>大概有点理解了，所以说，在正常翻译过程中的x语，在编译原理中，其实上是由文法来制定的，什么词加上什么词，构成什么语法结构，是由文法来决定的，这步是语法分析做的事。</p>\n<h2 id=\"1-5-语义分析概述\"><a href=\"#1-5-语义分析概述\" class=\"headerlink\" title=\"1-5 语义分析概述\"></a>1-5 语义分析概述</h2><p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210602004614.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210602004932.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210602005959.png\"></p>\n<h1 id=\"1-6-中间代码生成和编译器后端\"><a href=\"#1-6-中间代码生成和编译器后端\" class=\"headerlink\" title=\"1-6 中间代码生成和编译器后端\"></a>1-6 中间代码生成和编译器后端</h1><p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210602011331.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210602011713.png\"></p>\n<p>唯一确定了运算完成的顺序</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210602012107.png\"></p>\n<p>目标代码生成以源程序的中间表示形式作为输入，并把它映射到目标语言，最重要的是变量的寄存器分配</p>\n<p>代码优化为改进代码进行的等价程序变化，使其运行得更快，所占用空间更少</p>\n<p>总结下: 有个一个大体的概念，老师讲的挺赞的</p>\n","feature":null,"text":"前言在看哈工大的编译原理视频ing，顺便做做笔记（，要考试了，太惨了 笔记1-1 什么是编译源程序进行编译器，编译成汇编，然后汇编生成可重定位的机器代码，再经过链接，生成目标机器代码，大体流程是这样的，具体的流程，我又去翻了一遍程序员的自我修养的第二章。 先经过预处理操作 这里的...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":2,"path":"api/categories/编译原理.json"}],"tags":[{"name":"计算机基础","slug":"计算机基础","count":2,"path":"api/tags/计算机基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%94%E8%AE%B0\"><span class=\"toc-text\">笔记</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">1-1 什么是编译</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1-2 编译系统的结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90\"><span class=\"toc-text\">1-3 词法分析</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-4-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1-4 语法分析概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1-5 语义分析概述</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-6-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%90%8E%E7%AB%AF\"><span class=\"toc-text\">1-6 中间代码生成和编译器后端</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"关于pixel4 root成砖，又复活的故事","uid":"645125775bc5f25537c3c04c5e9cbef1","slug":"关于pixel4-root成砖，又复活的故事","date":"2021-06-02T08:04:54.000Z","updated":"2021-06-02T08:21:37.424Z","comments":true,"path":"api/articles/关于pixel4-root成砖，又复活的故事.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/3z/3z32j3.jpg","text":"前言我自己的pixel1忘记带来了，从导师那弄了一台pixel4，好像没root，所以打算开始先root，然后装个测试环境 刷入面具magisk这里和常规的那种pixel，刷入第三方tw，然后卡刷zip包还是很大不同，我尝试了一遍，发现根本没用，从网上搜了一种方法还行，打开调试模...","link":"","photos":[],"count_time":{"symbolsCount":869,"symbolsTime":"1 mins."},"categories":[{"name":"刷机","slug":"刷机","count":2,"path":"api/categories/刷机.json"}],"tags":[{"name":"刷机","slug":"刷机","count":2,"path":"api/tags/刷机.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"windows上反调试的一些总结","uid":"29c90278776b9ceb230f70e3bee57549","slug":"windows上反调试的一些总结","date":"2021-05-27T17:25:12.000Z","updated":"2021-06-04T06:01:07.572Z","comments":true,"path":"api/articles/windows上反调试的一些总结.json","keywords":null,"cover":"https://w.wallhaven.cc/full/57/wallhaven-57ly31.jpg","text":"前言反调试，分为两种，一种是静态反调试，另一种是动态反调试，这两者主要的目的也不同，第一种的核心目的是检测调试器，而第二种的核心目的其实就是为了隐藏代码和数据的，第一种的类似xxdebugpresent，第二种类似双进程保护，异常处理等反调试手段，第一种的话实际上一次破解结束后，...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":1,"path":"api/categories/逆向工程核心原理.json"}],"tags":[{"name":"反调试","slug":"反调试","count":1,"path":"api/tags/反调试.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}