{"title":"xposed插件编写01","uid":"2baa56a271382e4f44c5cafacec7639e","slug":"xposed插件编写01","date":"2021-07-25T11:46:40.000Z","updated":"2021-07-25T12:26:22.976Z","comments":true,"path":"api/articles/xposed插件编写01.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/8o/8oky1j.jpg","content":"<h1 id=\"前置准备两个apk（一个xposed模块，一个要hook的apk）\"><a href=\"#前置准备两个apk（一个xposed模块，一个要hook的apk）\" class=\"headerlink\" title=\"前置准备两个apk（一个xposed模块，一个要hook的apk）\"></a>前置准备两个apk（一个xposed模块，一个要hook的apk）</h1><ul>\n<li><p>xposed模块准备</p>\n<p>直接选择nativec++创建就行，然后就是配置需要注意</p>\n<p>在app目录下的build.gradle文件中修改这几点</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">externalNativeBuild &#123;\n           cmake &#123;\n               cppFlags &quot;&quot;\n           &#125;\n           ndk&#123;\n               abiFilters &quot;armeabi-v7a&quot;\n           &#125;\n       &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">repositories &#123;\n    jcenter()\n&#125;\n\ndependencies &#123;\n    compileOnly &#39;de.robv.android.xposed:api:82&#39;\n    compileOnly &#39;de.robv.android.xposed:api:82:sources&#39;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后在AndroidManifest.xml的application标签下加入</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;meta-data android:name&#x3D;&quot;xposedmodule&quot; android:value&#x3D;&#39;true&#39;&#x2F;&gt;\n      &lt;meta-data android:name&#x3D;&quot;xposeddescription&quot; android:value&#x3D;&quot;kanxueso1&quot;&#x2F;&gt;\n      &lt;meta-data android:name&#x3D;&quot;xposedminversion&quot; android:value&#x3D;&quot;82&quot;&#x2F;&gt;\n      <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>开始编写hook逻辑</p>\n<p>这里选择是套e佬的inlinehook框架，有轮子就上轮子，</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210725195858.png\"></p>\n<p>cmake里面也需要改下，把这些文件依赖导入进去</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">add_library( # Sets the name of the library.\n             native-lib\n\n             # Sets the library as a shared library.\n             SHARED\n\n             # Provides a relative path to your source file(s).\n            inlinehookk&#x2F;inlineHook.cpp\n            inlinehookk&#x2F;inlineHook.h\n            inlinehookk&#x2F;relocate.cpp\n            inlinehookk&#x2F;relocate.h\n\n             native-lib.cpp\n            )<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;jni.h&gt;\n#include &lt;string&gt;\nextern &quot;C&quot;&#123;\n    #include &quot;inlinehookk&#x2F;inlineHook.h&quot;\n&#125;\n#include &quot;android&#x2F;log.h&quot;\n#include &lt;stdio.h&gt;\n#include &lt;dlfcn.h&gt;\n\nint (*old_strstr)(const char *,const char *) &#x3D; NULL;\n\nint new_strstr(const char *string,const char* myStr)\n&#123;\n    __android_log_print(4,&quot;YenKoc&quot;,&quot;i hook success %s&quot;,myStr);\n    if(!strcmp(myStr,&quot;YenKoc&quot;))\n    &#123;\n        return 100;\n    &#125;else&#123;\n        return old_strstr(string,myStr);\n    &#125;\n\n&#125;\n\nint hook()\n&#123;\n   void* handle&#x3D; dlopen(&quot;libc.so&quot;,RTLD_NOW);\n   void* strstraddr&#x3D;dlsym(handle,&quot;strstr&quot;);\n    if (registerInlineHook((uint32_t) strstraddr, (uint32_t) new_strstr, (uint32_t **) &amp;old_strstr) !&#x3D; ELE7EN_OK) &#123;\n        return -1;\n    &#125;\n    if (inlineHook((uint32_t) strstraddr) !&#x3D; ELE7EN_OK) &#123;\n        return -1;\n    &#125;\n\n    return 0;\n&#125;\n\nint unHook()\n&#123;\n    if (inlineUnHook((uint32_t) puts) !&#x3D; ELE7EN_OK) &#123;\n        return -1;\n    &#125;\n\n    return 0;\n&#125;\nextern &quot;C&quot; JNIEXPORT jstring JNICALL\nJava_com_example_kanxuexposedso1_MainActivity_stringFromJNI(\n        JNIEnv* env,\n        jobject &#x2F;* this *&#x2F;) &#123;\n    std::string hello &#x3D; &quot;Hello from C++&quot;;\n    hook();\n    return env-&gt;NewStringUTF(hello.c_str());\n&#125;extern &quot;C&quot;\nJNIEXPORT void JNICALL\nJava_com_example_kanxuexposedso1_Xmodule_hookhook(JNIEnv *env, jobject thiz) &#123;\n    hook();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>xposed这里先注册一个native函数，方便调用，不过不可能直接调用的，每次hook用的都是被hook app的classloader，会找不到代码执行的，说白了，进程内存中根本没你那段代码，执行个锤子（，所以我们需要得是将so注入进去</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.example.kanxuexposedso1;\n\nimport de.robv.android.xposed.IXposedHookLoadPackage;\nimport de.robv.android.xposed.XC_MethodHook;\nimport de.robv.android.xposed.XposedBridge;\nimport de.robv.android.xposed.XposedHelpers;\nimport de.robv.android.xposed.callbacks.XC_LoadPackage;\n\npublic class Xmodule implements IXposedHookLoadPackage &#123;\n    public native void hookhook();\n    @Override\n    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123;\n        if(lpparam.packageName.equals(&quot;com.example.hooksoexample01&quot;))\n        &#123;\n            Class systemClass&#x3D;lpparam.classLoader.loadClass(&quot;java.lang.Runtime&quot;);\n            XposedBridge.hookAllMethods(systemClass, &quot;loadLibrary0&quot;, new XC_MethodHook() &#123;\n                @Override\n                protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;\n                    super.beforeHookedMethod(param);\n                &#125;\n\n                @Override\n                protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;\n                    super.afterHookedMethod(param);\n                    System.load(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;a.so&quot;);\n                    hookhook();\n                &#125;\n            &#125;);\n\n        &#125;\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里的so文件，是我将编译后的apk中的so文件取出了（，每次app启动自动注入so到内存中</p>\n</li>\n<li><p>被hook的app的核心逻辑</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;jni.h&gt;\n#include &lt;string&gt;\n\nextern &quot;C&quot; JNIEXPORT jstring JNICALL\nJava_com_example_hooksoexample01_MainActivity_stringFromJNI(\n        JNIEnv* env,\n        jobject &#x2F;* this *&#x2F;) &#123;\n    std::string hello &#x3D; &quot;Hello from C++&quot;;\n    if(strstr(&quot;fast&quot;,&quot;YenKoc&quot;)!&#x3D;nullptr)\n    &#123;\n        hello&#x3D;&quot;you are hooked&quot;;\n    &#125;\n\n    return env-&gt;NewStringUTF(hello.c_str());\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>到此为止，基本上hook完成，屏幕就不截图了，结果是you are hooked，不过这次对我来说，有了一些感悟吧2333</p>\n</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>之前就有想过就是inlinehook这东西，我要如何去加入到我的逻辑上，之前陷入就是在自己开发的app中加入inlinehook没啥问题，但是去hook其他app时，总会感觉很迷茫，但是经过下午的练习，慢慢有了感觉，发现我对本质的东西之前是没有去理解，实际上我们去inlinehook肯定是找到某个函数的地址，然后架设跳板，之前在自己开发的app是完全可以实现的，因为我们hook逻辑也是写在本身的app进程中的，而且是由我们自己决定是否调用的，但是hook别的app，我们的hook逻辑是写在别的地方的，无法进去app进程，连进程空间都进不去，谈何hook，所以说我们需要去把hook的逻辑注入到app的进程内存，这样我们的hook逻辑和被hook的地方处在了一个空间中，我们的hook逻辑是可以对它进行操作的，剩下的问题就是调用起hook逻辑了，这里xposed设置native函数，也是为了调用起来，毕竟注入进去后，我们如果不提供接口出来，其实很难去操作的，但是我又想到了，就是dll注入中，每次注入是不是会自动执行某种入口函数xxmain，作为类linux平台也是一样的，so文件载入内存中，会先执行init。initarray段函数，再执行jni_onload函数，这些函数无需人为调用，是由linker完成的，所以我们也可以将hook逻辑写在这几个地方，让它自己执行就行。</p>\n","feature":null,"text":"前置准备两个apk（一个xposed模块，一个要hook的apk） xposed模块准备 直接选择nativec++创建就行，然后就是配置需要注意 在app目录下的build.gradle文件中修改这几点 externalNativeBuild &#123; cmake &#12...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":9,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"xposed","slug":"xposed","count":2,"path":"api/tags/xposed.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87%E4%B8%A4%E4%B8%AAapk%EF%BC%88%E4%B8%80%E4%B8%AAxposed%E6%A8%A1%E5%9D%97%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%A6%81hook%E7%9A%84apk%EF%BC%89\"><span class=\"toc-text\">前置准备两个apk（一个xposed模块，一个要hook的apk）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"Xposed编写inlinehook框架插件02","uid":"81adc87c645a49aab325f38e6f3026a2","slug":"Xposed编写inlinehook框架插件02","date":"2021-07-26T08:35:24.000Z","updated":"2021-07-26T08:48:55.416Z","comments":true,"path":"api/articles/Xposed编写inlinehook框架插件02.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/pk/pkw6y3.jpg","text":"前言吐槽下，妈的，应该是框架本身的bug，好像hook自己编写的函数无参数的话，就会莫名报错，这里耽误了我几个小时，最终才发现了这个问题，鬼知道我开关机了几次妈的。 正式开始 被hook的app的核心逻辑 #include &lt;jni.h&gt; #include &lt;s...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":9,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"xposed","slug":"xposed","count":2,"path":"api/tags/xposed.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"android的PMS动态代理","uid":"668f1dbfd60678f860dbea390d6a69fb","slug":"android的PMS动态代理","date":"2021-07-02T06:26:47.000Z","updated":"2021-07-02T06:54:06.525Z","comments":true,"path":"api/articles/android的PMS动态代理.json","keywords":null,"cover":"https://th.wallhaven.cc/small/28/281d5y.jpg","text":"前言目前在java层中签名验证是使用java层的api进行获取，然后进行判断，可以选择hook，也可以使用安卓本身的特性去hook，不使用任何hook框架去实现hook 代理是什么？结合我自己的理解来说，动态代理实际上就是比如你想找别人，但是你不自己去找，而是委托另一个人去找，把...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":9,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":19,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}