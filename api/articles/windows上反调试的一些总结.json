{"title":"windows上反调试的一些总结","uid":"29c90278776b9ceb230f70e3bee57549","slug":"windows上反调试的一些总结","date":"2021-05-27T17:25:12.000Z","updated":"2021-06-04T06:01:07.572Z","comments":true,"path":"api/articles/windows上反调试的一些总结.json","keywords":null,"cover":"https://w.wallhaven.cc/full/57/wallhaven-57ly31.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>反调试，分为两种，一种是静态反调试，另一种是动态反调试，这两者主要的目的也不同，第一种的核心目的是检测调试器，而第二种的核心目的其实就是为了隐藏代码和数据的，第一种的类似xxdebugpresent，第二种类似双进程保护，异常处理等反调试手段，第一种的话实际上一次破解结束后，反调试就被绕过了，程序就可以正常调试了，但是第二种是要不断的调试，才能看到代码和数据的，还是有很大区别的。</p>\n<h1 id=\"静态反调试\"><a href=\"#静态反调试\" class=\"headerlink\" title=\"静态反调试\"></a>静态反调试</h1><h2 id=\"0x01-PEB反调试\"><a href=\"#0x01-PEB反调试\" class=\"headerlink\" title=\"0x01 PEB反调试\"></a>0x01 PEB反调试</h2><p>peb的意思是进程环境信息块，利用peb结构体信息可以判断当前进程是否处于被调试的状态的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">typedef struct _PEB &#123;\n  BYTE                          Reserved1[2];\n  BYTE                          BeingDebugged; &#x2F;&#x2F;被调试状态\n  BYTE                          Reserved2[1];\n  PVOID                         Reserved3[2];\n  PPEB_LDR_DATA                 Ldr;\n  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;\n  BYTE                          Reserved4[104];\n  PVOID                         Reserved5[52];\n  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;\n  BYTE                          Reserved6[128];\n  PVOID                         Reserved7[1];\n  ULONG                         SessionId;\n&#125; PEB, *PPEB;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上是peb结构体的成员信息，不完全，但是这里就不截图了，具体完整的peb可以见链接:<a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx\">https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx</a></p>\n<p>这里主要关注四个成员</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0x002 BeingDebugged  UChar\n0x00c Ldr \t\t\t\t\tPtr32_PEB_LDR_DATA\n0x018 ProcessHeap.  Ptr32_Void\n0x068 NtGlobalFlag. Uint48<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"0x02-获取peb地址\"><a href=\"#0x02-获取peb地址\" class=\"headerlink\" title=\"0x02 获取peb地址\"></a>0x02 获取peb地址</h1><p>这里获取peb结构体有两种方式，不过都是通过借助fs段寄存器做的</p>\n<ol>\n<li><p>直接获取peb的地址</p>\n<p>MOV EAX,DWORD PTR FS:[0x30]</p>\n</li>\n<li><p>先获取teb地址，再通过ProcessEnvironmentBlock成员（偏移加0x30）来获取peb地址</p>\n<p>MOV EAX,DWORD PTR FS:[0x18]</p>\n<p>MOV EAX,DWORD PTR DS:[EAX+0x30]</p>\n</li>\n</ol>\n<h2 id=\"0x03-细分peb\"><a href=\"#0x03-细分peb\" class=\"headerlink\" title=\"0x03 细分peb\"></a>0x03 细分peb</h2><ul>\n<li><p>BeingDebugged(+0x2)</p>\n<p>进程处于调试状态的时候，这个成员会被设置成1，不在调试状态下，它的值是会被设置成0，</p>\n<p>这不得不 提到IsDebuggerPresent()这个api实际上就是检测peb这个成员的值的。</p>\n</li>\n<li><p>NtGlobalFlag(+0x68)</p>\n<p>调试进程的时候，PEB.NtGlobalFlag成员(+0x68)的值会被设置成0x70所以可以去检测</p>\n<p>这个值，然后去判断进程是否处于被调试状态。</p>\n<p>但是直接attach上调试器的时候，这个成员值是不会变的</p>\n</li>\n</ul>\n<h2 id=\"0x04-过反调试办法\"><a href=\"#0x04-过反调试办法\" class=\"headerlink\" title=\"0x04 过反调试办法\"></a>0x04 过反调试办法</h2><p>peb毕竟还是结构体，也就是最终还是在内存中体现的，那么</p>\n<p>我们可以直接取到peb地址，然后把成员的值改回来就行了</p>\n<p>或者可以利用我之前使用的在汇编层面上把返回值修改掉，不过</p>\n<p>没有直接改结构体，来的方便</p>\n<h2 id=\"0x01-NtQueryInformationProcess\"><a href=\"#0x01-NtQueryInformationProcess\" class=\"headerlink\" title=\"0x01 NtQueryInformationProcess()\"></a>0x01 NtQueryInformationProcess()</h2><p>利用这个api探测调试器，这个api可以获取各种与进程调试相关的信息</p>\n<p>，该函数定义</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">NTSTATUS WINAPI NtQueryInformationProcess\n(\n\t__in HANDLE ProcessHandle\n\t__in PROCESSINFOCLASS ProcessInforationClass\n\t__out PVOID ProcessInformation,\n\t__in ULONG ProcessInformationLength,\n\t__out_opt PULONG ReturnLength\n);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>根据传入的第二个参数的不同，返回值会传入第三个参数</p>\n<p>这个PROCESSINFOCLASS是枚举类型，我们我们主要去关心这个与调试器有关的成员有</p>\n<p>ProcessDebugPort(0x7)、ProcessDebugObject-Handle(0x1E)、ProcessDebugFlags(0x1F)</p>\n<h2 id=\"0x02-ProcessDebugPort-0x7\"><a href=\"#0x02-ProcessDebugPort-0x7\" class=\"headerlink\" title=\"0x02 ProcessDebugPort(0x7)\"></a>0x02 ProcessDebugPort(0x7)</h2><p>当传入的参数为0x7的时候，调用这个NtQueryInformationProcess()函数</p>\n<p>，进程处于非调试状态时，是为0，处于调试状态值为0xFFFFFFFF</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210528024312.png\"></p>\n<p>Ntqxxxx()</p>\n<h2 id=\"0x03-ProcessDebugObjectHandle-0x1e\"><a href=\"#0x03-ProcessDebugObjectHandle-0x1e\" class=\"headerlink\" title=\"0x03 ProcessDebugObjectHandle(0x1e)\"></a>0x03 ProcessDebugObjectHandle(0x1e)</h2><p>调试进程会生成调试对象，当传入第二个参数为0x1e时，</p>\n<p>第三个参数就可以获取调试对象句柄，但是这个句柄要在进程处于调试状态的时候，才可以，如果进程处于非调试状态</p>\n<p>，这个对象是为空的。</p>\n<h2 id=\"0x04-ProcessDebugFlags-0x1F\"><a href=\"#0x04-ProcessDebugFlags-0x1F\" class=\"headerlink\" title=\"0x04 ProcessDebugFlags(0x1F)\"></a>0x04 ProcessDebugFlags(0x1F)</h2><p>和上面的是一样的，不过第二个参数现在要传入0x11f的，</p>\n<p>若进程处于被调试状态，第三个参数值为0，如果为1的话，则进程处于非调试状态的</p>\n<h2 id=\"0x05-反调试方法\"><a href=\"#0x05-反调试方法\" class=\"headerlink\" title=\"0x05 反调试方法\"></a>0x05 反调试方法</h2><p>如果反调试api调用少，我们可以直接去改那个内存中的值，毕竟每次传入第二个参数的时候，会把返回值存在第三个参数重，第三个参数的内存空间，我们是可以操作的，如果api很多，我们可以选择用inlinehook，直接去修改返回值，实现自动化。</p>\n<h2 id=\"0x01-ZwSetInformationThread\"><a href=\"#0x01-ZwSetInformationThread\" class=\"headerlink\" title=\"0x01 ZwSetInformationThread()\"></a>0x01 ZwSetInformationThread()</h2><p>强制分离调试器和被调试进程的技术</p>\n<p>这个api的结构</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">NTSTATUS ZwSetInformationThread(\n\t--in HANDLE ThreadHandle\n\t--in THREADINFOCLASS ThreadInformationClass\n\t__in PVOID ThreadInformation,\n\t__in ULONG ThreadInformationLength\n)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>由第二个参数来决定这个api的功能，第二个参数为0x11时，是隐藏调试进程，使其无法调试的，</p>\n<h2 id=\"0x02-反调试方法\"><a href=\"#0x02-反调试方法\" class=\"headerlink\" title=\"0x02 反调试方法\"></a>0x02 反调试方法</h2><p>可以修改第二个参数的值为0，这样就可以不执行分离进程的功能了</p>\n<h2 id=\"其他方式\"><a href=\"#其他方式\" class=\"headerlink\" title=\"其他方式\"></a>其他方式</h2><p>例如检测虚拟机环境，检测od窗口，检测进程中是否有调试器的进程，检测计算机的名字</p>\n<p>主要通过系统的api去做的检测</p>\n","feature":null,"text":"前言反调试，分为两种，一种是静态反调试，另一种是动态反调试，这两者主要的目的也不同，第一种的核心目的是检测调试器，而第二种的核心目的其实就是为了隐藏代码和数据的，第一种的类似xxdebugpresent，第二种类似双进程保护，异常处理等反调试手段，第一种的话实际上一次破解结束后，...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":1,"path":"api/categories/逆向工程核心原理.json"}],"tags":[{"name":"反调试","slug":"反调试","count":1,"path":"api/tags/反调试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">静态反调试</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x01-PEB%E5%8F%8D%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">0x01 PEB反调试</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x02-%E8%8E%B7%E5%8F%96peb%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">0x02 获取peb地址</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x03-%E7%BB%86%E5%88%86peb\"><span class=\"toc-text\">0x03 细分peb</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x04-%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">0x04 过反调试办法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x01-NtQueryInformationProcess\"><span class=\"toc-text\">0x01 NtQueryInformationProcess()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x02-ProcessDebugPort-0x7\"><span class=\"toc-text\">0x02 ProcessDebugPort(0x7)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x03-ProcessDebugObjectHandle-0x1e\"><span class=\"toc-text\">0x03 ProcessDebugObjectHandle(0x1e)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x04-ProcessDebugFlags-0x1F\"><span class=\"toc-text\">0x04 ProcessDebugFlags(0x1F)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x05-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">0x05 反调试方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x01-ZwSetInformationThread\"><span class=\"toc-text\">0x01 ZwSetInformationThread()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x02-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">0x02 反调试方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">其他方式</span></a></li></ol></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"哈工大编译原理第一节笔记","uid":"77bc24379b69ae18331fff6632b0555b","slug":"哈工大编译原理第一节笔记","date":"2021-06-01T11:15:47.000Z","updated":"2021-06-01T17:28:38.215Z","comments":true,"path":"api/articles/哈工大编译原理第一节笔记.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/l3/l3zmwy.jpg","text":"前言在看哈工大的编译原理视频ing，顺便做做笔记（，要考试了，太惨了 笔记1-1 什么是编译源程序进行编译器，编译成汇编，然后汇编生成可重定位的机器代码，再经过链接，生成目标机器代码，大体流程是这样的，具体的流程，我又去翻了一遍程序员的自我修养的第二章。 先经过预处理操作 这里的...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":2,"path":"api/categories/编译原理.json"}],"tags":[{"name":"计算机基础","slug":"计算机基础","count":2,"path":"api/tags/计算机基础.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"mrctf的游戏逆向","uid":"99d6abf837e88eebd0687f5f9fc4ecea","slug":"mrctf的游戏逆向","date":"2021-05-24T05:57:54.000Z","updated":"2021-05-25T23:45:20.353Z","comments":true,"path":"api/articles/mrctf的游戏逆向.json","keywords":null,"cover":"https://th.wallhaven.cc/small/z8/z887yw.jpg","text":"前言之前ctf中的游戏逆向都是比较直接，都是dnspy然后搜索关键字，然后开始逆向的，比较简单些，这题的话和其他的游戏题还是有很大的不同的，昂哥出的题确实有质量，后续的官方wp中也有昂哥用dll注入，直接破掉的操作，先看几题，常规的题，之后再与这题进行一个对比。 BJD hamb...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"gameReverse","slug":"gameReverse","count":1,"path":"api/categories/gameReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":13,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}