{"title":"pintool in CTF","uid":"884cdb3da3fbfd31ea764ff186f03018","slug":"pintool-in-CTF","date":"2021-05-22T12:28:18.000Z","updated":"2021-05-22T13:24:10.554Z","comments":true,"path":"api/articles/pintool-in-CTF.json","keywords":null,"cover":"https://th.wallhaven.cc/small/6o/6oqzgq.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>突然发现pintools对一些单字节验证的题目还挺好使的，所以就打算整整学学，唉，就是玩，2333</p>\n<h1 id=\"安装-ubuntu16-04\"><a href=\"#安装-ubuntu16-04\" class=\"headerlink\" title=\"安装(ubuntu16.04)\"></a>安装(ubuntu16.04)</h1><p>不要问我，kali怎么装，应该是一样的）,无脑输入下面的shell命令就完事了</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">wget -c https:&#x2F;&#x2F;software.intel.com&#x2F;sites&#x2F;landingpage&#x2F;pintool&#x2F;downloads&#x2F;pin-3.13-98189-g60a6ef199-gcc-linux.tar.gz\ntar -xvf pin-3.13-98189-g60a6ef199-gcc-linux.tar.gz\nmv pin-3.13-98189-g60a6ef199-gcc-linux pin\ncd pin&#x2F;source&#x2F;tools&#x2F;ManualExamples&#x2F;\nmake all TAEGET&#x3D;intel64\nmake all TAEGET&#x3D;ia32<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>之后就会生成一个文件夹，本来是叫pin-xxxxx，就很多，名字改的简洁些，改成pin了，效果如下</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210522203603.png\"></p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>使用的方法基本就是命令记住就行，以下命令在pin目录路径下执行，主要是为了找到pin这个可执行文件，绝对路径和相对路径应该明白的吧，兄弟们。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.&#x2F;pin -t &#x2F;home&#x2F;giantbranch&#x2F;pin&#x2F;source&#x2F;tools&#x2F;ManualExamples&#x2F;obj-intel64&#x2F;inscount0.so -- .&#x2F;文件名<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h1 id=\"原理剖析\"><a href=\"#原理剖析\" class=\"headerlink\" title=\"原理剖析\"></a>原理剖析</h1><p>inscount0.so这个玩意主要就是记录执行的指令数，也是我们非常常用的，我们可以利用这个指令数的差异进行爆破，我总结了下，主要是适用于单字节比较，比如输入的一个字节，经过一个加密等操作后，和密文进行对比，如果错误，程序退出，如果正确的话，是不是就进行下一个字节的判断，由此造成了指令数的差异，如果正确的话，指令数可能会暴增，但是也是不一定的，qctf有题ollvm，指令数就是输入正确的，反而指令数更少了，还是需要去根据规律去使用。</p>\n<h1 id=\"根据ctf实例，进行分析\"><a href=\"#根据ctf实例，进行分析\" class=\"headerlink\" title=\"根据ctf实例，进行分析\"></a>根据ctf实例，进行分析</h1><h2 id=\"1-强网杯的一题xx-warm-obf\"><a href=\"#1-强网杯的一题xx-warm-obf\" class=\"headerlink\" title=\"1. 强网杯的一题xx_warm_obf\"></a>1. 强网杯的一题xx_warm_obf</h2><p>这题倒是有点意思，在main函数中注册了一个信号处理函数。</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210522205052.png\"></p>\n<p>至于怎么发现呢，就是在调试过程中，发现了许多的int3的指令，这玩意会引起软中断的，并发送一个信号，但是由于我们使用调试器调试，所以会先将信号发送到调试器来处理，由于程序是需要int3去发送信号，并处理信号的，我们就不要去打乱这个逻辑，所以我们这里稍微修改一手信号操作。</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210522205439.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210522205602.png\"></p>\n<p> ok，已经不会老弹窗了，不过还有一个信号要处理，应该是一个反调试，就是关于程序超时的情况，所以一弹出，我们直接丢弃这个异常就完事了，下一步就是我们不断的去调试，发现它有很多固定的跳转模式，其实就是垃圾指令，本来程序执行的话，它的指令流程是固定的嘛，这里不谈输入的影响，但是加入一些垃圾指令后，增加了我们静态分析的难度，但是这玩意和ollvm，永远只是表面上打乱了程序流程，但是实际的trace日志上体现的，还是从上到下的执行流程，把垃圾的指令分辨出来就可以，很快到真实执行的地方了，发现这玩意就是一个方程，我们可以用z3去解，但是有pintools，这题又是单字节整活，直接安排上。</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210522204918.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210522204948.png\"></p>\n<p>放下pintool exp（python），实际上能操作shell都行</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import os\nimport sys\nimport subprocess\n\nclass Shell(object):\n    def runCmd(self, cmd):\n        res &#x3D; subprocess.Popen(cmd, shell&#x3D;True, stdin&#x3D;subprocess.PIPE,\n                               stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.STDOUT)\n        sout, serr &#x3D; res.communicate()\n        return res.returncode, sout, serr, res.pid\n\n    def initPin(self, cmd):\n        res &#x3D; subprocess.Popen(cmd, shell&#x3D;True, stdin&#x3D;subprocess.PIPE,\n                               stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.STDOUT)\n        self.res &#x3D; res\n\n    def pinWrite(self, input):\n        self.res.stdin.write(input)\n\n    def pinRun(self):\n        sout, serr &#x3D; self.res.communicate()\n        return sout, serr\n\ncmd &#x3D; &#39;.&#x2F;pin -t .&#x2F;home&#x2F;giantbranch&#x2F;pin&#x2F;source&#x2F;tools&#x2F;ManualExamples&#x2F;obj-intel64&#x2F;inscount0.so -- .&#x2F;xx_warmup_obf&#39;\n\nshell &#x3D; Shell()\n\ns &#x3D; &quot;f&quot;\nimport string\nchs&#x3D;string.printable\nchs &#x3D; string.digits+string.ascii_letters+&#39;&#123;&#125;_&#39;\nfor i in range(27):\n    min_num &#x3D; 2**32\n    min_ch &#x3D; &quot;&quot;\n    for ch in chs:\n        tmp &#x3D; s + ch +(28-len(s)-1)*&#39;a&#39;+&#39;\\n&#39;\n        shell.initPin(cmd)\n        shell.pinWrite(tmp)\n        sout,serr &#x3D; shell.pinRun()\n        with open(&#39;inscount.out&#39;) as f:\n            count &#x3D; f.readline().split(&#39; &#39;)[1]\n        count &#x3D; int(count)\n        print(count,tmp,sout)\n        if(count&lt;min_num):\n            min_num &#x3D; count\n            min_ch &#x3D; ch\n    s+&#x3D;min_ch\n    print(min_num,min_ch)\n    print(&#39;flag:&#39;+s)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"2-QCTF-ollvm\"><a href=\"#2-QCTF-ollvm\" class=\"headerlink\" title=\"2. QCTF ollvm\"></a>2. QCTF ollvm</h2><p>这题也是很经典的一题ollvm类型题目了，可以用bird爷的去平坦化的脚本，可以去掉的，也可以有骚操作，比如pintool，在尝试输入的过程中呢，发现q，输入之后，指令数是在递增的，c也是，说明是可以使用pintool的，放下exp就完事了</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import subprocess\nimport os\nimport logging\nimport json\nimport string\nimport time\nlogging.basicConfig(level&#x3D;logging.INFO)\nlogger &#x3D; logging.getLogger(__name__)\nclass shell(object):\n    def runCmd(self, cmd):\n        res &#x3D; subprocess.Popen(cmd, shell&#x3D;True, stdin&#x3D;subprocess.PIPE,\n                               stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.STDOUT)\n        sout, serr &#x3D; res.communicate()\n        return res.returncode, sout, serr, res.pid\n\n    def initPin(self, cmd):\n        res &#x3D; subprocess.Popen(cmd, shell&#x3D;True, stdin&#x3D;subprocess.PIPE,\n                               stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.STDOUT)\n        self.res &#x3D; res\n\n    def pinWrite(self, input):\n        self.res.stdin.write(input)\n\n    def pinRun(self):\n        sout, serr &#x3D; self.res.communicate()\n        return sout, serr\nfilename &#x3D; &quot;.&#x2F;ollvm&quot;\ncmd &#x3D; &quot;.&#x2F;pin -t &quot; + \\\n    &quot;&#x2F;home&#x2F;giantbranch&#x2F;pin&#x2F;source&#x2F;tools&#x2F;ManualExamples&#x2F;obj-intel64&#x2F;inscount0.so&quot; + &quot; -- &quot; + filename\nprint cmd\nsubprocess.Popen(cmd,shell&#x3D;True,stdin&#x3D;subprocess.PIPE,stdout&#x3D;subprocess.PIPE,stderr&#x3D;subprocess.STDOUT)\n#### brup args ascii\nstart_time &#x3D; time.time()\ndic &#x3D; string.letters+&#39;_&#123;&#125;&#39;+string.digits\ncur&#x3D;&#39;&#39;\nshell &#x3D; shell()\ncout_old&#x3D;0\nstart_time &#x3D; time.time()\nfor i in range(38):\n    for s in dic:\n        pwd &#x3D; cur+s+&#39;?&#39;*(37-len(cur))\n        print len(pwd)\n        rcmd &#x3D; cmd+&#39; &#39;+pwd\n        shell.initPin(rcmd)\n        sout,serr &#x3D; shell.pinRun()\n\twith open(&#39;inscount.out&#39;) as f:\n\t\tcount&#x3D;f.readline().split(&#39; &#39;)[1]\n\tcout&#x3D;count\n        cout_sub&#x3D; int(cout) - cout_old\n        cout_old &#x3D; int(cout)\n        if cout_sub &gt; 1000000 and cout_sub &lt; 1500000 :\n            cur&#x3D;cur+s\n        print (&quot;current flag &quot;, pwd,&quot;current count:&quot;,cout,&quot;sub_count &quot;,cout_sub)\nend_time&#x3D;time.time()\ntimes&#x3D; end_time-start_time\nprint &quot;need times :&quot;,times,&#39;s&#39;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n","feature":null,"text":"前言突然发现pintools对一些单字节验证的题目还挺好使的，所以就打算整整学学，唉，就是玩，2333 安装(ubuntu16.04)不要问我，kali怎么装，应该是一样的）,无脑输入下面的shell命令就完事了 wget -c https:&#x2F;&#x2F;softwar...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"pintool","slug":"pintool","count":1,"path":"api/categories/pintool.json"}],"tags":[{"name":"reverse","slug":"reverse","count":11,"path":"api/tags/reverse.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85-ubuntu16-04\"><span class=\"toc-text\">安装(ubuntu16.04)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">使用</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90\"><span class=\"toc-text\">原理剖析</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%B9%E6%8D%AEctf%E5%AE%9E%E4%BE%8B%EF%BC%8C%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90\"><span class=\"toc-text\">根据ctf实例，进行分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%BC%BA%E7%BD%91%E6%9D%AF%E7%9A%84%E4%B8%80%E9%A2%98xx-warm-obf\"><span class=\"toc-text\">1. 强网杯的一题xx_warm_obf</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-QCTF-ollvm\"><span class=\"toc-text\">2. QCTF ollvm</span></a></li></ol></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"mrctf的游戏逆向","uid":"99d6abf837e88eebd0687f5f9fc4ecea","slug":"mrctf的游戏逆向","date":"2021-05-24T05:57:54.000Z","updated":"2021-05-25T23:45:20.353Z","comments":true,"path":"api/articles/mrctf的游戏逆向.json","keywords":null,"cover":"https://th.wallhaven.cc/small/z8/z887yw.jpg","text":"前言之前ctf中的游戏逆向都是比较直接，都是dnspy然后搜索关键字，然后开始逆向的，比较简单些，这题的话和其他的游戏题还是有很大的不同的，昂哥出的题确实有质量，后续的官方wp中也有昂哥用dll注入，直接破掉的操作，先看几题，常规的题，之后再与这题进行一个对比。 BJD hamb...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"gameReverse","slug":"gameReverse","count":1,"path":"api/categories/gameReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":11,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"rctf 2018 Simple vm","uid":"f39a6fe1a2cc6526ddedf18113d11661","slug":"rctf-2018-Simple-vm","date":"2021-05-21T02:23:22.000Z","updated":"2021-05-21T07:51:03.131Z","comments":true,"path":"api/articles/rctf-2018-Simple-vm.json","keywords":null,"cover":[],"text":"给了两个文件，一个是vm，一个是opcode文件，ida打开后 打开了bin文件，然后将文件内容读取出来，继续进入下一个函数里面分析 是一个非常明显的while switch case的解释器，ptr存着就是上面读取的opcode文件内存，这就是属于是那种已经给定了opcode，...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"writeup","slug":"writeup","count":8,"path":"api/categories/writeup.json"}],"tags":[{"name":"reverse","slug":"reverse","count":11,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}