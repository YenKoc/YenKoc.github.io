{"title":"利用unicorn实现一个小型调试器","uid":"e82fc54bd55d17936e1dc0d74228fd9d","slug":"利用unicorn实现一个小型调试器","date":"2021-09-04T07:56:58.000Z","updated":"2021-09-04T08:02:12.871Z","comments":true,"path":"api/articles/利用unicorn实现一个小型调试器.json","keywords":null,"cover":"https://th.wallhaven.cc/small/rd/rdyyjm.jpg","content":"<p>代码实现已经写注释</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from unicorn import *\nfrom unicorn.arm_const import *\nfrom capstone import *\nfrom pwn import *\nimport hexdump\nclass UnicornDebugger:\n    #模拟器启动\n    def emu_start(self):\n        self.fake_pc.emu_start(self.fake_pc_begin,self.fake_pc_begin+self.fake_pc_size)\n    #初始添加断点\n    def add_bpt(self,tmp_bpt):\n        self.currentbpt&#x3D;tmp_bpt\n        self.bpts.append(tmp_bpt)\n    #打印出寄存器\n    def print_reg(self):\n        for i in self.name_maps:\n            print(self.name_maps[i]+&quot;&#x3D;&quot;+str(hex(self.fake_pc.reg_read(i))))\n    #打印反汇编的内容\n    def print_asm(self,CODE):\n        md &#x3D; self.cs\n        for i in md.disasm(CODE, 0x1000):\n            print(&quot;0x%x:\\t%s\\t%s&quot; % (i.address, i.mnemonic, i.op_str))\n    def print_memory(self,target_address):\n        result&#x3D;self.fake_pc.mem_read(target_address,7)\n        print(self.advance_dump(result,target_address))\n        #print(&quot;result:&quot;,bytes(result))\n        return\n\n    def advance_dump(self,data, base):\n        PY3K &#x3D; sys.version_info &gt;&#x3D; (3, 0)\n        generator &#x3D; hexdump.genchunks(data, 16)\n\n        retstr &#x3D; &#39;&#39;\n        for addr, d in enumerate(generator):\n            print(&quot;len d:%d&quot;%len(d))\n            # 00000000:\n            line &#x3D; &#39;%08X: &#39; % (base + addr * 16)\n            # 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n            dumpstr &#x3D; hexdump.dump(d)\n            print(dumpstr[0:4])\n            line +&#x3D; dumpstr[:8*3]\n            if len(d) &gt; 8:  # insert separator if needed\n                line +&#x3D; &#39; &#39; + dumpstr[8 * 3:]\n            # ................\n            # calculate indentation, which may be different for the last line\n            pad &#x3D; 2\n            if len(d) &lt; 16:\n                pad +&#x3D; 3 * (16 - len(d))\n            if len(d) &lt;&#x3D; 8:\n                pad +&#x3D; 1\n            line +&#x3D; &#39; &#39; * pad\n            print(&quot;len pad:%d&quot;%pad)\n\n            for byte in d:\n                # printable ASCII range 0x20 to 0x7E\n                if not PY3K:\n                    byte &#x3D; ord(byte)\n                if 0x20 &lt;&#x3D; byte &lt;&#x3D; 0x7E:\n                    line +&#x3D; chr(byte)\n                else:\n                    line +&#x3D; &#39;.&#39;\n            retstr +&#x3D; line + &#39;\\n&#39;\n        return retstr\n    def real_trace(self, uc, address, size):\n        self.print_reg()\n        self.print_asm(uc.mem_read(address,size+0x10))\n        if address&#x3D;&#x3D;self.fake_pc_begin+8:\n            print(&quot;over!&quot;)\n            return\n        while True:\n            t&#x3D;str(input())\n            commands&#x3D;t.split(&quot; &quot;)\n            if commands[0]&#x3D;&#x3D;&quot;b&quot;:\n                print(&quot;断点已经设置%s&quot;%commands[1])\n                self.bpts.append(eval(commands[1]))\n                self.currentbpt&#x3D;eval(commands[1])\n            elif commands[0]&#x3D;&#x3D;&quot;n&quot;:\n                print(&quot;步过&quot;)\n                self.bpts.append(address+size)\n                self.currentbpt&#x3D;address+size\n                self.next&#x3D;1\n                self.step&#x3D;0\n                return\n            elif commands[0]&#x3D;&#x3D;&quot;s&quot;:\n                print(&quot;步入&quot;)\n                self.next&#x3D;0\n                self.step&#x3D;1\n                self.currentbpt&#x3D;0\n                return\n            elif commands[0]&#x3D;&#x3D;&quot;c&quot;:\n                print(&quot;继续运行&quot;)\n                self.next&#x3D;0\n                self.step&#x3D;0\n                return\n            elif commands[0]&#x3D;&#x3D;&quot;m&quot;:\n                print(&quot;查看内存&quot;)\n                target_address&#x3D;commands[1]\n                self.print_memory(eval(target_address))\n\n        return\n\n    def trace_yk(self,uc,address,size,user_data):\n        #print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size &#x3D; 0x%x&quot; % (address, size))\n        if self.step&#x3D;&#x3D;0 and self.next&#x3D;&#x3D;0:\n            if address not in self.bpts:\n                return\n        if self.currentbpt!&#x3D;address and self.currentbpt!&#x3D;0:\n            return\n        return self.real_trace(uc, address, size)\n    def __init__(self,mu,address,size):\n        # 寄存器名字的映射表，方便打印\n        self.name_maps&#x3D;&#123;\n        UC_ARM_REG_R0:&quot;R0&quot;,\n        UC_ARM_REG_R1:&quot;R1&quot;,\n        UC_ARM_REG_R2:&quot;R2&quot;,\n        UC_ARM_REG_R3:&quot;R3&quot;,\n        UC_ARM_REG_R4:&quot;R4&quot;,\n        UC_ARM_REG_R5:&quot;R5&quot;,\n        UC_ARM_REG_R6:&quot;R6&quot;,\n        UC_ARM_REG_R7:&quot;R7&quot;,\n        UC_ARM_REG_R8:&quot;R8&quot;,\n        UC_ARM_REG_R9:&quot;R9&quot;,\n        UC_ARM_REG_R10:&quot;R10&quot;,\n        UC_ARM_REG_R11:&quot;R11&quot;,\n        UC_ARM_REG_R12: &quot;R12&quot;,\n        UC_ARM_REG_R13: &quot;R13&quot;,\n        UC_ARM_REG_R14: &quot;R14&quot;,\n        UC_ARM_REG_R15: &quot;R15&quot;,\n            UC_ARM_REG_PC:&quot;PC&quot;,\n            UC_ARM_REG_LR:&quot;LR&quot;,\n            UC_ARM_REG_SP:&quot;SP&quot;\n                        &#125;\n        #设置步入和步过的标志，当步入或步过为1时，执行对应的功能\n        #步过\n        self.next&#x3D;0\n        #步入\n        self.step&#x3D;0\n        #当前断点\n        self.currentbpt&#x3D;0\n        #断点集合\n        self.bpts&#x3D;[]\n        #调试器的一些命令\n        self.command&#x3D;&quot;按m xxx 查看内存，按n 是步过，按 s 是步入，按 b xxx 是下断点&quot;\n        #引用传入创建好的模拟器对象\n        self.fake_pc&#x3D;mu\n        #模拟器的初始地址和指令大小\n        self.fake_pc_begin&#x3D;address\n        self.fake_pc_size&#x3D;size\n        # capstone汇编\n        self.cs&#x3D;Cs(CS_ARCH_ARM, CS_MODE_ARM)\n        self.fake_pc.hook_add(UC_HOOK_CODE,self.trace_yk,begin&#x3D;self.fake_pc_begin,end&#x3D;self.fake_pc_begin+self.fake_pc_size-4)\n\n# 每次指令执行前都会先执行这个回调\ndef hook_code(uc,address,size,user_data):\n\n    print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size &#x3D; 0x%x&quot;% (address,size))\nARM_CODE &#x3D; b&quot;\\x37\\x00\\xa0\\xe3\\x03\\x10\\x42\\xe0\\x04\\x40\\xa0\\xe1&quot;\ndef test_arm():\n    print(&quot;Emulate ARM code&quot;)\n    try:\n        mu&#x3D;Uc(UC_ARCH_ARM,UC_MODE_ARM) # 创建一个uc对象\n        #map 2MB memory for this emulation  这里应该是笔误了，不是2mb，64mb了\n        ADDRESS&#x3D;0x4002d000 # 我们需要将执行的代码载入unicorn的虚拟内存中，unicorn虚拟机实例初始内存是没有任何映射的，在读写内存中，也需要先映射一段内存\n        mu.mem_map(ADDRESS,2*0x10000)\n        #将之前编写的指令写入到虚拟内存中，必须是python的byte类型\n        mu.mem_write(ADDRESS,ARM_CODE)\n        #给虚拟寄存器赋值\n        mu.reg_write(UC_ARM_REG_R0,0x1234)\n        mu.reg_write(UC_ARM_REG_R2,0x6789)\n        mu.reg_write(UC_ARM_REG_R3,0x3333)\n        mu.reg_write(UC_ARM_REG_R4,0x4444)\n        #添加指令级的hook\n        #mu.hook_add(UC_HOOK_CODE,hook_code,begin&#x3D;ADDRESS,end&#x3D;ADDRESS+8)\n        ud&#x3D;UnicornDebugger(mu,ADDRESS,len(ARM_CODE))\n        ud.add_bpt(0x4002d000)\n        ud.emu_start()\n\n        #mu.emu_start(ADDRESS,ADDRESS+len(ARM_CODE))\n        r0&#x3D;mu.reg_read(UC_ARM_REG_R0)\n        r1&#x3D;mu.reg_read(UC_ARM_REG_R1)\n\n    except UcError as e:\n        print(&quot;ERROR:%s&quot;%e)\n\ntest_arm()\n# mov r0, #0x37;\n# sub r1, r2, r3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>实现效果</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210904160107.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210904160126.png\"></p>\n","feature":null,"text":"代码实现已经写注释 from unicorn import * from unicorn.arm_const import * from capstone import * from pwn import * import hexdump class UnicornDebugge...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"unicorn","slug":"unicorn","count":2,"path":"api/categories/unicorn.json"}],"tags":[{"name":"reverse","slug":"reverse","count":21,"path":"api/tags/reverse.json"}],"toc":"","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{},"next_post":{"title":"美团的jnionload反混淆","uid":"575d038a35fac80847b9d48c9af690e7","slug":"美团的jnionload反混淆","date":"2021-08-30T03:15:40.000Z","updated":"2021-08-30T03:16:30.766Z","comments":true,"path":"api/articles/美团的jnionload反混淆.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":10,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"反混淆（花指令)","slug":"反混淆（花指令","count":1,"path":"api/tags/反混淆（花指令.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}