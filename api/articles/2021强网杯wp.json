{"title":"2021强网杯wp","uid":"e711ae4763716495e69aa9bd1f61c2a8","slug":"2021强网杯wp","date":"2021-06-13T17:59:54.000Z","updated":"2021-06-15T08:38:16.032Z","comments":true,"path":"api/articles/2021强网杯wp.json","keywords":null,"cover":"https://img2.baidu.com/it/u=3566088443,3713209594&fm=26&fmt=auto&gp=0.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>就看了两题安卓加一个timeago，太菜了呀，实属要退役的节奏了，一段时间没调，感觉水平无限下滑（。</p>\n<h1 id=\"ezmath\"><a href=\"#ezmath\" class=\"headerlink\" title=\"ezmath\"></a>ezmath</h1><p>这题不予评价了，感觉挺奇怪的，按道理来说idapython还是inline hook都是可以每两字节爆破出来的，但是精度损失的非常厉害，感觉是出题人机器和我们的不太一样的问题，没啥意思感觉。</p>\n<h1 id=\"TimetoAgo\"><a href=\"#TimetoAgo\" class=\"headerlink\" title=\"TimetoAgo\"></a>TimetoAgo</h1><p>一道64位的exe，先去花指令的，都是一些简单的模式，d一下，然后该nop就nop就可以完美的f5了，</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210614024850.png\"></p>\n<p>因为题目一直提示时间的，问题，我就想当然的直接按没加密的patch，后面发现flag不对，又开始老老实实的搬砖了。</p>\n<p>先经过了四个漫长的函数，大概就是生成了一个结构体，不过结构体的字段值，是经过一个奇葩函数生成的，动调了下发现是常数，不过跑的很慢，耐心一点，大概5分钟就跑完了，四个值，0xffd,0x1ffd,0x3ffd,0x7ffd</p>\n<p>后面的就是慢慢磨，能很明显的看到tea算法加密的痕迹，第一个函数中出现&lt;&lt;4 和&gt;&gt;5的异或相加的，后面对照着思路，发现就是前4个是xtea变种加密，后4个tea加密，然后对比的密文也变动了，不用管直接dump下来，直接搞个脚本跑就行。</p>\n<h1 id=\"StandonGiant\"><a href=\"#StandonGiant\" class=\"headerlink\" title=\"StandonGiant\"></a>StandonGiant</h1><p>安卓题，java层没啥代码，就是一个点击事件而已，然后直接到native层，在.init_array发现很明显的openssl痕迹，github上一搜，发现就是openssl的初始化，明显是静态编译进来了，题目也告诉是大数，我这里犯了一个致命错误，没有拿源码去对比，实际上openssl的源码网上一堆，然后一直在调试库函数，无穷无尽，大概前面就是做了一个逆序，然后经过了一个纯的rsa加密，模数就是那个异或后的数组，然后再经过一个base64的换表加密，这个是真的坑，那个base64的表中+-重复了，也就会导致我们反推回原表的下标会导致不止一种情况，所以需要爆破2^14次，把情况都找出来，只有正确的那个才能解密（。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from Crypto.Util.number import *\nimport base64\nn &#x3D; 0x1321D2FDDDE8BD9DFF379AFF030DE205B846EB5CECC40FA8AA9C2A85CE3E992193E873B2BC667DABE2AC3EE9DD23B3A9ED9EC0C3C7445663F5455469B727DD6FBC03B1BF95D03A13C0368645767630C7EABF5E7AB5FA27B94ADE7E1E23BCC65D2A7DED1C5B364B51\np &#x3D; 33372027594978156556226010605355114227940760344767554666784520987023841729210037080257448673296881877565718986258036932062711\nq &#x3D; 64135289477071580278790190170577389084825014742943447208116859632024532344630238623598752668347708737661925585694639798853367\ne &#x3D; 65537\n#普通的base64的换表\n&#39;&#39;&#39;\nstr1 &#x3D; &quot;x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q&quot;\n\nstring1 &#x3D; &quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+&#x2F;&quot;\nstring2 &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot;\nflag&#x3D;base64.b64decode(str1.translate(str.maketrans(string1,string2)))\n&#39;&#39;&#39;\n# 表中出现重复出现的字符时要怎么做\na &#x3D;&quot;bborOT+ohG*,U:;@&#x2F;gVIAZ-,t++LaZkOrk?UcSOKJ?p-J+vuSN?:e,Kc&#x2F;?h-oH?:tthoqYYSPp-ZC+Yw:*jrxPymGYO&#x2F;PvDOIivNYtvJ?Mi*GG+&#x2F;lmqEysrTdSD+eP+moP+l?+Np&#x2F;oK&quot;\n#a &#x3D; &quot;btF.d:IDCNIMHdD+PFExV+BBGYbxjqGK@IN?B+d:*;XZvSMiBJaY@ufB,CIDCI?;oR?SWWdNU?EXc*BfpakoNsRD:IQRffViAUmF+&#x2F;aJ*v*xvxYw?KXVaFsRzy&#x2F;N&#x2F;,XGGKHrpZ*Ooje&#x3D;&quot;\ntable1 &#x3D; &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ*+,-.&#x2F;:;?@+-&quot;\ntable2 &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot;\nprint(len(a))\nall_mid_result&#x3D;[]\ndef findIndex(table,yk):\n    Indexs&#x3D;[]\n    for i in range(len(table)):\n        if yk&#x3D;&#x3D;table[i]:\n            Indexs.append(i);\n    return Indexs\n&#39;&#39;&#39;\nfor i in range(len(a)):\n    ykIndexs&#x3D;findIndex(a[i])\n    if len(ykIndexs)&#x3D;&#x3D;1:\n        flag+&#x3D;table2[ykIndexs[0]]\n    elif len(ykIndexs)&#x3D;&#x3D;2:\n&#39;&#39;&#39;\ntmp&#x3D;[]\ndef dfs(flag, yk, i):\n    if i&#x3D;&#x3D;139:\n        flag+&#x3D;&quot;&#x3D;&quot;\n        tmp.append(flag)\n        return\n    ykIndexs&#x3D;findIndex(yk,a[i])\n    #print(flag)\n    #print(ykIndexs)\n    if len(ykIndexs)&#x3D;&#x3D;2:\n        dfs(flag+table2[ykIndexs[0]],yk,i+1)\n        dfs(flag+table2[ykIndexs[1]],yk,i+1)\n    else:\n        dfs(flag+table2[ykIndexs[0]],yk,i+1)\ndfs(table2[table1.index(a[0])],table1,1)\nf&#x3D;open(&quot;data.txt&quot;,&quot;w&quot;)\nfor wx in range(len(tmp)):\n    mid_res&#x3D;base64.b64decode(tmp[wx])\n    c&#x3D;bytes_to_long(mid_res)\n    a&#x3D;pow(c,inverse(e,(p-1)*(q-1)),n)\n    flag&#x3D;long_to_bytes(a)\n    f.writelines(str(flag))\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h1 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h1><p>还有一题allinone是题android vm套娃，有些思路，但是最后有函数我逆不回去，只能放弃，太菜了，unicorn没看，有点像kctf的传家宝那题了，蜗牛壳，运行一点，解密一点，妈的，得写脚本一直扣代码吧，可怕，不会，期待下wp，感觉状态很差，麻了</p>\n","feature":null,"text":"前言就看了两题安卓加一个timeago，太菜了呀，实属要退役的节奏了，一段时间没调，感觉水平无限下滑（。 ezmath这题不予评价了，感觉挺奇怪的，按道理来说idapython还是inline hook都是可以每两字节爆破出来的，但是精度损失的非常厉害，感觉是出题人机器和我们的不...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"writeup","slug":"writeup","count":8,"path":"api/categories/writeup.json"}],"tags":[{"name":"reverse","slug":"reverse","count":14,"path":"api/tags/reverse.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ezmath\"><span class=\"toc-text\">ezmath</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TimetoAgo\"><span class=\"toc-text\">TimetoAgo</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#StandonGiant\"><span class=\"toc-text\">StandonGiant</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E6%80%9D\"><span class=\"toc-text\">反思</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"SVC指令获取设备信息&内联汇编","uid":"90a1c6273d337dfc4b6067dd868be1ed","slug":"SVC指令获取设备信息-内联汇编","date":"2021-06-28T07:05:01.000Z","updated":"2021-06-28T15:41:55.182Z","comments":true,"path":"api/articles/SVC指令获取设备信息-内联汇编.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/rd/rdyyjm.jpg","text":"前言目前越来越多的api，采用svc进行直接系统调用，syscall也不用了，直接内联汇编，然后svc，可以防止hook，不过最近在看雪也看到一篇修改内核的操作反操作的，之后打算再研究研究。 syscallsyscall可以说是系统层给用户层提供的一个调用内核态代码的api，我们...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":5,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":14,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"Android8.0 art下面的几个脱壳点","uid":"05699e0b3c4e02c2136460838badc80b","slug":"Android8-0-art下面的几个脱壳点","date":"2021-06-11T16:10:05.000Z","updated":"2021-06-11T17:09:36.572Z","comments":true,"path":"api/articles/Android8-0-art下面的几个脱壳点.json","keywords":null,"cover":"https://w.wallhaven.cc/full/5w/wallhaven-5w3dm8.jpg","text":"前言搞了一个17年decon 会议的ppt，里面对市面上的一些apk加固方式有一些整体分析，实际上手动脱壳，现在越来越难了，时间成本太大了，各种莫名的反调试和混淆，so的话，俺也不太会搞vmp，在学了在学了（我太菜了，java层的话，还是有突破口的，毕竟dex再怎么加固，最终还是...","link":"","photos":[],"count_time":{"symbolsCount":843,"symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":5,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"AndroidUnPacker","slug":"AndroidUnPacker","count":1,"path":"api/tags/AndroidUnPacker.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}