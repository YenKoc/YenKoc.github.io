{"title":"Xposed编写inlinehook框架插件02","uid":"81adc87c645a49aab325f38e6f3026a2","slug":"Xposed编写inlinehook框架插件02","date":"2021-07-26T08:35:24.000Z","updated":"2021-07-26T08:48:55.416Z","comments":true,"path":"api/articles/Xposed编写inlinehook框架插件02.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/pk/pkw6y3.jpg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>吐槽下，妈的，应该是框架本身的bug，好像hook自己编写的函数无参数的话，就会莫名报错，这里耽误了我几个小时，最终才发现了这个问题，鬼知道我开关机了几次妈的。</p>\n<h1 id=\"正式开始\"><a href=\"#正式开始\" class=\"headerlink\" title=\"正式开始\"></a>正式开始</h1><ul>\n<li><p>被hook的app的核心逻辑</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;jni.h&gt;\n#include &lt;string&gt;\n#include &lt;string.h&gt;\n#include &quot;android&#x2F;log.h&quot;\nint myr0(char* str) &#123;\n    if (strstr(str, &quot;YenKoc&quot;) !&#x3D; nullptr) &#123;\n\n        __android_log_print(4, &quot;YenKoc&quot;, &quot;i am  success&quot;);\n\n\n    &#125; else &#123;\n\n        __android_log_print(4, &quot;YenKoc&quot;, &quot;i ma fail&quot;);\n    &#125;\n    return reinterpret_cast&lt;int&gt;(strstr(str, &quot;YenKoc&quot;));\n&#125;\n\nextern &quot;C&quot; JNIEXPORT jstring JNICALL\nJava_com_example_hooksoexample01_MainActivity_stringFromJNI(\n        JNIEnv* env,\n        jobject &#x2F;* this *&#x2F;) &#123;\n    std::string hello &#x3D; &quot;Hello from C++&quot;;\n    if(myr0(&quot;123456789&quot;))&#123;\n        __android_log_print(4,&quot;YenKoc&quot;,&quot;myr0 is true  &quot;);\n    &#125;\n    else &#123;\n\n        __android_log_print(4,&quot;YenKoc&quot;,&quot;myr0 is false&quot;);\n    &#125;\n\n    return env-&gt;NewStringUTF(hello.c_str());\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>hook的逻辑</p>\n<p>这里需要先明确一个问题，就是我们的hook的so，不像上一篇是hook libc的so，libc的so是在安卓的白名单中的，所以我们可以直接用dlopen打开，但是我们的so不在白名单，那么只能利用查看内存空间，根据符号表，或者偏移实现了，这里也是用的别的大佬开源的框架导入一手就行</p>\n<p><img src=\"https://raw.githubusercontent.com/YenKoc/YenKoc_tuchuang/main/images20210726164424.png\"></p>\n<p>cmake记得导入</p>\n<p>剩下就是编写真正hook逻辑了</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;jni.h&gt;\n#include &lt;string&gt;\nextern &quot;C&quot;&#123;\n    #include &quot;inlinehookk&#x2F;inlineHook.h&quot;\n    #include &quot;dlfcn&#x2F;dlfcn_compat.h&quot;\n    #include &quot;dlfcn&#x2F;dlfcn_nougat.h&quot;\n&#125;\n\n\n#include &quot;android&#x2F;log.h&quot;\n#include &lt;stdio.h&gt;\n#include &lt;dlfcn.h&gt;\n\nint (*old_judge)() &#x3D; NULL;\n\nint new_judge()\n&#123;\n    __android_log_print(4,&quot;YenKoc&quot;,&quot;i hook success %s&quot;);\n\n    return 1;\n\n&#125;\n\nint hook()\n&#123;\n   void* handle&#x3D; dlopen_compat(&quot;&#x2F;data&#x2F;app&#x2F;com.example.hooksoexample01-Ox57xIxBDLPq0xQ-MNJm-g&#x3D;&#x3D;&#x2F;lib&#x2F;arm&#x2F;libnative-lib.so&quot;,RTLD_NOW);\n   void* judgeaddr&#x3D;dlsym_compat(handle,&quot;_Z4myr0v&quot;);\n   __android_log_print(4,&quot;YenKoc&quot;,&quot; i hook success libaddr:%s&quot;,handle);\n    __android_log_print(4,&quot;YenKoc&quot;,&quot; i hook success funcaddr:%x&quot;,judgeaddr);\n    if (registerInlineHook((uint32_t) judgeaddr, (uint32_t) new_judge, (uint32_t **) &amp;old_judge) !&#x3D; ELE7EN_OK) &#123;\n        return -1;\n    &#125;\n    if (inlineHook((uint32_t) judgeaddr) !&#x3D; ELE7EN_OK) &#123;\n        return -1;\n    &#125;\n\n    return 0;\n&#125;\n\nint unHook()\n&#123;\n    if (inlineUnHook((uint32_t) puts) !&#x3D; ELE7EN_OK) &#123;\n        return -1;\n    &#125;\n\n    return 0;\n&#125;\nextern &quot;C&quot; void _init(void) &#123;\n    __android_log_print(4,&quot;YenKoc&quot;,&quot; i enter into init&quot;);\n     hook();\n&#125;\n\n\n&#x2F;&#x2F; 编译生成后在.init_array段 [名字可以更改]\n&#x2F;*__attribute__((__constructor__)) static void pp_init() &#123;\n    PPLOGD(&quot;Enter pp_init......&quot;);\n&#125;\n *&#x2F;\n&#x2F;&#x2F; jni_onload方法\n&#x2F;*\njint JNI_OnLoad(JavaVM *vm, void *reserved) &#123;\n\n    JNIEnv *env &#x3D; NULL;\n\n    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_4) !&#x3D; JNI  _OK) &#123;  &#x2F;&#x2F;判断 JNI 版本是否为JNI_VERSION_1_4\n        return JNI_EVERSION;\n    &#125;\n\n\n\n    return JNI_VERSION_1_4;\n&#125;\n *&#x2F;\nextern &quot;C&quot; JNIEXPORT jstring JNICALL\nJava_com_example_kanxuexposedso1_MainActivity_stringFromJNI(\n        JNIEnv* env,\n        jobject &#x2F;* this *&#x2F;) &#123;\n    std::string hello &#x3D; &quot;Hello from C++&quot;;\n    return env-&gt;NewStringUTF(hello.c_str());\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里讲几点，一个是关于路径问题，路径的话，实际上就是/da ta/app/包名的变化/lib/arm/下的so文件名，这里直接adb进入查看就好了，问题一般不大，然后就是符号名，c++是有符号修饰，直接ida打开看，或者objection也可以，目前还是为了去寻找地址，剩下就是我们将hook逻辑都放在init段了，这样就可以直接启动，其他initarray和jnionload也在里面。</p>\n</li>\n<li><p>xposed逻辑</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.example.kanxuexposedso1;\n\nimport android.util.Log;\n\nimport de.robv.android.xposed.IXposedHookLoadPackage;\nimport de.robv.android.xposed.XC_MethodHook;\nimport de.robv.android.xposed.XposedBridge;\nimport de.robv.android.xposed.XposedHelpers;\nimport de.robv.android.xposed.callbacks.XC_LoadPackage;\n\npublic class Xmodule implements IXposedHookLoadPackage &#123;\n    @Override\n    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123;\n        if(lpparam.packageName.equals(&quot;com.example.hooksoexample01&quot;))\n        &#123;\n            Class systemClass&#x3D;lpparam.classLoader.loadClass(&quot;java.lang.Runtime&quot;);\n            XposedBridge.hookAllMethods(systemClass, &quot;loadLibrary0&quot;, new XC_MethodHook() &#123;\n                @Override\n                protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;\n                    super.beforeHookedMethod(param);\n                &#125;\n\n                @Override\n                protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;\n                    super.afterHookedMethod(param);\n                    String libname&#x3D;(String)param.args[1];\n                    Log.e(&quot;YenKoc::&quot;,libname);\n                    if(libname.indexOf(&quot;native-lib&quot;)!&#x3D;-1)\n                    &#123;\n                        System.load(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;b.so&quot;);\n                    &#125;\n\n\n                &#125;\n            &#125;);\n\n        &#125;\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里indexOf差点把我坑了，这里是指括号里面的在libname中的下标，之前一直搞反了。</p>\n</li>\n</ul>\n","feature":null,"text":"前言吐槽下，妈的，应该是框架本身的bug，好像hook自己编写的函数无参数的话，就会莫名报错，这里耽误了我几个小时，最终才发现了这个问题，鬼知道我开关机了几次妈的。 正式开始 被hook的app的核心逻辑 #include &lt;jni.h&gt; #include &lt;s...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":9,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"xposed","slug":"xposed","count":2,"path":"api/tags/xposed.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%A7%8B\"><span class=\"toc-text\">正式开始</span></a></li></ol>","author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""},"mapped":true,"prev_post":{"title":"2015阿里移动安全挑战赛5道题writeup","uid":"48c7547c87104b3665dc18f2c480b135","slug":"阿里移动安全挑战赛5道题","date":"2021-07-28T03:15:34.000Z","updated":"2021-07-28T03:19:57.229Z","comments":true,"path":"api/articles/阿里移动安全挑战赛5道题.json","keywords":null,"cover":"https://w.wallhaven.cc/full/dg/wallhaven-dg2dog.jpg","text":"Alicrackme_1jeb打开 逻辑非常简单就是调用了两个方法，返回一张表，和密文，而我们的输入是作为表的下标去进行检索。 不过在用frida dump下结果后，发现竟然是中文，我还想转换成字节数组，后面发现一个索引对一个中文， 直接写脚本撸就行 public class g...","link":"","photos":[],"count_time":{"symbolsCount":848,"symbolsTime":"1 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":9,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"reverse","slug":"reverse","count":16,"path":"api/tags/reverse.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}},"next_post":{"title":"xposed插件编写01","uid":"2baa56a271382e4f44c5cafacec7639e","slug":"xposed插件编写01","date":"2021-07-25T11:46:40.000Z","updated":"2021-07-25T12:26:22.976Z","comments":true,"path":"api/articles/xposed插件编写01.json","keywords":null,"cover":"https://th.wallhaven.cc/lg/8o/8oky1j.jpg","text":"前置准备两个apk（一个xposed模块，一个要hook的apk） xposed模块准备 直接选择nativec++创建就行，然后就是配置需要注意 在app目录下的build.gradle文件中修改这几点 externalNativeBuild &#123; cmake &#12...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"AndroidReverse","slug":"AndroidReverse","count":9,"path":"api/categories/AndroidReverse.json"}],"tags":[{"name":"xposed","slug":"xposed","count":2,"path":"api/tags/xposed.json"}],"author":{"name":"YenKoc","avatar":"https://avatars.githubusercontent.com/u/52554268?s=400&u=e21e2b4ac372eaf3c2bc9c720c1ac24f974e936a&v=4","link":""}}}